**戰鬥標準流程**：
Player 觸碰了 Enemy(BattleTrigger) -> 將 [Player 隊伍、Enemy] 打包轉移至 BattleScene。
BattleUnit Member, Enemy 的圖像生成至正確的位置，並顯示他們的 HealthUI。
BattleLog 顯示 [戰鬥開始]，進入[玩家規劃階段]。
[玩家規劃階段]：
(1) 玩家可以點擊 [前衛] ，ActionButtonUI 開始運作，顯示 [前衛] 的專屬按鈕。
(2) 玩家也可以點選 [遠1] ，ActionButtonUI 開始運作，顯示 [遠1] 的專屬按鈕。
點擊攻擊按鈕，進入 [玩家選擇目標階段]。
[前衛] 的 [玩家選擇目標階段]：選擇 Enemy[前衛] 攻擊目標 -> ActionSlotUI 格子1 會顯示 [前衛]攻擊。
[遠程] 的 [玩家選擇目標階段]：選擇 Enemy[前衛] 攻擊目標 -> 選擇 ActionSlotUI 格子1~4。
(1) 若選擇 ActionSlotUI 格子1 -> ActionSlotUI 格子1 會顯示 [遠程]攻擊。
(2) 若選擇 ActionSlotUI 格子2 -> ActionSlotUI 格子2 會顯示 [遠程]攻擊。
[玩家規劃階段] -> 點擊 「回合結束」 按鈕，輪到 [敵人回合]。
BattleLog 顯示 輪到 [敵人回合] -> EnemyBattleAI 開始運作，運作完畢 -> 進入 [行動執行階段]
BattleLog 顯示 [行動執行階段]，並且開始顯示 成員 [誰] 做 [什麼] 行動、敵人做 [誰] 做 [什麼] 行動。
[行動執行階段]：
玩家[前衛] 行動格1 執行 -> 敵人[前衛] 行動格1 執行 ->  玩家[遠程] 行動格1 執行 -> 敵人[遠程] 行動格1 執行 -> 玩家[前衛] 行動格2 執行 -> 敵人[前衛] 行動格2 執行 ->  玩家[遠程] 行動格2 執行 -> 敵人[遠程] 行動格2 執行 -> ......。
若是敵人全部陣亡 -> BattleLog 顯示 [戰鬥勝利]，BattleEndUI 運作，勝利Panel。
若是我方全部陣亡 -> BattleLog 顯示 [戰鬥失敗]，BattleEndUI 運作，失敗Panel。
若是雙方皆未全部陣亡 -> BattleLog 顯示 [玩家規劃階段]。
並繼續戰鬥，直至其中一方全部陣亡。

**戰鬥標準邏輯**：
不論敵我只能攻擊 [前衛]。
一個回合只有4個行動格，每個行動格只能放置 2次 行動。
[前衛] 每個回合有 4個 行動格，每個行動格可以進行 1次 行動。
[遠1] 每個回合可以進行 2次 行動。
[遠2] 每個回合可以進行 2次 行動。
當 [前衛] ActionSlotUI 格子1~4 輸入完後，專屬按鈕將會變成灰色，無法點擊。
當 [遠1] ActionSlotUI 格子1~4 已經輸入 2格後，專屬按鈕將會變成灰色，無法點擊。
當 [遠2] ActionSlotUI 格子1~4 已經輸入 2格後，專屬按鈕將會變成灰色，無法點擊。
玩家有4個行動格，敵人也有4個行動格。

修改版本：
**戰鬥標準流程**
Player 觸碰了 Enemy(BattleTrigger) -> 將 [Player 隊伍、Enemy] 打包轉移至 BattleScene。
BattleUnit Member, Enemy 的圖像生成至正確的位置，並顯示他們的 HealthUI。
BattleLog 顯示 [戰鬥開始]，進入[玩家規劃階段]。
[玩家規劃階段]：
如果[後勤]存在，則隨時可以使用[指揮官技能]，不佔用行動格。
[前衛] `Phase 1` 選擇 -> [進攻] -> [進攻]誰？；{ActionSlotUI 格子1 會顯示 [前衛]攻擊}
[遠程] `Phase 1` -> 選擇誰(遠1 or 遠2) -> [進攻] -> [進攻]誰？；{ActionSlotUI 格子1 會顯示 [遠1 or 遠2]攻擊}
[前衛] `Phase 2` 選擇 -> [進攻] -> [進攻]誰？；{ActionSlotUI 格子2 會顯示 [前衛]攻擊}
......直至 [遠程] `Phase 4`
[玩家規劃階段] -> 點擊 「回合結束」 按鈕，輪到 [敵人回合]。
BattleLog 顯示 輪到 [敵人回合] -> EnemyBattleAI 開始運作，運作完畢 -> 進入 [行動執行階段]
BattleLog 顯示 [行動執行階段]，並且開始顯示 成員 [誰] 做 [什麼] 行動、敵人做 [誰] 做 [什麼] 行動。
[行動執行階段]：
玩家[前衛] 行動格1 執行 -> 敵人[前衛] 行動格1 執行 ->  玩家[遠程] 行動格1 執行 -> 敵人[遠程] 行動格1 執行 -> 玩家[前衛] 行動格2 執行 -> 敵人[前衛] 行動格2 執行 ->  玩家[遠程] 行動格2 執行 -> 敵人[遠程] 行動格2 執行 -> ......。
若是敵人全部陣亡 -> BattleLog 顯示 [戰鬥勝利]，BattleEndUI 運作，勝利Panel。
若是我方全部陣亡 -> BattleLog 顯示 [戰鬥失敗]，BattleEndUI 運作，失敗Panel。
若是雙方皆未全部陣亡 -> BattleLog 顯示 [玩家規劃階段]。
並繼續戰鬥，直至其中一方全部陣亡。

**戰鬥標準邏輯**：
不論敵我只能攻擊 [前衛]。(技能除外)
[玩家規劃階段]由系統自動播放：[前衛] `Phase 1` -> [遠程] `Phase 1` -> [前衛] `Phase 2` ...... -> [遠程] `Phase 4`
[玩家規劃階段]可以跳過該行動格不做任何行動。(補充：[跳過]按鈕)
[前衛]每個回合有 4個 行動格，每個行動格可以進行 1次 行動。
[遠1]每個回合可以進行 2次 行動。
[遠2]每個回合可以進行 2次 行動。
如果[後勤]存在，則隨時可以使用[指揮官技能]，不佔用行動格。
如果[遠程]兩人都存在，當其中一名行動 2次後，系統自動跳過已經行動 2次 的遠程。
如果[遠程]不存在，系統直接跳過，不顯示 [遠程] `Phase 1`。
如果[遠程]只存在一人，行動 2次後，系統自動跳過。


### 戰鬥系統：

**戰鬥系統核心資料結構**
1. BattleEnums.cs(遊戲字典)：
(1) 戰鬥角色職責：[前衛][遠1][遠2][後勤]
(2) 玩家可執行的行動類型：[攻擊][防禦][休息][技能][道具][交換位置][指揮官技能][結束回合]
(3) 回合管理器的狀態：[戰鬥開始][玩家規劃階段][玩家選擇目標階段][玩家選擇行動格階段][敵人回合][行動執行階段][戰鬥勝利][戰鬥失敗]

2. EnemyDataSO.cs (ScriptableObject)：
(1) 敵人基礎模板 (由開發者在Unity編輯器中設定)
*   **基礎資訊**: 敵人ID (獨一無二的編號)、敵人名稱、敵人圖像 (`Sprite` 引用)。
*   **基礎屬性**: 基礎血量、基礎攻擊力、體力(攻擊、施放技能消耗)、攻擊距離。
*   **技能槽位**: 從技能腳本中挑選技能ID輸入。
*   **物品掉落**: 會掉落的物品，如金錢、物品。

3. BattleEncounterSO.cs (戰鬥遭遇和配置)
介紹：它可以讓您把一場「戰鬥」打包成一個檔案。
(1) 隊伍配置：引用 `EnemyDataSO` 來定義敵方隊伍的組成、數量與初始位置，並將此配置提供給 `BattleManager`。
(2) 獎勵計算：根據配置的敵人，預先計算戰鬥勝利後的總獎勵，並將結果傳輸給 `BattleEndUI`。

4. ActionPlan.cs(資料容器)：
介紹：用於儲存單一、已規劃行動的數據結構。
(1) 行動數據：儲存一個行動的完整資訊，包含行動發起者、行動類型、行動目標。
(2) 階段索引：包含一個 `phaseIndex` 屬性 (值為 1-4)，標示此行動歸屬於回合中的哪一個行動階段。
(3) 傳遞資料：將自身作為數據包傳遞給 `TurnActionPlanner` 進行排程。

5. UnitStateSnapshot.cs (狀態快照容器)：
介紹：一個輕量級的資料容器，用於儲存單一戰鬥單位在特定時間點（通常是回合開始時）的關鍵狀態。
(1) 狀態儲存: 儲存目標單位的唯一標識符 (UnitID) 和該時間點的體力值 (Stamina)。未來也可擴展至其他可變資源（如魔力、怒氣等）。

---

**Prefab (預製件盒 - 遊戲世界的實體零件)**
1. BattleUnit.cs(戰鬥單位)：
介紹：附加於角色 Prefab 上的核心組件，代表一個可參與戰鬥的獨立單位，處理所有即時戰鬥狀態。它是整個戰鬥單位的數據與邏輯中心。
(1) 狀態管理：初始化單位屬性、處理傷害計算、判定單位陣亡、執行位置變更。提供公開的方法供 TurnManager 調用，用於直接修改自身的當前狀態。
* (int amount): 扣除指定數量的體力。
* (UnitStateSnapshot snapshot): 根據傳入的快照，將自身的體力等狀態恢復到快照中的數值。
(2) 狀態反饋：提供接口以改變自身視覺外觀，用於顯示「可被選為目標」或「不可選」等狀態。
(3) 點擊事件：處理自身的點擊事件，並將事件通知 `BattleUIManager`。
(4) 數據傳遞：在初始化時，將自身的基礎數據（如最大血量）傳遞給被引用的 `HealthUI` 組件。在受到傷害時，調用 `HealthUI` 的方法來更新血條顯示。

2. ActionButtonUI.cs (萬用按鈕)：
介紹：一個標準化的、可重用的UI按鈕模板。
(1) **事件傳遞**: 被點擊時，通知 `BattleUIManager` 玩家選擇了何種行動。
(2) **內容顯示**: 包含可配置的圖像與文字，用於顯示具體行動的資訊。
(3) **交互組件**: 內含一個標準的 `Button` 元件。

3. ActionSlotUI.cs(單一行動格內容)：
介紹：在戰術規劃板上，負責視覺化顯示一個已規劃行動的UI元件。
(1) 視覺化呈現：接收一個 `ActionPlan` 物件，並根據其數據更新自身的圖示與文字。
(2) 取消按鈕：當此取消按鈕被點擊時，它會將自身的階段索引（1-4）以及陣營信息（玩家方）回報給 BattleUIManager。

4. HealthUI.cs(血條)：
介紹：掛載於 `BattleUnit` 上的UI組件，用於顯示其生命值。
(1) 狀態追蹤：持續追蹤目標 `BattleUnit` 的當前血量。
(2) 更新顯示：在目標血量發生變化時，即時更新UI上的血條顯示。

5. BattleTrigger.cs (戰鬥觸發器)：
介紹：在非戰鬥場景中用於啟動戰鬥的觸發器。
(1) 數據引用：持有一個 `BattleEncounterSO` 的引用。
(2) 觸發戰鬥：當玩家角色與其發生交互時，通知 `GameManager` 啟動戰鬥，並將持有的 BattleEncounterSO 數據傳遞出去。

---

**UI (使用者介面盒 - 玩家的操作面板)**
(所有UI面板的職責均為：**接收來自 `BattleUIManager` 的指令來顯示或隱藏，並將玩家的輸入回報給 `BattleUIManager`**。)
1. ActionPanelUI.cs(行動按鈕面板)：
介紹：容納並管理當前所選角色所有可用行動按鈕的面板。
(1) 動態顯示：根據當前選擇的角色職責（[前衛]、[遠1]、[遠2]、[後勤]），顯示對應的專屬行動按鈕。
* [前衛]：攻擊、防禦、休息、技能、道具、位置交換。
* [遠1]：攻擊、技能、休息、道具、位置交換。
* [遠2]：攻擊、技能、休息、道具、位置交換。
* [後勤]：指揮官技能。(這個按鈕的操作獨立於行動格規劃。)
(2) 狀態同步：根據 `BattleRules` 的判斷結果，將不滿足使用條件(如行動次數耗盡、體力不足、距離不對、指揮官技能已使用)的按鈕設置為不可點擊的灰色狀態。

2. ActionSlotPanelUI.cs(戰術規劃板)：
介紹：視覺化呈現本回合所有行動規劃的面板，並在特定階段提供輸入功能。
(1) 行動格概念：一個回合由 4 個對稱的「行動階段」(Phase) 組成。玩家與敵人雙方都擁有這 4 個行動格的規劃權。此面板專門用於顯示玩家方的規劃。
(2) 結構生成：在畫面中生成代表4個行動階段的槽位。每個槽位應能**動態地**容納和顯示來自 [前衛] 或 [遠程] 的行動 (`ActionSlotUI`)。如果某個職位（如所有[遠程]單位）在隊伍中不存在，則對應的行動格區域不應顯示或應保持為空。
(3) 規劃更新：根據 `TurnActionPlanner` 中儲存的玩家方 `ActionPlan` 列表，更新所有 `ActionSlotUI` 的顯示內容。如果某個行動不存在，對應的UI應為空白（包含行動圖示和取消按鈕的可見性）。
(4) 處理點擊事件：當 `TurnManager` 進入 `[玩家選擇行動格階段]` 時，此面板上**符合條件**的 `ActionSlotUI` 應變為可交互狀態（例如高亮）。當玩家點擊其中一個時，它需要能將對應的階段索引（1-4）回報給 `BattleUIManager`。

3. BattleEndUI.cs(戰鬥結算畫面)：
介紹：顯示戰鬥結束後結果的UI介面。
(1) 顯示勝利：獲勝後顯示結算UI和退出按鈕。
(2) 顯示失敗：我方全滅時，顯示失敗面板與退出按鈕。

4. BattleLog.cs(戰鬥日誌)：
介紹：時間順序記錄並顯示戰鬥過程中所有關鍵事件的文本日誌。
(1) 事件記錄：接收戰鬥中各個階段轉換、行動執行、傷害造成等事件，並將其格式化為文字記錄。
(2) 日誌顯示：提供一個可滾動的文本區域，讓玩家可以回顧戰鬥過程。

5. BattleUI.cs(戰鬥場景UI總集)：
介紹：集合了戰鬥場景中所有全局性UI按鈕的管理器。
(1) 取消按鈕：在[玩家選擇目標階段]提供取消操作的功能。
(2) 回合結束按鈕：提供一個讓玩家可以隨時結束[玩家規劃階段]並進入下一流程的按鈕。
(3) 清空規劃按鈕：提供一個「重置規劃」的按鈕。點擊後，會通知 BattleUIManager 觸發「清空所有玩家規劃」的事件。
(4) 系統按鈕：戰鬥系統專用UI，可以開啟系統功能。(未實作)
(5) 人物按鈕：顯示人物訊息UI。(未實作)

---

**Manager (管理器)**
1. TurnManager.cs(回合、邏輯管理器)：
介紹：戰鬥流程的核心控制器，使用狀態機來驅動整個戰鬥的節奏與階段轉換。
(1) 狀態機管理：依序切換並管理 `[玩家規劃階段]`, `[敵人回合]`, `[行動執行階段]` 等戰鬥狀態。
(2) 階段驅動與協調：
*   進入 [玩家規劃階段]：
    * 命令 BattleLog 顯示「玩家規劃階段」開始。
    * 命令 CharacterStateRule 執行所有單位體力回滿的邏輯。
    * 命令 BattleUIManager 顯示戰術規劃相關的UI（如 ActionPanelUI, ActionSlotPanelUI），並重置UI狀態。
*   進入 [敵人回合]： 
    * 命令 BattleLog 顯示「敵人回合」開始。
    * 調用 EnemyBattleAI 的接口，命令其為所有敵方單位規劃本回合的行動。
    * 等待 EnemyBattleAI 完成規劃後，自動轉換至下一階段。
*   進入 [行動執行階段]：
    *   **介紹**：此階段的核心是按照一個固定的、交錯的順序，來執行雙方已經規劃好的行動。
    *   命令 BattleLog 顯示「行動執行階段」開始。
    *   **執行迴圈**：系統將從行動階段 1 循環至 4。在每一個階段中，嚴格遵循以下順序執行單一行動：
        1.  **玩家[前衛]行動**：**查詢** `TurnActionPlanner` 中是否存在屬於玩家方、職責為[前衛]、且階段索引匹配的 `ActionPlan`。**如果存在**，則命令 `BattleActions` 執行。
        2.  **敵人[前衛]行動**：**查詢** `TurnActionPlanner` 中是否存在屬於敵人方、職責為[前衛]、且階段索引匹配的 `ActionPlan`。**如果存在**，則命令 `BattleActions` 執行。
        3.  **玩家[遠程]行動**：**查詢** `TurnActionPlanner` 中是否存在屬於玩家方、職責為[遠程]（[遠1]或[遠2]）、且階段索引匹配的 `ActionPlan`。**如果存在**，則命令 `BattleActions` 執行。
        4.  **敵人[遠程]行動**：**查詢** `TurnActionPlanner` 中是否存在屬於敵人方、職責為[遠程]、且階段索引匹配的 `ActionPlan`。**如果存在**，則命令 `BattleActions` 執行。
    *   在**每一個單一行動**執行完畢後，都會立即向 `BattleRules` 查詢戰鬥是否已滿足勝利或失敗條件。若滿足，則立刻中斷執行迴圈，進入戰鬥結算。
    *   如果某個順位的行動不存在（例如該方沒有遠程單位，或沒有在該階段規劃行動），則直接跳過，執行下一個順位的行動。
    *   當 4 個行動階段全部執行完畢後，轉換至下一個[玩家規劃階段]。
(3) 玩家輸入的處理與轉化 (狀態機詳細流程)：
*   **事件 (1) - 玩家點擊角色 (`BattleUnit`)**:
    1.  `BattleUIManager` 回報「玩家選擇了角色A」。
    2.  `TurnManager` 命令 `BattleUIManager` 顯示角色A對應的專屬行動按鈕。
*   **事件 (2) - 玩家點擊行動按鈕 (如「攻擊」)**:
    1.  `BattleUIManager` 回報「玩家為角色A選擇了『攻擊』行動」。
    2.  `TurnManager` **立即轉換至 `[玩家選擇目標階段]`**。
    3.  `TurnManager` 向 `BattleRules` 查詢此次行動的「合法目標列表」。
    4.  `TurnManager` 將目標列表交給 `BattleUIManager`，命令其在畫面上高亮標示出可被選擇的目標。
*   **事件 (3) - 玩家點擊合法目標**:
    1.  `BattleUIManager` 回報「玩家為角色A的『攻擊』行動選擇了目標B」。
    2.  `TurnManager` **立即轉換至 `[玩家選擇行動格階段]`**。
    3.  `TurnManager` 向 `BattleRules` 查詢角色A「當前可用的行動格列表」。
    4.  `TurnManager` 將可用的行動格列表交給 `BattleUIManager`，命令其高亮標示出**可供選擇的行動格 (`ActionSlotUI`)**。
*   **事件 (4) - 玩家點擊可用行動格**:
    1.  `BattleUIManager` 回報「玩家選擇了行動格3」。
    2.  `TurnManager` 此時已集齊所有資訊（發起者：角色A，行動：攻擊，目標：目標B，階段索引：3）。
    3.  資源預扣: TurnManager 向 BattleRules 查詢該行動的體力消耗，然後命令行動發起者 (BattleUnit) 扣除對應的體力。
    3.  將上述資訊打包成一個 `ActionPlan` 物件，並交給 `TurnActionPlanner` 儲存。
    4.  `TurnManager` **狀態重新回到 `[玩家規劃階段]`**，等待玩家下一次的輸入。
*   **事件 (5) - 玩家點擊單一行動格的「取消」按鈕**:
    1.  `BattleUIManager` 回報「請求取消玩家在行動格3的行動」。
    2.  TurnManager 從 TurnActionPlanner 獲取並移除該行動格的 ActionPlan。
    3.  資源返還: TurnManager 根據被移除的 ActionPlan，向 BattleRules 查詢其體力消耗，然後命令行動發起者 (BattleUnit) 返還對應數量的體力。
    4.  TurnManager 命令 BattleUIManager 更新UI，並刷新所有行動按鈕的狀態。
*   **事件 (6) - 玩家點擊「清空規劃」按鈕**:
    1. BattleUIManager 回報「請求清空所有玩家規劃」。
    2. TurnManager 命令 TurnActionPlanner 移除所有玩家方的 ActionPlan。
    3. 從快照恢復: TurnManager 命令 CharacterStateRule 執行「從快照恢復所有單位狀態」的邏輯。
    4. TurnManager 命令 BattleUIManager 更新整個UI介面。
(4) 勝負流程終結：
*   當從 `BattleRules` 得知勝利或失敗條件已達成時，立即中斷當前流程。
*   進入 `[戰鬥勝利]` 或 `[戰鬥失敗]` 狀態。
*   命令 `BattleLog` 顯示對應的結果。
*   命令 `BattleUIManager` 顯示 `BattleEndUI` 的勝利或失敗面板，結束戰鬥循環。

2. BattleManager.cs(戰鬥場景總控制器。)：
介紹：負責整個戰鬥場景的初始化設置與資源管理。
(1) 數據載入：戰鬥開始時，讀取玩家隊伍數據與傳入的 `BattleEncounterSO` 敵人數據。
(2) 忠實的單位實例化：根據讀取的隊伍數據，**僅實例化當前隊伍中實際存在的成員**。如果玩家隊伍只有 [前衛] 和 [遠1] 兩名成員，那麼在戰鬥場景中就只會生成這兩個 `BattleUnit`。系統的任何部分都不能假設一個職位必然存在。
(3) 數據分發：將生成的、**可能不完整的**單位列表 (`playerUnits`, `enemyUnits`) 提供給 `TurnManager` 和 `BattleRules` 等模組。
(4) 戰鬥結束處理：處理戰鬥結束後的獎勵發放與場景切換信號。

3. BattleUIManager.cs(系統協調)：
介紹：專職處理所有戰鬥UI顯示邏輯與玩家輸入傳遞的中介者。
(1) UI狀態同步：監聽 `TurnManager` 的狀態變更，並據此顯示、隱藏或更新對應的UI面板。
(2) 輸入中繼：接收來自各UI元件的點擊事件(如 `HealthUI`, `ActionPanelUI`, `ActionSlotPanelUI`, `BattleEndUI`, `BattleLog`)，將其打包成意圖明確的事件後，通知 `TurnManager`。
(3) 視覺反饋協調：根據 `TurnManager` 的指令，調用 `BattleUnit` 的接口來顯示目標選擇等視覺提示。

4. GameManager.cs(遊戲狀態管理器)：
介紹：遊戲最高層級的管理者，負責控制場景切換與跨場景的數據傳遞。
(1) 場景管理：執行戰鬥場景與非戰鬥場景之間的切換。
(2) 數據傳遞：接收 `BattleTrigger` 的戰鬥請求，並將 `BattleEncounterSO` 安全地傳遞給新場景的 `BattleManager`。

---

**戰鬥邏輯**
1. BattleRules.cs (戰鬥法典)：
介紹：作為戰鬥的「規則資料庫」與「仲裁者」，`BattleRules` 是一個被動的邏輯集合。它不主動發起任何行為，只負責儲存所有硬性規定，並精確地回答 `TurnManager` 提出的關於「是否可以做某事」的查詢。
**功能**：
(1)  **基於存在性的行動資格判定**:
*   提供一個核心方法，用於查詢指定角色 (`BattleUnit`) 在當前回合是否還有剩餘的行動機會。
*   內部邏輯嚴格遵守：[前衛]每回合可行動4次；[遠1]和[遠2]每回合各自可行動2次。此方法會通過查詢 `TurnActionPlanner` 中該角色的已規劃行動數量來進行判斷。
    **規則前提**：以下所有行動次數的規則，僅在對應職責的單位**實際存在於戰場上**時才適用。
    *   **如果** [前衛] 單位存在，它每回合可行動4次。
    *   **如果** [遠1] 單位存在，它每回合可行動2次。
    *   **如果** [遠2] 單位存在，它每回合可行動2次。
    *   如果某個職位的單位不存在，系統應直接忽略與其相關的所有行動次數規則。
*   當 `TurnManager` 請求顯示行動按鈕時，會調用此方法來決定按鈕是否應因「行動次數耗盡」而變為灰色。
(2)  **基於存在性的目標合法性與攻擊規則**:
*   提供一個核心方法，接收「攻擊者」與「行動類型」，返回一個「合法的目標列表」。
*   **唯一目標規則**: 實現「不論敵我，所有『攻擊』行動的目標只能是敵方隊伍的[前衛]單位」。
*   **指令失效規則**: 如果在 [行動執行階段]，輪到一個單位執行其預先規劃好的「攻擊」行動時，其指定的[前衛]目標已經陣亡，則該「攻擊」行動會被自動轉換為一個預設行動。
    * 若「攻擊」行動發起者是 [前衛]，其「攻擊」行動將被轉換為 「防禦」(其他行動不變)。
    * 若「攻擊」行動發起者是 [遠程]，其「攻擊」行動將被轉換為 「休息」(其他行動不變)。
*   **攻擊距離規則**: 在判斷目標合法性時，會一併檢查攻擊者的職責與攻擊距離。例如，若[遠1]的攻擊距離不足，則即使目標是[前衛]，此方法依然會返回一個空列表，表示沒有合法的攻擊目標。
(3)  **基於存在性的行動格規劃規則**:
*   提供方法以驗證行動格的放置是否合法。
*   實現核心規則：「在同一個行動階段（Phase 1-4），只能有一名[遠程]單位（[遠1]或[遠2]）規劃行動」。當玩家試圖為[遠程]單位選擇行動格時，`TurnManager` 會調用此方法，傳入該行動格的索引，`BattleRules` 會查詢 `TurnActionPlanner` 以確定該階段是否已被另一名[遠程]單位佔用。
    *   **遠程衝突規則**：此規則僅在**玩家隊伍中同時存在 [遠1] 和 [遠2] 單位時**才觸發。規則內容為：「在同一個行動階段，只能有一名[遠程]單位規劃行動」。
    *   **如果**玩家隊伍中只有一名[遠程]單位（例如只有[遠1]），則該單位可以在任何允許的行動格中規劃其行動，無需進行衝突檢查。
*   提供一個方法，接收一個角色(`BattleUnit`)作為參數，查詢 `TurnActionPlanner` 後，返回一個**該角色在本回合中尚未使用的、可用的行動格索引列表**（例如 `[2, 4]`）。`TurnManager` 會使用此列表來告知 `BattleUIManager` 哪些行動格應該高亮。
(4)  **勝利與失敗條件判定**:
*   提供兩個獨立的、清晰的方法：一個用於判斷勝利條件，另一個用於判斷失敗條件。
*   **勝利條件**: 檢查 `BattleManager` 提供的敵方單位列表 (`enemyUnits`) 是否所有成員都已陣亡。
*   **失敗條件**: 檢查 `BattleManager` 提供的我方單位列表 (`playerUnits`) 是否所有成員都已陣亡。
(5)  **單位陣亡後續處理規則**:
*   提供一個方法，用於處理單位陣亡後觸發的連鎖事件。
*   **位置替補規則**: 包含「[前衛]陣亡，[遠1]替補」和「[遠1]無人，[遠2]替補」等位置變動邏輯。
*   **行動刪除規則**: 當一個單位陣亡時，此方法會定義需要通知 `TurnActionPlanner` 將該單位所有尚未執行的後續行動全部從規劃中移除的邏輯。
(6)  **特殊技能使用規則**:
*   **指揮官技能**: 內部維護一個布爾值，記錄[指揮官技能]在本場戰鬥中是否已被使用。提供一個方法供 `TurnManager` 查詢，以決定是否顯示[指揮官技能]按鈕。

2. BattleActions.cs(行動邏輯)：
介紹：包含所有具體行動（如攻擊、防禦）實現邏輯的執行者。
(1) 執行行動：接收 `TurnManager` 的命令和一個 `ActionPlan`，並根據 `ActionPlan` 的內容執行具體的遊戲邏輯，如對目標造成傷害、為自身附加狀態等。
(2) 定義行動效果：
* 攻擊：消耗 3點 體力對敵人造成傷害。
* 防禦：該行動格受到傷害減半。
* 技能：(尚未設計)
* 道具：(尚未設計)
* 交換位置：[前衛]只能和[遠1]交換位置；[遠1]可以和[前衛]或[遠2]交換位置；[遠2]只能跟[遠1]交換位置；[後勤]無法進行交換。
* 指揮官技能：[指揮官技能]可以由[後勤]發動，一場戰鬥只能使用一次。(尚未設計)
(3) 判斷是否取消行動返還該行動格體力。

3. TurnActionPlanner.cs(回合行動規劃器)：
介紹：負責記錄與管理**玩家與敵人雙方**在[玩家規劃階段]與[敵人回合]所安排的所有行動。
功能：
(1) 統一儲存：提供一個 `List<ActionPlan>` ，用於儲存本回合**雙方**所有已規劃的行動。
(2) 精確提供行動：提供一個查詢方法，能根據 `TurnManager` 傳入的「階段索引」、「陣營(玩家/敵人)」、「角色職責(前衛/遠程)」等參數，精準地返回對應的 `ActionPlan`。
(3) 計數查詢：提供方法以計算某個 `BattleUnit` 已規劃的行動數量，供 `BattleRules` 判斷行動次數是否耗盡。

4. CharacterStateRule.cs：
介紹：管理戰鬥中角色在特定時間點的狀態變化規則。
(1) 體力恢復：提供一個方法，用於在[玩家規劃階段]開始時，將所有存活單位的體力恢復至全滿。此方法由 `TurnManager` 調用。
(**未來會再增加**)

5. EnemyBattleAI.cs(敵人進攻邏輯)：
介紹：負責在[敵人回合]為敵方單位規劃行動。
(1) 規劃行動：在[敵人回合]被 `TurnManager` 調用時，為所有敵方單位生成 `ActionPlan`，並將其添加到 `TurnActionPlanner` 中。AI需要遵循與玩家類似的規則（如前衛每階段行動、遠程行動分配等）。
(2) 每個行動格都使用攻擊行動，若體力耗盡，使用防禦。
(**未來再修改**)


### 隊伍系統：

**隊伍成員核心資料(資料層)**
1. MemberDataSO.cs (ScriptableObject)：
(1) 成員基礎模板 (由開發者在Unity編輯器中設定)
*   **基礎資訊**: 成員ID (獨一無二的編號)、成員名稱、成員圖像 (`Sprite` 引用)。
*   **基礎屬性**: 基礎血量、基礎攻擊力、體力(攻擊、施放技能消耗)、攻擊距離。
*   **技能槽位**: 從技能腳本中挑選技能ID輸入。
*   **成長規則**: 每級提升的血量、每級提升的攻擊力。(目前不需要，可註解)

2. PartyDatabase.cs (ScriptableObject)：
(1) 隊伍成員核心資料庫: 一個中央 ScriptableObject。
(2) 成員名冊: 包含遊戲中所有 `MemberDataSO` 的列表引用。
(3) 全局訪問: 在遊戲啟動時載入，提供全局靜態方法，讓其他系統可以方便地透過ID獲取任何成員的模板數據。

3. MemberInstance.cs (可序列化 Class)：
(1) 玩家擁有的成員個體 (用於存檔)
*   **關聯ID**: `memberDataSO_ID`，用來關聯到對應的 `MemberDataSO` 模板。
*   **唯一ID**: `instanceID`，每個實例都有獨一無二的識別碼。
*   **動態數據**: 等級、經驗值。(目前不需要，可註解)
*   **狀態屬性**: 當前HP、當前攻擊力 (根據等級計算後的值)。
(2) 可序列化為 JSON: 這個類別的物件會被寫入玩家的存檔中。

4. SkillData.cs (ScriptableObject)：
(1) Enums: 被動技能、主動技能、指揮官技能。
(2) 技能資料: ID、名稱、描述、是否為攻擊(若是-攻擊距離)、是否為回血(若是-使用距離)、是否為被動技能

5. SkillDatabase.cs (ScriptableObject)：
(1) 存放所有的技能，供調查使用。

---

**隊伍UI**
1. MemberCardUI (Prefab)：
(1) 可重用UI元件: 一個包含成員圖像、成員名稱和按鈕的獨立 Prefab。
(2) 數據填充: 有一個腳本，接收 `MemberInstance` 資料並更新卡片上的圖像和名稱。
(3) 狀態反饋: 包含被選中、在戰鬥隊伍中等不同的視覺狀態（例如發光邊框）。

2. MemberStatCardUI (Prefab)：
(1) 可重用UI元件: 一個包含成員圖像、成員名稱、攻擊力、體力、攻擊距離和按鈕的獨立 Prefab。
(2) 數據填充: 有一個腳本，接收 `MemberInstance` 資料並更新卡片上的圖像和名稱。
(3) 狀態反饋: 包含被選中、在戰鬥隊伍中等不同的視覺狀態（例如發光邊框）。

3. PartyHolderUI.cs (全部成員倉庫)：
(1) 顯示模式: 使用 `Scroll View` 搭配 `Grid Layout Group` 來顯示目前擁有的所有成員卡片。
(2) 點擊互動: 點擊任一成員卡片，會通知 `PartyDetailUI` 顯示其詳細資料。

4. PartyBattleUI.cs (戰鬥隊伍)：
(1) 顯示模式: 使用固定的容器（例如 `Horizontal Layout Group`）顯示當前出戰的成員卡片和基礎屬性(名稱、圖像、血量、攻擊力)。
(2) 互動操作: 支援點擊卡片查看詳細資料，以及拖曳卡片來交換戰鬥成員的順序。

5. PartyDetailUI.cs (成員詳細資料面板)：
(1) 顯示時機: 預設隱藏，點擊任一成員卡片時顯示。
(2) 數據展示: 顯示該成員的詳細數據（名稱、圖像、當前/最大HP、攻擊力、體力、攻擊距離）。
(3) 動態按鈕: 提供「上陣」或「卸下」按鈕，按鈕的功能和文字會根據該成員是否已在戰鬥隊伍中動態改變。
(4) 隱藏邏輯: 面板上有關閉按鈕；當整個隊伍介面關閉時，此詳細面板也應同步隱藏。

---

**隊伍管理器**
1. PartyManager.cs
(1) 核心邏輯: 管理玩家擁有的 `AllMembers` (所有成員實例列表) 和 `BattleParty` (戰鬥隊伍成員實例列表)，並限制戰鬥隊伍人數。
(2) 功能:
*   **加入/移除成員**: 處理 `MemberInstance` 的增減。
*   **戰鬥隊伍管理**: 指派成員上陣、從戰鬥隊伍中移除。
*   **排序**: 交換戰鬥成員的順序。
*   **狀態判斷**: 提供方法判斷是否有可戰鬥的成員 (HP > 0)。
(3) 事件系統:
*   提供一個全局的 `OnPartyUpdated` 事件，當隊伍資料（成員增減、順序變更）發生變化時觸發，通知所有相關UI進行刷新。
(4) 存檔與載入: 觸發 `JSONSaveManager` 來儲存或載入隊伍資料。

1. JSONSaveManager.cs(JSON 儲存、讀取系統)
(1) 序列化/反序列化: 專門負責將 `PartyManager` 中的 `MemberInstance` 列表轉換為 JSON 字串，或從 JSON 字串還原。
(2) 檔案管理:
*   將隊伍資料存為 JSON 檔。
*   從指定的路徑載入 JSON 檔。
*   管理存檔路徑，並檢查檔案是否存在。
(3) 資料驗證: (可選，但建議) 載入存檔時，檢查存檔中的 `memberDataSO_ID` 在當前的 `PartyDatabase` 中是否依然存在，避免因遊戲版本更新造成錯誤。

---

### **隊伍系統-重點回顧**

1.  **資料分層**: **ScriptableObject** 作為「設計藍圖」，**JSON** 作為玩家「進度存檔」。
2.  **UI模組化**: 核心是可重用的 **`MemberCardUI` Prefab**。
3.  **單一職責**: 系統完全專注於**成員的持有、升級和隊伍的編組**，移除了所有額外系統的耦合。
4.  **互動核心**: 玩家透過點擊查看詳情，並透過拖曳或按鈕進行隊伍管理。
5.  **穩健性**: 確保**腳本執行順序**正確，並做好**Unity編輯器內的UI連結**是成功運行的關鍵。