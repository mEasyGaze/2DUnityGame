好的，這是一個非常詳盡且結構清晰的戰鬥系統設計。基於您的需求，我將為您編寫所有相關的 C# 腳本。

這些腳本將嚴格遵循您設計的邏輯分離原則：資料、邏輯、UI 各司其職，並透過管理器進行協調。

---

### **1. 戰鬥系統核心資料結構**

#### **BattleEnums.cs**
這個腳本不需要是 `MonoBehaviour`，它只是一個定義，方便全局使用。

```csharp
using System;

// 戰鬥角色職責
public enum BattleRole
{
    Vanguard, // 前衛
    Ranged1,  // 遠1
    Ranged2,  // 遠2
    Support   // 後勤
}

// 單位可以執行的行動類型
public enum ActionType
{
    Attack,         // 攻擊
    Defend,         // 防禦
    Rest,           // 休息
    Skill,          // 技能
    Item,           // 道具
    Exchange,       // 交換位置
    Skip            // 跳過
}

// UI按鈕觸發的指令類型
public enum UICommandType
{
    CommanderSkill,     // 指揮官技能
    Back,               // 返回上一步
    EndTurn,            // 回合結束
    ResetAll,           // 清空規劃
    CancelSingleAction  // 取消單一行動
}

// 回合管理器的宏觀狀態
public enum BattleState
{
    Setup,              // 戰鬥準備階段
    PlayerPlanning,     // 玩家規劃階段
    EnemyTurn,          // 敵人回合
    ActionExecution,    // 行動執行階段
    Won,                // 戰鬥勝利
    Lost                // 戰鬥失敗
}

// 玩家規劃階段的微觀子狀態
public enum PlanningSubState
{
    None,                   // 無操作，等待流程推進
    SelectingRangedUnit,    // 正在等待玩家選擇行動的遠程單位
    SelectingAction,        // 正在等待玩家為已選單位選擇行動
    SelectingTarget,        // 正在等待玩家為已選行動選擇目標
    SelectingExchangeTarget // 正在等待玩家選擇交換位置的目標
}

// 數值代表了距離，方便計算
[Serializable]
public enum GridPosition
{
    PlayerSupport = 0,
    PlayerRanged2 = 1,
    PlayerRanged1 = 2,
    PlayerVanguard = 3,
    EnemyVanguard = 4,
    EnemyRanged1 = 5,
    EnemyRanged2 = 6,
    EnemySupport = 7,
    None = -1
}

public static class ActionTypeExtensions
{
    // "this ActionType type" 表示我們正在為 ActionType 這個枚舉擴充一個新方法
    public static string ToActionName(this ActionType type)
    {
        switch (type)
        {
            case ActionType.Attack:   return "攻擊";
            case ActionType.Defend:   return "防禦";
            case ActionType.Rest:     return "休息";
            case ActionType.Skill:    return "技能";
            case ActionType.Item:     return "道具";
            case ActionType.Exchange: return "交換";
            case ActionType.Skip:     return "跳過";
            default:                  return type.ToString(); // 作為備用選項
        }
    }
}
```

#### **EnemyDataSO.cs (ScriptableObject)**
敵人的靜態資料模板。

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewEnemyData", menuName = "Battle System/Enemy Data")]
public class EnemyDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string enemyID;
    public string enemyName;
    public Sprite enemyIcon;
    public GameObject enemyPrefab; // 戰鬥中使用的模型Prefab

    [Header("基礎屬性")]
    public int baseHealth;
    public int baseAttack;
    public int baseStamina;
    public int attackRange;

    [Header("技能槽位")]
    [Tooltip("輸入對應 SkillData 的技能ID")]
    public List<string> skillIDs;

    [Header("物品掉落")]
    public int goldDrop;
    // public List<ItemDropInfo> itemDrops; // 未來可擴充為物品掉落
}
```

#### **BattleEncounterSO.cs (ScriptableObject)**
定義一場戰鬥遭遇的配置。

```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class EnemyPositioning
{
    public EnemyDataSO enemyData;
    public BattleRole role; // 指定這個敵人在戰鬥中的職責
}

[CreateAssetMenu(fileName = "NewBattleEncounter", menuName = "Battle System/Battle Encounter")]
public class BattleEncounterSO : ScriptableObject
{
    [Header("敵人隊伍配置")]
    public List<EnemyPositioning> enemyTeam;

    [Header("戰鬥獎勵")]
    public int totalGoldReward;
    // public List<ItemReward> itemRewards; // 預計的物品獎勵

    // 這個方法可以在編輯器中自動計算總獎勵
    private void OnValidate()
    {
        int calculatedGold = 0;
        if (enemyTeam != null)
        {
            foreach (var enemyPos in enemyTeam)
            {
                if (enemyPos.enemyData != null)
                {
                    calculatedGold += enemyPos.enemyData.goldDrop;
                }
            }
        }
        totalGoldReward = calculatedGold;
    }
}
```

#### **ActionPlan.cs**
儲存單一行動的數據結構，不是 `MonoBehaviour`。

```csharp
using System;

public class ActionPlan
{
    public BattleUnit Source { get; }           // 行動發起者
    public ActionType Type { get; }             // 行動類型
    public int PhaseIndex { get; }              // 歸屬的行動階段 (1-4)
    public Guid TransactionID { get; }          // 關聯行動ID
    public GridPosition TargetPosition { get; } // 目標位置
    public BattleRole PlannedForRole { get; }

    // 構造函數也相應修改，它接收一個目標單位，但內部只儲存其位置
    public ActionPlan(BattleUnit source, BattleUnit target, ActionType type, int phaseIndex, BattleRole plannedForRole, Guid transactionID = default)
    {
        Source = source;
        Type = type;
        PhaseIndex = phaseIndex;
        // 如果傳入的 transactionID 是空的，則使用 Guid.Empty
        TransactionID = (transactionID == default) ? Guid.Empty : transactionID;
        // 如果傳入了目標，就記錄其當前位置；否則記錄為 None
        TargetPosition = (target != null) ? target.CurrentPosition : GridPosition.None;
        PlannedForRole = plannedForRole; // 儲存規劃時的職責
    }
}
```

---

### **2. Prefab 相關腳本**

#### **BattleUnit.cs**
附加在角色/敵人 Prefab 上的核心組件。

```csharp
using UnityEngine;
using UnityEngine.Events;

public class BattleUnit : MonoBehaviour
{
    // 靜態資料
    public MemberDataSO MemberData { get; private set; }
    public EnemyDataSO EnemyData { get; private set; }

    // 實例資料
    public MemberInstance MemberInstance { get; private set; }

    // 戰鬥相關屬性
    public BattleRole Role { get; private set; }
    public GridPosition CurrentPosition { get; set; }
    public int AttackRange { get; private set; }
    public bool IsPlayerTeam { get; private set; }
    public string UnitName { get; private set; }
    public int MaxHP { get; private set; }
    public int CurrentHP { get; private set; }
    public int CurrentAttack { get; private set; }
    public int MaxStamina { get; private set; }
    public int CurrentStamina { get; private set; }
    public bool IsDead { get; private set; } = false;

    private bool isDefending = false;

    [Header("元件連結")]
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private HealthUI healthUI;
    [SerializeField] private GameObject selectionHighlight;

    public UnityAction<BattleUnit> OnUnitClicked;

    public void Setup(MemberInstance instance, BattleRole role, GridPosition initialPosition)
    {
        MemberInstance = instance;
        MemberData = instance.BaseData;
        UnitName = MemberData.memberName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = MemberData.attackRange;
        IsPlayerTeam = true;
        
        MaxHP = instance.MaxHP;
        CurrentHP = instance.currentHP;
        CurrentAttack = instance.CurrentAttack;
        MaxStamina = instance.MaxStamina;
        CurrentStamina = instance.MaxStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = MemberData.memberIcon;
    }

    public void Setup(EnemyDataSO data, BattleRole role, GridPosition initialPosition)
    {
        EnemyData = data;
        UnitName = EnemyData.enemyName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = data.attackRange;
        IsPlayerTeam = false;
        
        MaxHP = data.baseHealth;
        CurrentHP = data.baseHealth;
        CurrentAttack = data.baseAttack;
        MaxStamina = data.baseStamina;
        CurrentStamina = data.baseStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = EnemyData.enemyIcon;
    }
    
    public void TakeDamage(int damage)
    {
        if (IsDead) return;
        if (isDefending) damage /= 2;
        CurrentHP -= damage;
        BattleLog.Instance.AddLog($"{UnitName} 受到 {damage} 點傷害。");
        if (CurrentHP <= 0)
        {
            CurrentHP = 0;
            Die();
        }
    }

    private void Die()
    {
        IsDead = true;
        gameObject.SetActive(false);
        BattleLog.Instance.AddLog($"{UnitName} 已陣亡！");
    }

    public void ConsumeStamina(int amount)
    {
        CurrentStamina = Mathf.Max(0, CurrentStamina - amount);
    }

    public void RestoreStamina(int amount)
    {
        CurrentStamina = Mathf.Min(MaxStamina, CurrentStamina + amount);
    }

    public void SetStamina(int value)
    {
        CurrentStamina = Mathf.Clamp(value, 0, MaxStamina);
    }

    public void SetNewPosition(GridPosition newPosition)
    {
        this.CurrentPosition = newPosition;
        // 我們不在這裡加日誌，統一由 BattleActions 或 BattleManager 在執行操作時記錄，避免重複。
    }

    public void SetRole(BattleRole newRole)
    {
        this.Role = newRole;
    }

    private void OnMouseDown()
    {
        OnUnitClicked?.Invoke(this);
    }
    
    public void SetHighlight(bool state)
    {
        if (selectionHighlight != null) selectionHighlight.SetActive(state);
    }
    
    public void SetDefenseState(bool defending)
    {
        isDefending = defending;
    }
}
```

#### **ActionButtonUI.cs**
萬用按鈕的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionButtonUI : MonoBehaviour
{
    [SerializeField] private Button button;
    [SerializeField] private TextMeshProUGUI buttonText;
    
    private ActionType actionType;
    
    public void Setup(ActionType type, System.Action<ActionType> onClickCallback)
    {
        buttonText.text = type.ToActionName();
        
        button.onClick.RemoveAllListeners();
        button.onClick.AddListener(() => onClickCallback(type));
    }
    
    public void SetInteractable(bool interactable)
    {
        button.interactable = interactable;
    }
}
```

#### **ActionSlotUI.cs**
單一行動格的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionSlotUI : MonoBehaviour
{
    [Header("內容UI")]
    [SerializeField] private Image icon;
    [SerializeField] private TextMeshProUGUI actionText;

    [Header("狀態物件")]
    [SerializeField] private GameObject emptyStateObject;
    [SerializeField] private GameObject filledStateObject;

    [Header("互動元件")]
    [SerializeField] private Button cancelButton;

    private ActionPlan currentPlan;

    // 簡化 Setup，因為我們不再需要點擊選擇格子的功能
    public void Setup(System.Action<ActionPlan> onCancelClicked)
    {
        cancelButton.onClick.RemoveAllListeners();
        cancelButton.onClick.AddListener(() =>
        {
            if (currentPlan != null)
            {
                onCancelClicked(currentPlan);
            }
        });
    }

    public void UpdateView(ActionPlan plan)
    {
        currentPlan = plan;
        if (plan == null)
        {
            emptyStateObject.SetActive(true);
            filledStateObject.SetActive(false);
        }
        else
        {
            emptyStateObject.SetActive(false);
            filledStateObject.SetActive(true);
            
            if (plan.Source != null)
            {
                if (plan.Source.MemberData != null) icon.sprite = plan.Source.MemberData.memberIcon;
                else if (plan.Source.EnemyData != null) icon.sprite = plan.Source.EnemyData.enemyIcon;
                
                actionText.text = $"{plan.Source.UnitName[0]} > {plan.Type.ToActionName()}";
            }
            else
            {
                actionText.text = "錯誤";
            }
        }
    }
}
```

#### **HealthUI.cs**
掛在 `BattleUnit` 上的血條 UI。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HealthUI : MonoBehaviour
{
    [SerializeField] private BattleUnit targetUnit;
    [SerializeField] private Slider healthSlider;
    [SerializeField] private TextMeshProUGUI healthText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if(targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (healthSlider != null)
        {
            healthSlider.minValue = 0;
            healthSlider.maxValue = 1;
        }
    }

    void Update()
    {
        if (targetUnit != null && !targetUnit.IsDead)
        {
            // 更新 Slider 的值 (0 到 1 之間)
            healthSlider.value = (float)targetUnit.CurrentHP / targetUnit.MaxHP;
            
            // 更新文字顯示
            if (healthText != null)
            {
                healthText.text = $"{targetUnit.CurrentHP} / {targetUnit.MaxHP}";
            }
            
            // 使血條始終面向攝影機
            transform.rotation = mainCamera.transform.rotation; 
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}
```

#### **BattleTrigger.cs**
戰鬥觸發器。

```csharp
using UnityEngine;

public class BattleTrigger : MonoBehaviour
{
    [SerializeField] private BattleEncounterSO battleEncounter;

    private void OnTriggerEnter(Collider other)
    {
        // 假設玩家物件帶有 "Player" 標籤
        if (other.CompareTag("Player"))
        {
            // 禁用觸發器避免重複觸發
            GetComponent<Collider>().enabled = false;
            
            // 通知 GameManager 啟動戰鬥
            GameManager.Instance.StartBattle(battleEncounter);
        }
    }
}
```

---

### **3. UI 管理腳本**

#### **ActionPanelUI.cs**
行動按鈕面板。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionPanelUI : MonoBehaviour
{
    [SerializeField] private GameObject panel;
    [SerializeField] private Transform buttonContainer;
    [SerializeField] private ActionButtonUI buttonPrefab;
    
    private List<ActionButtonUI> spawnedButtons = new List<ActionButtonUI>();
    private Dictionary<ActionType, ActionButtonUI> buttonMap = new Dictionary<ActionType, ActionButtonUI>();

    public void ShowPanel(BattleUnit unit, System.Action<ActionType> onActionSelected)
    {
        ClearButtons();
        
        // 根據角色職責決定可用的行動列表
        List<ActionType> availableActions = GetActionsForRole(unit.Role);

        foreach (var actionType in availableActions)
        {
            ActionButtonUI newButton = Instantiate(buttonPrefab, buttonContainer);
            newButton.Setup(actionType, onActionSelected);
            spawnedButtons.Add(newButton);
            buttonMap.Add(actionType, newButton);
        }
        
        panel.SetActive(true);
    }

    public void UpdateButtonStates(Dictionary<ActionType, bool> feasibility)
    {
        foreach (var pair in feasibility)
        {
            if (buttonMap.ContainsKey(pair.Key))
            {
                buttonMap[pair.Key].SetInteractable(pair.Value);
            }
        }
    }
    
    // 根據角色職責返回一個行動列表
    private List<ActionType> GetActionsForRole(BattleRole role)
    {
        switch (role)
        {
            case BattleRole.Vanguard:
            case BattleRole.Ranged1:
            case BattleRole.Ranged2:
                // 假設所有戰鬥單位都有這些基礎行動
                return new List<ActionType>
                {
                    ActionType.Attack,
                    ActionType.Defend,
                    ActionType.Rest,
                    ActionType.Exchange,
                    ActionType.Skip
                };
            // case BattleRole.Support: // 後勤的行動可以在這裡定義
            default:
                return new List<ActionType>();
        }
    }

    public void UpdateButtonStates(BattleUnit unit, BattleRules rules)
    {
        foreach (var btnUI in spawnedButtons)
        {
            // 簡化：這裡可以加入更複雜的規則，例如體力檢查
            // bool isInteractable = rules.CanPerformAction(unit, btnUI.ActionType);
            // btnUI.SetInteractable(isInteractable);
        }
    }

    public void HidePanel()
    {
        panel.SetActive(false);
        ClearButtons();
    }
    
    private void ClearButtons()
    {
        foreach (var btn in spawnedButtons)
        {
            Destroy(btn.gameObject);
        }
        spawnedButtons.Clear();
        buttonMap.Clear();
    }
}
```

#### **ActionSlotPanelUI.cs**
戰術規劃板。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionSlotPanelUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject panel;
    [SerializeField] private List<ActionSlotUI> vanguardSlots;
    [SerializeField] private List<ActionSlotUI> rangedSlots;
    [SerializeField] private List<GameObject> highlightObjects; // 8個高亮物件

    public void Initialize(System.Action<UICommandType, ActionPlan> onCommand)
    {
        // 為所有行動格設置取消回調
        foreach(var slot in vanguardSlots)
        {
            // 現在 Setup 只需一個參數，傳遞一個 Lambda 來呼叫 onCommand
            slot.Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
        foreach(var slot in rangedSlots)
        {
            // 同上
            slot.Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
    }
    
    public void UpdatePanel(TurnActionPlanner planner)
    {
        for(int i = 0; i < vanguardSlots.Count; i++)
        {
            int phaseIndex = i + 1;
            ActionPlan plan = planner.GetAction(phaseIndex, true, BattleRole.Vanguard);
            vanguardSlots[i].UpdateView(plan);
        }
        
        for(int i = 0; i < rangedSlots.Count; i++)
        {
            int phaseIndex = i + 1;
            ActionPlan plan = planner.GetRangedAction(phaseIndex, true);
            rangedSlots[i].UpdateView(plan);
        }
        
        panel.SetActive(true);
    }

    public void SetPlanningHighlight(int stepIndex) // stepIndex 是 0-7
    {
        for (int i = 0; i < highlightObjects.Count; i++)
        {
            if (highlightObjects[i] != null)
            {
                highlightObjects[i].SetActive(i == stepIndex);
            }
        }
    }
    
    public void HidePanel()
    {
        panel.SetActive(false);
    }
}
```

#### **BattleEndUI.cs**
戰鬥結算畫面。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BattleEndUI : MonoBehaviour
{
    [SerializeField] private GameObject victoryPanel;
    [SerializeField] private GameObject defeatPanel;
    [SerializeField] private TextMeshProUGUI rewardText;
    [SerializeField] private Button exitButton;

    private void Start()
    {
        exitButton.onClick.AddListener(OnExitButtonClicked);
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(false);
    }

    public void ShowVictory(int goldReward)
    {
        victoryPanel.SetActive(true);
        defeatPanel.SetActive(false);
        rewardText.text = $"獲得金幣: {goldReward}";
    }

    public void ShowDefeat()
    {
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(true);
    }

    private void OnExitButtonClicked()
    {
        // 通知 GameManager 返回主場景
        GameManager.Instance.EndBattle();
    }
}
```

#### **BattleLog.cs**
戰鬥日誌。

```csharp
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class BattleLog : MonoBehaviour
{
    public static BattleLog Instance { get; private set; }
    
    [SerializeField] private TextMeshProUGUI logText;
    [SerializeField] private ScrollRect scrollRect;
    private Queue<string> logMessages = new Queue<string>();
    private int maxMessages = 20;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public void AddLog(string message)
    {
        if (logMessages.Count >= maxMessages)
        {
            logMessages.Dequeue();
        }
        logMessages.Enqueue($"[{System.DateTime.Now:HH:mm:ss}] {message}");
        
        UpdateLogText();
    }

    private void UpdateLogText()
    {
        logText.text = string.Join("\n", logMessages);
        
        // 自動滾動到底部
        Canvas.ForceUpdateCanvases();
        scrollRect.verticalNormalizedPosition = 0f;
    }
}
```

#### **BattleUI.cs**
戰鬥場景 UI 總集。

```csharp
using UnityEngine;
using UnityEngine.UI;

public class BattleUI : MonoBehaviour
{
    [SerializeField] private Button endTurnButton;
    [SerializeField] private Button resetButton;
    [SerializeField] private Button backButton;

    // 將回調統一為一個，使用 UICommandType 來區分
    public void Setup(System.Action<UICommandType> onCommand)
    {
        endTurnButton.onClick.RemoveAllListeners();
        endTurnButton.onClick.AddListener(() => onCommand(UICommandType.EndTurn));
        
        resetButton.onClick.RemoveAllListeners();
        resetButton.onClick.AddListener(() => onCommand(UICommandType.ResetAll));
        
        backButton.onClick.RemoveAllListeners();
        backButton.onClick.AddListener(() => onCommand(UICommandType.Back));
    }
    
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        endTurnButton.interactable = interactable;
    }
    
    public void SetBackButtonVisible(bool visible)
    {
        backButton.gameObject.SetActive(visible);
    }

    public void SetResetButtonVisible(bool visible)
    {
        resetButton.gameObject.SetActive(visible);
    }
}
```

---

### **4. 管理器 (Managers)**

#### **TurnManager.cs**
回合與邏輯管理器，戰鬥的核心。

```csharp
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    public BattleState CurrentState { get; private set; }

    private BattleManager battleManager;
    private BattleUIManager uiManager;
    private TurnActionPlanner actionPlanner;
    private BattleRules battleRules;
    private BattleActions battleActions;
    private EnemyBattleAI enemyAI;
    private CharacterStateRule characterStateRule;

    private int currentPlanningStepIndex;
    private PlanningSubState currentSubState;
    private BattleUnit selectedUnitForAction;
    private ActionType selectedActionType;
    private List<BattleUnit> currentEligibleActors;

    public void Initialize(BattleManager bm, BattleUIManager uim, TurnActionPlanner ap, BattleRules br, BattleActions ba, EnemyBattleAI eai, CharacterStateRule csr)
    {
        battleManager = bm;
        uiManager = uim;
        actionPlanner = ap;
        battleRules = br;
        battleActions = ba;
        enemyAI = eai;
        characterStateRule = csr;
        currentEligibleActors = new List<BattleUnit>();
    }

    public void StartBattle()
    {
        BattleLog.Instance.AddLog("戰鬥開始！");
        SetState(BattleState.PlayerPlanning);
    }
    
    private void SetState(BattleState newState)
    {
        if (CurrentState == newState) return;
        CurrentState = newState;
        StartCoroutine(OnEnterState(newState));
    }
    
    private IEnumerator OnEnterState(BattleState state)
    {
        switch (state)
        {
            case BattleState.PlayerPlanning:
                BattleLog.Instance.AddLog("==== 新回合：玩家規劃階段 ====");
                actionPlanner.PrepareForNewTurn();
                characterStateRule.RestoreAllUnitStamina(battleManager.GetAllUnits());
                characterStateRule.RecordTurnStartStates(battleManager.GetAllUnits());
                uiManager.EnterPlayerPlanningState(actionPlanner);
                StartCoroutine(StartGuidedPlanning());
                break;
            case BattleState.EnemyTurn:
                BattleLog.Instance.AddLog("==== 敵人回合 ====");
                uiManager.EnterEnemyTurnState();
                enemyAI.PlanActions(battleManager.EnemyUnits, battleManager.PlayerUnits, actionPlanner, battleRules, battleActions.GetAttackStaminaCost());
                yield return new WaitForSeconds(1f);
                SetState(BattleState.ActionExecution);
                break;
            case BattleState.ActionExecution:
                BattleLog.Instance.AddLog("==== 行動執行階段 ====");
                uiManager.EnterActionExecutionState();
                StartCoroutine(ExecuteActions());
                break;
            case BattleState.Won:
                BattleLog.Instance.AddLog("★★ 戰鬥勝利 ★★");
                uiManager.ShowVictoryScreen(battleManager.EncounterData.totalGoldReward);
                break;
            case BattleState.Lost:
                BattleLog.Instance.AddLog("戰鬥失敗...");
                uiManager.ShowDefeatScreen();
                break;
        }
    }

    public void OnUnitClicked(BattleUnit unit)
    {
        if (currentSubState == PlanningSubState.SelectingRangedUnit)
        {
            if (currentEligibleActors.Contains(unit))
            {
                // 如果合法，才繼續執行後續流程
                selectedUnitForAction = unit;
                currentSubState = PlanningSubState.SelectingAction;
                ShowActionPanelForUnit(unit);
            }
            else
            {
                // 如果不合法，可以選擇忽略，或者給一個提示
                Debug.LogWarning($"點擊了非法的單位 {unit.UnitName}。請選擇高亮的遠程單位。");
                // 流程不會被卡死，因為我們沒有改變狀態
            }
        }
        else if (currentSubState == PlanningSubState.SelectingTarget)
        {
            var validTargets = battleRules.GetValidTargets(selectedUnitForAction, battleManager.GetOpposingTeam(selectedUnitForAction));
            if (validTargets.Contains(unit)) FinalizeActionPlan(unit);
        }
        else if (currentSubState == PlanningSubState.SelectingExchangeTarget)
        {
            var validTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, battleManager.GetSameTeam(selectedUnitForAction));
            if (validTargets.Contains(unit)) FinalizeExchangePlan(unit);
        }
    }

    public void OnActionSelected(ActionType type)
    {
        if (currentSubState != PlanningSubState.SelectingAction) return;
        selectedActionType = type;
        if (type == ActionType.Attack)
        {
            currentSubState = PlanningSubState.SelectingTarget;
            var validTargets = battleRules.GetValidTargets(selectedUnitForAction, battleManager.GetOpposingTeam(selectedUnitForAction));
            uiManager.ShowTargetSelection(validTargets);
        }
        else if (type == ActionType.Exchange)
        {
            currentSubState = PlanningSubState.SelectingExchangeTarget;
            var validTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, battleManager.GetSameTeam(selectedUnitForAction));
            uiManager.ShowTargetSelection(validTargets);
        }
        else
        {
            FinalizeActionPlan(null);
        }
    }
    
    public void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        switch (command)
        {
            case UICommandType.EndTurn: if (CurrentState == BattleState.PlayerPlanning) SetState(BattleState.EnemyTurn); break;
            case UICommandType.ResetAll:
                if (CurrentState != BattleState.PlayerPlanning) return;
                actionPlanner.ClearPlayerPlans();
                characterStateRule.RestoreAllUnitsFromSnapshot();
                uiManager.EnterPlayerPlanningState(actionPlanner);
                StartCoroutine(StartGuidedPlanning());
                BattleLog.Instance.AddLog("已重置所有規劃。");
                break;
            case UICommandType.CancelSingleAction:
                if (CurrentState != BattleState.PlayerPlanning || planData == null) return;
                actionPlanner.RemovePlan(planData);
                characterStateRule.RefundStaminaForPlan(planData, battleActions.GetAttackStaminaCost());
                uiManager.UpdateActionSlots(actionPlanner);
                BattleLog.Instance.AddLog($"已取消行動: {planData.Source.UnitName} -> {planData.Type}");
                break;
            case UICommandType.Back:
                HandleBackButton();
                break;
        }
    }

    private void HandleBackButton()
    {
        // 只有在玩家規劃階段才能返回
        if (CurrentState != BattleState.PlayerPlanning) return;

        switch (currentSubState)
        {
            // 情況一：正在選擇目標 -> 返回到選擇行動
            case PlanningSubState.SelectingTarget:
            case PlanningSubState.SelectingExchangeTarget:
                currentSubState = PlanningSubState.SelectingAction;
                // selectedUnitForAction 依然是之前選好的那個單位，不需要改變
                // 重新為這個單位顯示行動面板
                ShowActionPanelForUnit(selectedUnitForAction);
                BattleLog.Instance.AddLog("返回到選擇行動。");
                break;
            
            // 情況二：正在為某個單位選擇行動 -> 返回到選擇單位 (僅在遠程規劃時有意義)
            case PlanningSubState.SelectingAction:
                // 檢查 currentEligibleActors 的數量，如果大於1，說明之前是處於「選擇遠程單位」的步驟
                if (currentEligibleActors.Count > 1)
                {
                    currentSubState = PlanningSubState.SelectingRangedUnit;
                    selectedUnitForAction = null; // 清空已選單位
                    // 重新顯示可選的遠程單位
                    uiManager.ShowRangedUnitSelection(currentEligibleActors, currentPlanningStepIndex);
                    BattleLog.Instance.AddLog("返回到選擇遠程單位。");
                }
                else
                {
                    // 如果只有一個合格單位(通常是前衛)，說明沒有「上一步」，返回按鈕不應起作用
                    // (或者在UI層面就應該讓它不可見)
                    Debug.Log("沒有更早的步驟可以返回。");
                }
                break;
        }
    }

    private IEnumerator StartGuidedPlanning()
    {
        currentPlanningStepIndex = 0;
        AdvancePlanningStep();
        yield return null;
    }

    private void AdvancePlanningStep()
    {
        if (currentPlanningStepIndex >= 8)
        {
            currentSubState = PlanningSubState.None;
            BattleLog.Instance.AddLog("所有行動已規劃完畢。請點擊「回合結束」。");
            uiManager.ShowPlanningFinishedState();
            return;
        }
        List<BattleUnit> eligibleActors = battleRules.GetEligibleActorsForStep(currentPlanningStepIndex, battleManager.PlayerUnits, actionPlanner);
        currentEligibleActors = battleRules.GetEligibleActorsForStep(currentPlanningStepIndex, battleManager.PlayerUnits, actionPlanner);
        if (eligibleActors.Count == 0)
        {
            currentPlanningStepIndex++;
            AdvancePlanningStep();
        }
        else if (eligibleActors.Count == 1)
        {
            selectedUnitForAction = eligibleActors[0];
            currentSubState = PlanningSubState.SelectingAction;
            ShowActionPanelForUnit(selectedUnitForAction);
        }
        else
        {
            currentSubState = PlanningSubState.SelectingRangedUnit;
            uiManager.ShowRangedUnitSelection(currentEligibleActors, currentPlanningStepIndex);
        }
    }

    private void ShowActionPanelForUnit(BattleUnit unit)
    {
        var feasibility = battleRules.GetActionFeasibility(unit, battleManager.GetAllUnits(), actionPlanner);
        uiManager.ShowActionSelectionFor(unit, currentPlanningStepIndex, feasibility);
    }
    
    private void FinalizeActionPlan(BattleUnit target)
    {
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        // 判斷當前步驟是前衛還是遠程
        BattleRole stepRole = (currentPlanningStepIndex % 2 == 0) ? BattleRole.Vanguard : BattleRole.Ranged1;

        characterStateRule.ConsumeStaminaForPlan(selectedUnitForAction, selectedActionType, battleActions.GetAttackStaminaCost(), battleActions.GetExchangeStaminaCost());
        // 將 stepRole 傳入構造函數
        ActionPlan newPlan = new ActionPlan(selectedUnitForAction, target, selectedActionType, phaseIndex, stepRole);
        actionPlanner.AddPlan(newPlan);
        GoToNextStep();
    }
    
    private void FinalizeExchangePlan(BattleUnit target)
    {
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = (currentPlanningStepIndex % 2 == 0) ? BattleRole.Vanguard : BattleRole.Ranged1;

        characterStateRule.ConsumeStaminaForPlan(selectedUnitForAction, ActionType.Exchange, battleActions.GetAttackStaminaCost(), battleActions.GetExchangeStaminaCost());
        Guid transactionID = Guid.NewGuid();
        // 將 stepRole 傳入構造函數
        var planA = new ActionPlan(selectedUnitForAction, target, ActionType.Exchange, phaseIndex, stepRole, transactionID);
        actionPlanner.AddPlan(planA);
        GoToNextStep();
    }

    private void GoToNextStep()
    {
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;
        uiManager.UpdateActionSlots(actionPlanner);
        currentPlanningStepIndex++;
        AdvancePlanningStep();
    }

    private IEnumerator ExecuteActions()
    {
        var processedTransactions = new HashSet<Guid>();
        for (int i = 1; i <= 4; i++)
        {
            yield return StartCoroutine(ExecutePhase(i, true, BattleRole.Vanguard, processedTransactions));
            if (CheckBattleEnd()) yield break;
            yield return StartCoroutine(ExecutePhase(i, false, BattleRole.Vanguard, processedTransactions));
            if (CheckBattleEnd()) yield break;
            yield return StartCoroutine(ExecutePhase(i, true, BattleRole.Ranged1, processedTransactions));
            if (CheckBattleEnd()) yield break;
            yield return StartCoroutine(ExecutePhase(i, false, BattleRole.Ranged1, processedTransactions));
            if (CheckBattleEnd()) yield break;
        }
        if (CurrentState == BattleState.ActionExecution)
        {
            SetState(BattleState.PlayerPlanning);
        }
    }
    
    private IEnumerator ExecutePhase(int phase, bool isPlayer, BattleRole role, HashSet<Guid> processedTransactions)
    {
        // 現在我們直接從 planner 獲取對應職責格的計畫
        ActionPlan plan = actionPlanner.GetActionForRole(phase, isPlayer, role);

        if (plan != null && !plan.Source.IsDead)
        {
            battleActions.Execute(plan, actionPlanner, processedTransactions, battleManager);
            yield return new WaitForSeconds(1.0f);
        }
    }

    private bool CheckBattleEnd()
    {
        actionPlanner.RemovePlansFromDeadUnits(battleManager.GetAllUnits());
        battleManager.HandleTeamPromotions();
        uiManager.UpdateActionSlots(actionPlanner);
        if (battleRules.IsVictory(battleManager.EnemyUnits)) { SetState(BattleState.Won); return true; }
        if (battleRules.IsDefeat(battleManager.PlayerUnits)) { SetState(BattleState.Lost); return true; }
        return false;
    }
}
```

#### **BattleManager.cs**
戰鬥場景總控制器。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattleManager : MonoBehaviour
{
    public static BattleManager Instance { get; private set; }
    public BattleEncounterSO EncounterData { get; private set; }
    public List<BattleUnit> PlayerUnits { get; private set; }
    public List<BattleUnit> EnemyUnits { get; private set; }
    
    public Transform[] GridSpawns => gridSpawns;
    [SerializeField] private Transform[] gridSpawns = new Transform[8];

    [Header("系統模組")]
    [SerializeField] private TurnManager turnManager;
    [SerializeField] private BattleUIManager uiManager;
    [SerializeField] private BattleRules battleRules;
    [SerializeField] private BattleActions battleActions;
    [SerializeField] private EnemyBattleAI enemyAI;
    [SerializeField] private CharacterStateRule characterStateRule;
    
    private TurnActionPlanner actionPlanner;

    private void Awake() { Instance = this; }
    void Start()
    {
        EncounterData = GameManager.Instance.CurrentEncounter;
        if (EncounterData == null) { Debug.LogError("沒有傳入戰鬥遭遇數據！"); return; }
        InitializeSystems();
        SpawnUnits();
        turnManager.StartBattle();
    }

    private void InitializeSystems()
    {
        actionPlanner = new TurnActionPlanner();
        PlayerUnits = new List<BattleUnit>();
        EnemyUnits = new List<BattleUnit>();
        turnManager.Initialize(this, uiManager, actionPlanner, battleRules, battleActions, enemyAI, characterStateRule);
        uiManager.Initialize(turnManager);
    }
    
    private void SpawnUnits()
    {
        var battleParty = PartyManager.Instance.BattleParty;
        for (int i = 0; i < battleParty.Count; i++)
        {
            var role = (BattleRole)i;
            var position = GetInitialPositionForRole(role, true);
            var spawnTransform = gridSpawns[(int)position];
            
            GameObject unitGO = Instantiate(battleParty[i].BaseData.unitPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(battleParty[i], role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            PlayerUnits.Add(unit);
        }
        foreach (var enemyPos in EncounterData.enemyTeam)
        {
            var role = enemyPos.role;
            var position = GetInitialPositionForRole(role, false);
            var spawnTransform = gridSpawns[(int)position];
            GameObject unitGO = Instantiate(enemyPos.enemyData.enemyPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(enemyPos.enemyData, role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            EnemyUnits.Add(unit);
        }
    }
    
    private GridPosition GetInitialPositionForRole(BattleRole role, bool isPlayer)
    {
        if (isPlayer)
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.PlayerVanguard;
                case BattleRole.Ranged1:  return GridPosition.PlayerRanged1;
                case BattleRole.Ranged2:  return GridPosition.PlayerRanged2;
                case BattleRole.Support:  return GridPosition.PlayerSupport;
            }
        }
        else
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.EnemyVanguard;
                case BattleRole.Ranged1:  return GridPosition.EnemyRanged1;
                case BattleRole.Ranged2:  return GridPosition.EnemyRanged2;
                case BattleRole.Support:  return GridPosition.EnemySupport;
            }
        }
        throw new System.Exception("無效的角色或隊伍");
    }
    
    public void HandleTeamPromotions()
    {
        CheckAndPromoteForTeam(PlayerUnits);
        CheckAndPromoteForTeam(EnemyUnits);
    }

    private void CheckAndPromoteForTeam(List<BattleUnit> team)
    {
        var promotionOrder = new List<GridPosition> { GridPosition.PlayerVanguard, GridPosition.PlayerRanged1, GridPosition.PlayerRanged2, GridPosition.PlayerSupport };
        if (team.Any() && !team.First().IsPlayerTeam)
        {
            promotionOrder = new List<GridPosition> { GridPosition.EnemyVanguard, GridPosition.EnemyRanged1, GridPosition.EnemyRanged2, GridPosition.EnemySupport };
        }
        
        for (int i = 0; i < promotionOrder.Count - 1; i++)
        {
            GridPosition currentPos = promotionOrder[i];
            BattleUnit unitAtCurrentPos = GetUnitAtPosition(currentPos, team);
            if (unitAtCurrentPos == null || unitAtCurrentPos.IsDead)
            {
                for (int j = i + 1; j < promotionOrder.Count; j++)
                {
                    GridPosition substitutePos = promotionOrder[j];
                    BattleUnit substituteUnit = GetUnitAtPosition(substitutePos, team);
                    if (substituteUnit != null && !substituteUnit.IsDead)
                    {
                        // SetNewPosition
                        BattleLog.Instance.AddLog($"{substituteUnit.UnitName} 自動替補到 {currentPos} 位置！");
                        substituteUnit.SetNewPosition(currentPos);
                        substituteUnit.transform.position = gridSpawns[(int)currentPos].position;
                        break;
                    }
                }
            }
        }
    }

    public BattleUnit GetUnitAtPosition(GridPosition pos, List<BattleUnit> team) => team.FirstOrDefault(u => u.CurrentPosition == pos && !u.IsDead);
    public List<BattleUnit> GetAllUnits() => PlayerUnits.Concat(EnemyUnits).ToList();
    public List<BattleUnit> GetOpposingTeam(BattleUnit unit) => unit.IsPlayerTeam ? EnemyUnits : PlayerUnits;
    public List<BattleUnit> GetSameTeam(BattleUnit unit) => unit.IsPlayerTeam ? PlayerUnits : EnemyUnits;
    public BattleUnit GetUnitAtPosition(GridPosition pos)
    {
        if (pos == GridPosition.None) return null;
        // 在所有存活的單位中尋找佔據該位置的單位
        return GetAllUnits().FirstOrDefault(u => !u.IsDead && u.CurrentPosition == pos);
    }
    public bool IsBattleWon()
    {
        return turnManager != null && turnManager.CurrentState == BattleState.Won;
    }
}
```

#### **BattleUIManager.cs**
UI 系統協調者。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class BattleUIManager : MonoBehaviour
{
    private TurnManager turnManager;

    [Header("UI 面板")]
    [SerializeField] private ActionPanelUI actionPanel;
    [SerializeField] private ActionSlotPanelUI actionSlotPanel;
    [SerializeField] private BattleUI battleUI;
    [SerializeField] private BattleEndUI battleEndUI;
    
    public void Initialize(TurnManager tm)
    {
        turnManager = tm;
        // 使用 Lambda 表達式來匹配 Setup 的參數需求
        battleUI.Setup(cmd => OnUICommand(cmd, null));
        actionSlotPanel.Initialize((cmd, plan) => OnUICommand(cmd, plan));
    }

    // --- 狀態進入時的 UI 設置 ---
    public void EnterPlayerPlanningState(TurnActionPlanner planner)
    {
        HideAllActionPanels();
        actionSlotPanel.UpdatePanel(planner);
        actionSlotPanel.gameObject.SetActive(true);
        battleUI.SetEndTurnButtonInteractable(false); // 規劃完成前不可結束
        battleUI.SetResetButtonVisible(true);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterEnemyTurnState()
    {
        HideAllActionPanels();
        battleUI.SetEndTurnButtonInteractable(false);
        battleUI.SetResetButtonVisible(false);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterActionExecutionState()
    {
        HideAllActionPanels();
    }
    
    // --- 引導式規劃的 UI 顯示 ---
    public void ShowRangedUnitSelection(List<BattleUnit> units, int stepIndex)
    {
        HideAllActionPanels();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        units.ForEach(u => u.SetHighlight(true));
        battleUI.SetBackButtonVisible(false); // 選擇單位是第一步，不能返回
        BattleLog.Instance.AddLog("請選擇一位遠程單位來規劃行動。");
    }

    public void ShowActionSelectionFor(BattleUnit unit, int stepIndex, Dictionary<ActionType, bool> feasibility)
    {
        DeselectAllHighlights();
        unit.SetHighlight(true);
        
        actionPanel.ShowPanel(unit, turnManager.OnActionSelected);
        actionPanel.UpdateButtonStates(feasibility); // 更新按鈕狀態
        
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        battleUI.SetBackButtonVisible(true);
    }
    
    public void ShowTargetSelection(List<BattleUnit> validTargets)
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        validTargets.ForEach(t => t.SetHighlight(true));
        BattleLog.Instance.AddLog("請選擇一個目標。");
    }

    public void ShowPlanningFinishedState()
    {
        HideAllActionPanels();
        actionSlotPanel.SetPlanningHighlight(-1); // 關閉所有高亮
        battleUI.SetEndTurnButtonInteractable(true);
        battleUI.SetBackButtonVisible(false);
    }
    
    public void UpdateActionSlots(TurnActionPlanner planner)
    {
        actionSlotPanel.UpdatePanel(planner);
    }

    // --- 其他 UI 控制 ---
    public void ShowVictoryScreen(int gold) { battleEndUI.ShowVictory(gold); }
    public void ShowDefeatScreen() { battleEndUI.ShowDefeat(); }
    
    private void HideAllActionPanels()
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(-1);
    }

    private void DeselectAllHighlights()
    {
        if (BattleManager.Instance == null) return;
        foreach(var unit in BattleManager.Instance.PlayerUnits) unit.SetHighlight(false);
        foreach(var unit in BattleManager.Instance.EnemyUnits) unit.SetHighlight(false);
    }

    // --- 輸入中繼 ---
    private void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        turnManager.OnUICommand(command, planData);
    }
}
```

#### **GameManager.cs**
遊戲狀態管理器。

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Linq;
using System.Collections.Generic;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    
    public BattleEncounterSO CurrentEncounter { get; private set; }
    
    private string mainSceneName = "Title"; // 假設您的非戰鬥場景名
    private string battleSceneName = "BattleScene"; // 假設您的戰鬥場景名

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    public void StartBattle(BattleEncounterSO encounter)
    {
        CurrentEncounter = encounter;
        SceneManager.LoadScene(battleSceneName);
    }

    public void EndBattle()
    {
        ProcessBattleResults();
        UpdatePartyStatusAfterBattle();
        // 可以在這裡處理獎勵發放等邏輯
        CurrentEncounter = null;
        SceneManager.LoadScene(mainSceneName);
    }

    private void UpdatePartyStatusAfterBattle()
    {
        // 檢查 BattleManager 和 PartyManager 是否存在，避免在編輯器中單獨運行場景時出錯
        if (BattleManager.Instance == null || PartyManager.Instance == null)
        {
            Debug.LogWarning("無法更新隊伍狀態，因為 BattleManager 或 PartyManager 不存在。");
            return;
        }

        // 遍歷所有參與戰鬥的玩家單位
        foreach (var unit in BattleManager.Instance.PlayerUnits)
        {
            // 在 PartyManager 的總成員列表中，找到與之對應的那個實例
            // 我們使用獨一無二的 instanceID 來進行匹配
            MemberInstance instanceToUpdate = PartyManager.Instance.AllMembers.FirstOrDefault(
                m => m.instanceID == unit.MemberInstance.instanceID
            );

            if (instanceToUpdate != null)
            {
                // 將戰鬥結束時的血量寫回實例
                instanceToUpdate.currentHP = unit.CurrentHP;
                Debug.Log($"已更新成員 [{instanceToUpdate.BaseData.memberName}] 的血量為: {instanceToUpdate.currentHP}");
            }
        }
        // (可選) 在這裡也可以觸發一次存檔
        // PartyManager.Instance.SaveParty();
    }

    private void ProcessBattleResults()
    {
        if (BattleManager.Instance == null) return;
        
        // 檢查戰鬥是否勝利 (失敗則不處理獎勵和進度)
        if (BattleManager.Instance.IsBattleWon())
        {
            // 處理金錢和經驗值獎勵
            var encounterData = BattleManager.Instance.EncounterData;
            int totalGold = 0;
            // int totalExp = 0; // 暫時註解掉未使用的變數

            foreach(var enemyUnit in BattleManager.Instance.EnemyUnits)
            {
                if(enemyUnit.EnemyData != null)
                {
                    totalGold += enemyUnit.EnemyData.goldDrop;
                    // totalExp += enemyUnit.EnemyData.expDrop; // 這行也保持註解
                }
            }

            if(PlayerState.Instance != null)
            {
                PlayerState.Instance.AddMoney(totalGold);
                // PlayerState.Instance.GainExperience(totalExp); // 這行也保持註解
                Debug.Log($"戰鬥勝利！獲得金幣: {totalGold}");
            }

            // 處理擊殺任務進度
            if (QuestManager.Instance != null)
            {
                foreach (var enemyUnit in BattleManager.Instance.EnemyUnits)
                {
                    // 確保只計算被擊殺的敵人
                    if (enemyUnit.IsDead && enemyUnit.EnemyData != null)
                    {
                        string enemyID = enemyUnit.EnemyData.enemyID;
                        QuestManager.Instance.AdvanceObjective(enemyID, QuestObjectiveType.Kill, 1);
                        Debug.Log($"向任務系統報告擊殺: {enemyID}");
                    }
                }
            }
        }
    }
}
```

---

### **5. 戰鬥邏輯**

#### **BattleRules.cs**
戰鬥法典。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "BattleRules", menuName = "Battle System/Battle Rules")]
public class BattleRules : ScriptableObject
{
    // -- 查詢行動資格 --
    public List<BattleUnit> GetEligibleActorsForStep(int stepIndex, List<BattleUnit> playerUnits, TurnActionPlanner planner)
    {
        var eligibleActors = new List<BattleUnit>();
        bool isVanguardStep = stepIndex % 2 == 0;

        if (isVanguardStep)
        {
            // 尋找當前正站在「前衛位置」上的單位
            BattleUnit unitInVanguardPos = playerUnits.FirstOrDefault(u => !u.IsDead && u.CurrentPosition == GridPosition.PlayerVanguard);
            if (CanUnitAct(unitInVanguardPos, planner, 4))
            {
                if (unitInVanguardPos != null) eligibleActors.Add(unitInVanguardPos);
            }
        }
        else // Ranged step
        {
            // 尋找當前正站在「遠程位置」上的單位
            BattleUnit unitInRanged1Pos = playerUnits.FirstOrDefault(u => !u.IsDead && u.CurrentPosition == GridPosition.PlayerRanged1);
            BattleUnit unitInRanged2Pos = playerUnits.FirstOrDefault(u => !u.IsDead && u.CurrentPosition == GridPosition.PlayerRanged2);

            if (CanUnitAct(unitInRanged1Pos, planner, 2))
            {
                if (unitInRanged1Pos != null) eligibleActors.Add(unitInRanged1Pos);
            }
            if (CanUnitAct(unitInRanged2Pos, planner, 2))
            {
                if (unitInRanged2Pos != null) eligibleActors.Add(unitInRanged2Pos);
            }
        }
        return eligibleActors;
    }

    private bool CanUnitAct(BattleUnit unit, TurnActionPlanner planner, int maxActions)
    {
        if (unit == null || unit.IsDead) return false;
        return planner.GetActionCountForUnit(unit) < maxActions;
    }
    
    // -- 查詢行動可行性 (給UI按鈕用) --
    public Dictionary<ActionType, bool> GetActionFeasibility(BattleUnit actor, List<BattleUnit> allUnits, TurnActionPlanner planner)
    {
        var feasibility = new Dictionary<ActionType, bool>();
        var sameTeam = allUnits.Where(u => u.IsPlayerTeam == actor.IsPlayerTeam).ToList();
        var opposingTeam = allUnits.Where(u => u.IsPlayerTeam != actor.IsPlayerTeam).ToList();

        // 攻擊
        feasibility[ActionType.Attack] = GetValidTargets(actor, opposingTeam).Any();
        // 交換
        feasibility[ActionType.Exchange] = GetValidExchangeTargets(actor, sameTeam).Any();
        // 其他行動總是可行 (體力由 TurnManager 判斷)
        feasibility[ActionType.Defend] = true;
        feasibility[ActionType.Rest] = true;
        feasibility[ActionType.Skip] = true;
        
        return feasibility;
    }

    // -- 查詢合法目標 --
    public List<BattleUnit> GetValidTargets(BattleUnit attacker, List<BattleUnit> allEnemies)
    {
        var validTargets = new List<BattleUnit>();
        if (attacker == null || attacker.IsDead) return validTargets;

        // 1. 找出敵方隊伍中存活的前衛單位
        BattleUnit enemyVanguard = allEnemies.FirstOrDefault(u => u.Role == BattleRole.Vanguard && !u.IsDead);

        // 2. 決定潛在的目標列表
        List<BattleUnit> potentialTargets = new List<BattleUnit>();
        if (enemyVanguard != null)
        {
            // 如果有存活的前衛，那麼它就是唯一的潛在目標
            potentialTargets.Add(enemyVanguard);
        }
        else
        {
            // 如果沒有存活的前衛，則所有存活的敵人都成為潛在目標
            // (這個邏輯可以讓遊戲在敵方前衛陣亡後繼續進行)
            potentialTargets = allEnemies.Where(u => !u.IsDead).ToList();
        }

        // 3. 根據攻擊距離，從潛在目標中篩選出最終的合法目標
        foreach (var target in potentialTargets)
        {
            if (target == null) continue;
            
            // 計算距離的邏輯保持不變
            int distance = Mathf.Abs((int)attacker.CurrentPosition - (int)target.CurrentPosition);
            if (distance <= attacker.AttackRange)
            {
                validTargets.Add(target);
            }
        }

        return validTargets;
    }
    
    public List<BattleUnit> GetValidExchangeTargets(BattleUnit actor, List<BattleUnit> teammates)
    {
        var validTargets = new List<BattleUnit>();
        if (actor == null || actor.IsDead || actor.Role == BattleRole.Support) return validTargets;

        foreach (var mate in teammates)
        {
            if (mate == null || mate.IsDead || mate == actor) continue;

            bool canSwap = false;
            switch (actor.Role)
            {
                case BattleRole.Vanguard:
                    canSwap = (mate.Role == BattleRole.Ranged1);
                    break;
                case BattleRole.Ranged1:
                    canSwap = (mate.Role == BattleRole.Vanguard || mate.Role == BattleRole.Ranged2);
                    break;
                case BattleRole.Ranged2:
                    canSwap = (mate.Role == BattleRole.Ranged1);
                    break;
            }
            if(canSwap) validTargets.Add(mate);
        }
        return validTargets;
    }

    // -- 查詢勝負 --
    public bool IsVictory(List<BattleUnit> enemyUnits) => enemyUnits.All(u => u.IsDead);
    public bool IsDefeat(List<BattleUnit> playerUnits) => playerUnits.All(u => u.IsDead);
}
```

#### **BattleActions.cs**
行動邏輯的執行者。

```csharp
using UnityEngine;
using System;
using System.Linq;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "BattleActions", menuName = "Battle System/Battle Actions")]
public class BattleActions : ScriptableObject
{
    [Header("行動數值")]
    [SerializeField] private int attackStaminaCost = 3;
    [SerializeField] private int exchangeStaminaCost = 2;
    [SerializeField] private int restStaminaRecovery = 5;

    public int GetAttackStaminaCost() => attackStaminaCost;
    public int GetExchangeStaminaCost() => exchangeStaminaCost;

    public void Execute(ActionPlan plan, TurnActionPlanner planner, HashSet<Guid> processedTransactions, BattleManager battleManager)
    {   // 1. 檢查發起者是否存在
        if (plan.Source.IsDead) return;
        // 2. 處理關聯行動的唯一性 (例如交換位置)，確保只執行一次
        if (plan.Type == ActionType.Exchange && plan.TransactionID != Guid.Empty)
        {
            if (processedTransactions.Contains(plan.TransactionID)) return;
            processedTransactions.Add(plan.TransactionID);
        }
        // 在執行前一刻，才去查詢目標位置上的單位是誰
        BattleUnit currentTarget = battleManager.GetUnitAtPosition(plan.TargetPosition); 
        // 3. 檢查指令是否失效 (例如目標已消失)，並決定最終執行的行動
        ActionType finalActionType = plan.Type;
        // 攻擊指令失效規則
        if (plan.Type == ActionType.Attack && currentTarget == null)
        {
            finalActionType = (plan.Source.Role == BattleRole.Vanguard) ? ActionType.Defend : ActionType.Rest;
            BattleLog.Instance.AddLog($"{plan.Source.UnitName} 的攻擊目標已消失，行動變更為 [{finalActionType.ToActionName()}]！");
        }
        // 交換指令失效規則
        if (plan.Type == ActionType.Exchange && currentTarget == null)
        {
            finalActionType = ActionType.Rest;
            BattleLog.Instance.AddLog($"{plan.Source.UnitName} 的交換目標已消失，行動變更為 [{finalActionType.ToActionName()}]！");
        }
        // 4. 根據最終決定的行動類型，執行對應的邏輯
        switch (finalActionType)
        {
            case ActionType.Attack: ExecuteAttack(plan.Source, currentTarget); break;
            case ActionType.Defend: ExecuteDefend(plan.Source); break;
            case ActionType.Rest: ExecuteRest(plan.Source); break;
            case ActionType.Exchange: ExecuteExchange(plan.Source, currentTarget, battleManager); break;
            case ActionType.Skip: BattleLog.Instance.AddLog($"{plan.Source.UnitName} 選擇跳過行動。"); break;
        }
    }
    
    private void ExecuteAttack(BattleUnit source, BattleUnit target)
    {
        BattleLog.Instance.AddLog($"{source.UnitName} 對位於 [{target.CurrentPosition}] 的 {target.UnitName} 發動攻擊！");
        target.TakeDamage(source.CurrentAttack);
    }
    
    private void ExecuteDefend(BattleUnit source)
    {
        source.SetDefenseState(true);
        BattleLog.Instance.AddLog($"{source.UnitName} 進入防禦姿態。");
    }

    private void ExecuteRest(BattleUnit source)
    {
        source.RestoreStamina(restStaminaRecovery);
        BattleLog.Instance.AddLog($"{source.UnitName} 休息，恢復 {restStaminaRecovery} 體力。");
    }

    private void ExecuteExchange(BattleUnit source, BattleUnit target, BattleManager battleManager)
    {
        BattleLog.Instance.AddLog($"{source.UnitName} 與 {target.UnitName} 進行位置交換！");

        GridPosition posA = source.CurrentPosition;
        GridPosition posB = target.CurrentPosition;

        // 同時獲取並交換 Role 屬性
        BattleRole roleA = source.Role;
        BattleRole roleB = target.Role;

        // 執行邏輯交換
        source.SetNewPosition(posB);
        target.SetNewPosition(posA);
        source.SetRole(roleB); // 更新 A 的角色為 B 原本的角色
        target.SetRole(roleA); // 更新 B 的角色為 A 原本的角色

        // 執行視覺交換
        source.transform.position = battleManager.GridSpawns[(int)posB].position;
        target.transform.position = battleManager.GridSpawns[(int)posA].position;
    }
}
```

#### **TurnActionPlanner.cs**
回合行動規劃器。

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class TurnActionPlanner
{
    private List<ActionPlan> plannedActions = new List<ActionPlan>();

    public void AddPlan(ActionPlan plan) { plannedActions.Add(plan); }
    public void RemovePlan(ActionPlan plan) { if (plan != null) plannedActions.Remove(plan); }
    public void ClearPlayerPlans() { plannedActions.RemoveAll(p => p.Source != null && p.Source.IsPlayerTeam); }
    
    public void PrepareForNewTurn()
    {
        foreach (var plan in plannedActions)
        {
            if (plan.Source != null && plan.Type == ActionType.Defend)
            {
                plan.Source.SetDefenseState(false);
            }
        }
        plannedActions.Clear();
    }

    public ActionPlan GetAction(int phase, bool isPlayer, BattleRole role) => plannedActions.FirstOrDefault(p => p.PhaseIndex == phase && p.Source != null && p.Source.IsPlayerTeam == isPlayer && p.Source.Role == role);
    public ActionPlan GetRangedAction(int phase, bool isPlayer) => plannedActions.FirstOrDefault(p => p.PhaseIndex == phase && p.Source != null && p.Source.IsPlayerTeam == isPlayer && (p.Source.Role == BattleRole.Ranged1 || p.Source.Role == BattleRole.Ranged2));
    public ActionPlan GetActionForRole(int phase, bool isPlayer, BattleRole role)
    {
        if (role == BattleRole.Vanguard)
        {
            return plannedActions.FirstOrDefault(p =>
                p.PhaseIndex == phase &&
                p.Source.IsPlayerTeam == isPlayer &&
                p.PlannedForRole == BattleRole.Vanguard);
        }
        else // 查找遠程格的計畫 (Ranged1 或 Ranged2)
        {
            return plannedActions.FirstOrDefault(p =>
                p.PhaseIndex == phase &&
                p.Source.IsPlayerTeam == isPlayer &&
                (p.PlannedForRole == BattleRole.Ranged1 || p.PlannedForRole == BattleRole.Ranged2));
        }
    }
    public List<ActionPlan> GetPlansByTransactionID(Guid id) => (id == Guid.Empty) ? new List<ActionPlan>() : plannedActions.Where(p => p.TransactionID == id).ToList();
    public int GetActionCountForUnit(BattleUnit unit) => plannedActions.Count(p => p.Source == unit);
    public void RemovePlansFromDeadUnits(List<BattleUnit> allUnits)
    {
        var deadUnits = allUnits.Where(u => u.IsDead).ToList();
        if (deadUnits.Any())
        {   
            int removedCount = plannedActions.RemoveAll(p => deadUnits.Contains(p.Source));
            if (removedCount > 0)
            {
                BattleLog.Instance.AddLog($"因單位陣亡，移除了 {removedCount} 個無效的行動計畫。");
            }
        }
    }

    public List<int> GetPlannedPhaseIndicesForUnit(BattleUnit unit)
    {
        return plannedActions.Where(p => p.Source == unit).Select(p => p.PhaseIndex).ToList();
    }
}
```
**注意**: `TurnActionPlanner` 不適合做成 ScriptableObject，因為它需要儲存每一場戰鬥的即時數據。這裡我已將其改為一個普通的類，您需要在 `BattleManager` 中 `new TurnActionPlanner()` 來創建實例。

#### **CharacterStateRule.cs**
管理戰鬥中角色在特定時間點的狀態變化規則。

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "CharacterStateRule", menuName = "Battle System/Character State Rule")]
public class CharacterStateRule : ScriptableObject
{
    public class UnitStateSnapshot
    {
        public BattleUnit Unit { get; }
        public int Stamina { get; }
        // 未來可以擴展，例如記錄當時的 Buff/Debuff
        // public List<StatusEffect> StatusEffects { get; } 

        public UnitStateSnapshot(BattleUnit unit)
        {
            Unit = unit;
            Stamina = unit.CurrentStamina;
            // StatusEffects = new List<StatusEffect>(unit.ActiveStatusEffects);
        }
    }

    // 這個列表現在儲存的是我們剛剛定義的 UnitStateSnapshot 物件
    private List<UnitStateSnapshot> turnStartSnapshots = new List<UnitStateSnapshot>();

    // 在回合開始時記錄所有單位的狀態
    public void RecordTurnStartStates(List<BattleUnit> allUnits)
    {
        turnStartSnapshots.Clear();
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                // 創建一個新的快照並加入列表
                turnStartSnapshots.Add(new UnitStateSnapshot(unit));
            }
        }
    }

    // 當玩家點擊「清空規劃」時，從快照恢復所有單位狀態
    public void RestoreAllUnitsFromSnapshot()
    {
        foreach (var snapshot in turnStartSnapshots)
        {
            if (snapshot.Unit != null && !snapshot.Unit.IsDead)
            {
                // 根據快照中的數據恢復單位狀態
                snapshot.Unit.SetStamina(snapshot.Stamina);
            }
        }
    }
    
    // 根據行動類型消耗體力
    public void ConsumeStaminaForPlan(BattleUnit actor, ActionType action, int attackCost, int exchangeCost)
    {
        switch (action)
        {
            case ActionType.Attack:
                actor.ConsumeStamina(attackCost);
                break;
            case ActionType.Exchange:
                actor.ConsumeStamina(exchangeCost);
                break;
        }
    }
    
    // 為被取消的攻擊行動返還體力
    public void RefundStaminaForPlan(ActionPlan plan, int attackCost)
    {
        if (plan == null || plan.Source == null) return;
        if (plan.Type == ActionType.Attack)
        {
            plan.Source.RestoreStamina(attackCost);
        }
    }
    
    // 在回合開始時回滿體力
    public void RestoreAllUnitStamina(List<BattleUnit> allUnits)
    {
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                unit.SetStamina(unit.MaxStamina);
            }
        }
    }
}
```

#### **EnemyBattleAI.cs**
敵人進攻邏輯。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "EnemyBattleAI", menuName = "Battle System/Enemy AI")]
public class EnemyBattleAI : ScriptableObject
{
    public void PlanActions(List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules, int attackCost)
    {
        // 為「前衛職責格」規劃行動
        PlanForRole(BattleRole.Vanguard, 4, selfUnits, opponentUnits, planner, rules, attackCost);
        // 為「遠程1職責格」規劃行動
        PlanForRole(BattleRole.Ranged1, 2, selfUnits, opponentUnits, planner, rules, attackCost);
        // 為「遠程2職責格」規劃行動
        PlanForRole(BattleRole.Ranged2, 2, selfUnits, opponentUnits, planner, rules, attackCost);
        
        BattleLog.Instance.AddLog("敵人已完成行動規劃。");
    }

    private void PlanForRole(BattleRole planningForRole, int maxActions, List<BattleUnit> self, List<BattleUnit> opponents, TurnActionPlanner planner, BattleRules rules, int attackCost)
    {
        // 1. 根據「戰術職責格位」找到當前佔據該位置的單位
        GridPosition targetPosition = GetGridPositionForRole(planningForRole, false);
        BattleUnit unit = self.FirstOrDefault(u => u.CurrentPosition == targetPosition && !u.IsDead);
        
        // 如果這個位置上沒有單位，就直接返回
        if (unit == null) return;

        // 2. 計算還需要規劃多少個行動
        int actionsToPlan = maxActions - planner.GetActionCountForUnit(unit);

        for (int i = 0; i < actionsToPlan; i++)
        {
            // 3. 尋找一個可用的行動階段 (Phase 1-4)
            int? availablePhase = FindAvailablePhaseForUnit(unit, planner);
            if (availablePhase == null) break; // 如果沒有可用的階段，就停止規劃

            // 4. 決定行動類型 (優先攻擊，體力不夠則防禦)
            ActionType action = ActionType.Attack;
            if (unit.CurrentStamina < attackCost)
            {
                action = ActionType.Defend;
            }

            // 5. 尋找攻擊目標
            var targets = rules.GetValidTargets(unit, opponents);
            BattleUnit target = (targets.Count > 0) ? targets.First() : null;

            // 6. 創建 ActionPlan，並傳入 `planningForRole`
            if (target != null && action == ActionType.Attack)
            {
                planner.AddPlan(new ActionPlan(unit, target, action, availablePhase.Value, planningForRole));
                unit.ConsumeStamina(attackCost); // 預扣體力
            }
            else
            {
                planner.AddPlan(new ActionPlan(unit, null, ActionType.Defend, availablePhase.Value, planningForRole));
            }
        }
    }
    
    // 輔助方法：根據單位尋找可用的行動階段
    private int? FindAvailablePhaseForUnit(BattleUnit unit, TurnActionPlanner planner)
    {
        var plannedPhases = planner.GetPlannedPhaseIndicesForUnit(unit);
        for (int phase = 1; phase <= 4; phase++)
        {
            if (!plannedPhases.Contains(phase))
            {
                return phase;
            }
        }
        return null;
    }

    // 輔助方法：根據職責獲取對應的格子位置
    private GridPosition GetGridPositionForRole(BattleRole role, bool isPlayer)
    {
        if (isPlayer)
        {
            switch(role)
            {
                case BattleRole.Vanguard: return GridPosition.PlayerVanguard;
                case BattleRole.Ranged1: return GridPosition.PlayerRanged1;
                case BattleRole.Ranged2: return GridPosition.PlayerRanged2;
                case BattleRole.Support: return GridPosition.PlayerSupport;
            }
        }
        else
        {
            switch(role)
            {
                case BattleRole.Vanguard: return GridPosition.EnemyVanguard;
                case BattleRole.Ranged1: return GridPosition.EnemyRanged1;
                case BattleRole.Ranged2: return GridPosition.EnemyRanged2;
                case BattleRole.Support: return GridPosition.EnemySupport;
            }
        }
        // 理論上不應該執行到這裡
        return GridPosition.None;
    }
}
```