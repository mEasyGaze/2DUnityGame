## 存檔系統增強計畫

這份統整方案將分為三大塊：**用戶體驗**、**系統穩健性** 和 **性能優化**，涵蓋了所有被提出的優秀建議。

---

### **存檔系統增強計畫：統整方案**

#### **第一部分：用戶體驗與交互增強 (UX & Interaction)**

這些功能直接影響玩家的操作感受和便利性。

##### **1. 詳細的加載進度條 (Detailed Loading Progress Bar)**

*   **目標**：在加載遊戲時提供明確的視覺反饋，取代靜態的讀取畫面，提升專業感和玩家耐心。
*   **實現方案**：
    1.  **增強 `LoadingScreen` UI**：在現有的讀取畫面上，增加一個 `Slider` (進度條) 和一個 `TextMeshProUGUI` (狀態提示文本)。
    2.  **創建 `LoadingScreen.cs`** 腳本來統一管理這些UI元素的更新。
    3.  **重構 `SaveManager` 的 `LoadSceneAndApplyData` 協程**，將其分解為多個階段，並在每個階段更新進度條和提示文本：
        *   **階段一：載入場景 (0% → 50%)**: 使用 `asyncLoad.progress` 平滑更新進度條，提示「正在載入場景...」。
        *   **階段二：還原數據 (50% → 90%)**: 依次調用各個 `IGameSaveable` 對象的 `LoadFromSaveData` 方法。每還原一個主要系統（如玩家數據、背包、任務），就推進一小段進度條，並更新提示文本（如「正在整理背包...」、「正在檢查任務進度...」）。
        *   **階段三：最終同步 (90% → 100%)**: 調用 `OnGameLoadComplete` 事件，恢復玩家位置，並提示「載入完成！」。
        *   **階段四：淡出畫面**: 讓進度條在100%停留片刻，然後平滑地淡出讀取畫面。

##### **2. 自動儲存 (Autosave)**

*   **目標**：降低玩家因忘記手動存檔而丟失進度的風險，是現代遊戲的標配功能。
*   **實現方案**：
    1.  **指定專用槽位**：例如，將槽位 0 固定為「自動存檔」槽。
    2.  **在 `SaveManager.cs` 中新增 `TriggerAutosave()` 方法**。
    3.  在遊戲的**關鍵節點**（如完成主線任務、進入新地圖、重要戰鬥前）自動調用 `TriggerAutosave()`。
    4.  `SaveSlotUI` 可以根據槽位索引，為自動存檔槽顯示一個特殊的標籤或圖標。

---

#### **第二部分：系統穩健性與數據安全 (Robustness & Data Safety)**

這些功能確保存檔系統在意外情況下依然可靠，保護玩家的數據。

##### **1. 存檔損壞處理 (Corruption Handling)**

*   **目標**：防止因存檔文件損壞（如JSON格式錯誤）導致整個遊戲崩潰。
*   **實現方案**：
    1.  在 `SaveManager.cs` 中，將所有 `JsonUtility.FromJson()` 的調用都包裹在 `try-catch` 塊中。
    2.  如果在 `catch` 塊中捕獲到異常，意味著文件已損壞。
    3.  此時，**不要讓遊戲崩潰**，而是返回 `null` 或一個標記為損壞的對象。
    4.  `SaveSlotUI` 在接收到這個信號後，應顯示為「存檔已損壞」，並只允許玩家對其執行「刪除」操作。

##### **2. 存檔版本管理 (Save Versioning)**

*   **目標**：在遊戲更新（特別是存檔結構變更）後，能優雅地處理來自舊版本的存檔，避免因數據不匹配導致的錯誤。
*   **實現方案**：
    1.  在 `GameSaveData.cs` 中添加一個 `public string gameVersion;` 字段。
    2.  每次保存時，將當前的遊戲版本 (`Application.version`) 寫入該字段。
    3.  讀取時，比較存檔中的版本號與當前遊戲的版本號。
    4.  如果不一致，使用**通用確認面板**提示玩家：「此存檔來自舊版本，繼續載入可能會有未知問題」，讓玩家選擇是否繼續。

##### **3. 更安全的存檔寫入 (Safe Write / Backup Mechanism)**

*   **目標**：防止在保存過程中（如電腦突然斷電）導致原存檔和新存檔都損壞，造成數據永久丟失。
*   **實現方案**：
    1.  在執行保存操作時，**不要直接覆蓋**舊文件。
    2.  **步驟一**: 將已存在的 `SaveSlot_1.json` 重命名為 `SaveSlot_1.json.bak` (創建備份)。
    3.  **步驟二**: 寫入全新的 `SaveSlot_1.json` 文件。
    4.  **步驟三**: 寫入成功後，再安全地刪除 `.bak` 備份文件。
    *   這樣即使在步驟二中發生意外，玩家至少還能恢復到上一次的存檔。

---

#### **第三部分：性能與進階優化 (Performance & Advanced Optimization)**

這些功能專注於提升系統在處理大數據時的性能和響應速度。

##### **1. 存檔元數據優化 (Metadata Optimization)**

*   **目標**：解決當存檔文件變得很大時，僅僅是打開存檔列表就可能導致卡頓的問題。
*   **實現方案**：
    1.  **創建伴生文件**：每次保存 `SaveSlot_1.json` 時，額外創建一個極小的 `SaveSlot_1_meta.json` 文件。
    2.  **精簡內容**：這個 `_meta` 文件只包含UI列表需要顯示的摘要信息（時間戳、場景名、玩家等級等）。
    3.  **修改 `SaveManager.GetSaveFileSummary()`**: 讓它只讀取這個小巧的 `_meta` 文件，而不是解析整個龐大的主存檔。
    *   結果是存檔/讀取界面的加載速度會變得飛快。

##### **2. 異步保存 (Asynchronous Saving)**

*   **目標**：防止在保存大文件時，因文件寫入操作阻塞主線程而導致的遊戲畫面瞬間卡頓或掉幀。
*   **實現方案**：
    1.  將 `SaveManager.SaveGame()` 方法改為一個協程 `SaveGameCoroutine()`。
    2.  使用 `System.IO.File.WriteAllTextAsync()` 在後台線程執行文件寫入操作。
    3.  在異步寫入期間，可以在UI上顯示一個小的「正在保存...」圖標，並在操作完成後隱藏它，提供即時反饋。