#### **遊戲世界模組 (Game World Module)**

1. `GameEventManager.cs`:
    (1) 遊戲事件管理器。

2. `WorldTimeSystem.cs`:
    (1) 世界時間系統。

3. `GameManager.cs`:
    (1) 場景管理。
    
4. `TitleManager.cs`：
    (1) 標題管理。

5. `CameraController.cs`：
    (1) 畫面跟隨控制器，跟隨目標、控制移動、限制地圖邊界。

6. `CursorManager.cs`(游標管理器)：
    (1) 管理跟隨滑鼠的自定義圖標。

---

#### 事件系統

1. GameEventListener.cs：
(1) 監聽事件ID，響應事件動作。

2. QuestStateListener.cs：
(1) 監聽任務ID，響應事件動作。

---

### 總腳本

#### 1. `GameEventManager.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System;

public class GameEventManager : MonoBehaviour, IGameSaveable
{
    public static GameEventManager Instance { get; private set; }
    private HashSet<string> triggeredEvents = new HashSet<string>();
    public static event Action<string> OnEventTriggered;

    private bool isLoading = false;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        SaveManager.Instance.Register(this);
    }

    void OnDestroy()
    {
        if (SaveManager.Instance != null)
        {
            SaveManager.Instance.Unregister(this);
        }
    }

    public void TriggerEvent(string eventID)
    {
        if (string.IsNullOrEmpty(eventID)) return;

        if (triggeredEvents.Add(eventID))
        {
            Debug.Log($"[GameEventManager] 遊戲事件觸發: {eventID}");
            if (!isLoading)
            {
                OnEventTriggered?.Invoke(eventID);
            }
        }
    }

    public bool HasEventBeenTriggered(string eventID)
    {
        if (string.IsNullOrEmpty(eventID)) return false;
        return triggeredEvents.Contains(eventID);
    }

    public HashSet<string> GetTriggeredEvents() => triggeredEvents;

    #region 存檔資料
    public void PopulateSaveData(GameSaveData data)
    {
        data.worldData.triggeredEvents = new List<string>(this.triggeredEvents);
    }

    public void LoadFromSaveData(GameSaveData data)
    {
        isLoading = true;
        
        if (data.worldData != null && data.worldData.triggeredEvents != null)
        {
            this.triggeredEvents = new HashSet<string>(data.worldData.triggeredEvents);
        }
        else
        {
            this.triggeredEvents = new HashSet<string>();
        }
        isLoading = false;
    }
    #endregion
}
```

#### 2. `WorldTimeSystem.cs`
```csharp
using UnityEngine;
using System;
using UnityEngine.SceneManagement;

public class WorldTimeSystem : MonoBehaviour, IGameSaveable
{
    public static WorldTimeSystem Instance { get; private set; }
    public int CurrentDay { get; private set; } = 1;
    public static event Action<int> OnDayChanged;

    [SerializeField] private float secondsPerDay = 60f;
    private float dayTimer = 0f;
    
    private bool isLoading = false;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        SaveManager.Instance.Register(this);
    }

    void OnDestroy()
    {
        if (SaveManager.Instance != null)
        {
            SaveManager.Instance.Unregister(this);
        }
    }
    
    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        if (GameManager.Instance != null && scene.name == "BattleScene")
        {
            this.enabled = false;
            Debug.Log("[WorldTimeSystem] 進入戰鬥場景，時間系統已暫停。");
        }
        else
        {
            this.enabled = true;
        }
    }

    void Update()
    {
        dayTimer += Time.deltaTime;
        if (dayTimer >= secondsPerDay)
        {
            dayTimer -= secondsPerDay;
            AdvanceDay();
        }
    }

    private void AdvanceDay()
    {
        CurrentDay++;
        Debug.Log($"[WorldTimeSystem] 新的一天開始了！今天是第 {CurrentDay} 天。");
        if (!isLoading) OnDayChanged?.Invoke(CurrentDay);
    }

    public void PassDays(int days)
    {
        for (int i = 0; i < days; i++)
        {
            AdvanceDay();
        }
    }

    #region 存檔資料
    public void PopulateSaveData(GameSaveData data)
    {
        data.worldTimeData.currentDay = this.CurrentDay;
        data.worldTimeData.dayTimer = this.dayTimer;
    }

    public void LoadFromSaveData(GameSaveData data)
    {
        isLoading = true; 
        
        if (data.worldTimeData != null)
        {
            this.CurrentDay = data.worldTimeData.currentDay;
            this.dayTimer = data.worldTimeData.dayTimer;
        }
        isLoading = false;
    }
    #endregion
}
```

#### 3. `GameManager.cs`
```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Linq;
using System.Collections.Generic;

public enum GameState
{
    Exploration,  // 探索模式
    InDialogue,   // 對話中
    InShop,       // 商店中
    InTutorial,   // 教學中
    InStoryScene, // 劇情演出中
    InBattle,     // 戰鬥中
    Paused        // 遊戲暫停 (打開系統選單)
}

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    public GameState CurrentGameState { get; private set; }
    public BattleEncounterSO CurrentEncounter { get; private set; }
    
    [Header("場景名稱設定")]
    [SerializeField] private string mainSceneName = "Title";
    [SerializeField] private string battleSceneName = "BattleScene";

    [Header("場景管理UI")]
    [Tooltip("請將您場景中的讀取畫面 UI 物件拖曳至此")]
    public GameObject loadingScreen;

    private string currentBattleTriggerID;
    private bool lastBattleWon = false;
    
    private string sceneBeforeBattle;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
        else
        {
            Debug.LogError("[GameManager] 未在 Inspector 中指定 LoadingScreen 物件！非同步載入功能可能無法正確顯示讀取畫面。");
        }
        CurrentGameState = GameState.Exploration;
    }

    public void SetGameState(GameState newState)
    {
        if (CurrentGameState == newState) return;
        CurrentGameState = newState;
        Debug.Log($"[GameManager] 遊戲狀態已切換至: {newState}");
        switch (newState)
        {
            case GameState.Exploration:
                InputManager.Instance?.EnableGameplayInput(true);
                Time.timeScale = 1f;
                break;

            case GameState.InDialogue:
            case GameState.InShop:
            case GameState.InTutorial:
            case GameState.InStoryScene:
            case GameState.Paused:
                InputManager.Instance?.EnableGameplayInput(false);
                Time.timeScale = 0f;
                break;
                
            case GameState.InBattle:
                InputManager.Instance?.EnableGameplayInput(false);
                Time.timeScale = 1f;
                break;
        }
    }

    public void StartBattle(BattleEncounterSO encounter, string enemyID = null)
    {
        if (encounter == null)
        {
            Debug.LogError("嘗試開始戰鬥，但傳入的 BattleEncounterSO 為空！");
            return;
        }
        currentBattleTriggerID = enemyID;
        lastBattleWon = false;
        sceneBeforeBattle = SceneManager.GetActiveScene().name;
        SetGameState(GameState.InBattle);
        StartCoroutine(LoadBattleSceneCoroutine(encounter));
    }

    public void EndBattle()
    {
        StartCoroutine(LoadAfterBattleCoroutine());
    }

    private IEnumerator LoadBattleSceneCoroutine(BattleEncounterSO encounter)
    {
        CurrentEncounter = encounter;
        InputManager.Instance?.EnableGameplayInput(false);
        SaveManager.Instance.SaveSceneStateToMemory();
        
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(true);
        }
        
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(battleSceneName);
        while (!asyncLoad.isDone)
        {
            yield return null;
        }
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
    }
    
    private IEnumerator LoadAfterBattleCoroutine()
    {
        ProcessBattleResults();
        UpdatePartyStatusAfterBattle();
        
        string targetScene = sceneBeforeBattle;
        if (string.IsNullOrEmpty(targetScene)) targetScene = mainSceneName;
        Vector3? targetPosition = null;
        string eventToTrigger = null;
        if (!lastBattleWon && CurrentEncounter != null)
        {
            Debug.Log($"[GameManager] 戰鬥失敗。處理方式: {CurrentEncounter.defeatType}");
            
            switch (CurrentEncounter.defeatType)
            {
                case DefeatActionType.ReturnToTitle:
                    Debug.Log("Game Over - 返回標題 (暫時返回原場景)"); 
                    break;

                case DefeatActionType.TeleportToScene:
                    if (!string.IsNullOrEmpty(CurrentEncounter.defeatSceneName))
                    {
                        targetScene = CurrentEncounter.defeatSceneName;
                        targetPosition = CurrentEncounter.defeatPosition;
                    }
                    break;
                
                case DefeatActionType.TriggerStoryEvent:
                    eventToTrigger = CurrentEncounter.defeatEventID;
                    break;
            }
        }
        CurrentEncounter = null;
        
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(true);
        }
        InputManager.Instance?.EnableGameplayInput(false);
        Debug.Log($"[GameManager] 正在載入場景: {targetScene}");
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(targetScene);
        while (!asyncLoad.isDone)
        {
            yield return null;
        }
        yield return new WaitForEndOfFrame();
        
        if (targetScene == sceneBeforeBattle)
        {
            SaveManager.Instance.LoadSceneStateFromMemory();
            if (lastBattleWon && !string.IsNullOrEmpty(currentBattleTriggerID))
            {
                HandleVictoryDestruction(currentBattleTriggerID);
            }
        }
        else
        {
            SaveManager.Instance.LoadSceneStateFromMemory();
        }

        if (targetPosition.HasValue)
        {
            var player = FindObjectOfType<Player>();
            if (player != null)
            {
                player.SetPosition(targetPosition.Value);
            }
        }
        currentBattleTriggerID = null;
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
        
        if (!string.IsNullOrEmpty(eventToTrigger))
        {
            yield return null; 
            GameEventManager.Instance.TriggerEvent(eventToTrigger);
        }
        SetGameState(GameState.Exploration);
    }

    private void HandleVictoryDestruction(string targetID)
    {
        ScenePersistenceManager.Instance.RecordObjectDestruction(targetID);
        var allIdentifiers = FindObjectsOfType<UniqueObjectIdentifier>();
        foreach (var idObj in allIdentifiers)
        {
            if (idObj.ID == targetID)
            {
                Debug.Log($"[GameManager] 戰鬥勝利，銷毀觸發戰鬥的物件: {idObj.name}");
                Destroy(idObj.gameObject);
                break;
            }
        }
    }

    private void UpdatePartyStatusAfterBattle()
    {
        if (BattleManager.Instance == null || PartyManager.Instance == null) return;
        foreach (var unit in BattleManager.Instance.PlayerUnits)
        {
            MemberInstance instanceToUpdate = PartyManager.Instance.AllMembers.FirstOrDefault(
                m => m.instanceID == unit.MemberInstance.instanceID
            );
            if (instanceToUpdate != null)
            {
                instanceToUpdate.currentHP = Mathf.Max(1, unit.CurrentHP);
                Debug.Log($"已更新成員 [{instanceToUpdate.BaseData.memberName}] 的血量為: {instanceToUpdate.currentHP}");
            }
        }
    }

    private void ProcessBattleResults()
    {
        if (BattleManager.Instance == null) return;
        if (BattleManager.Instance.IsBattleWon())
        {
            lastBattleWon = true;

            var encounterData = BattleManager.Instance.EncounterData;
            int totalGold = 0;
            // int totalExp = 0;
            foreach(var enemyUnit in BattleManager.Instance.EnemyUnits)
            {
                if(enemyUnit.EnemyData != null)
                {
                    totalGold += enemyUnit.EnemyData.goldDrop;
                    // totalExp += enemyUnit.EnemyData.expDrop;
                }
            }
            if(PlayerState.Instance != null)
            {
                PlayerState.Instance.AddMoney(totalGold);
                // PlayerState.Instance.GainExperience(totalExp);
                Debug.Log($"戰鬥勝利！獲得金幣: {totalGold}");
            }
            if (QuestManager.Instance != null)
            {
                foreach (var enemyUnit in BattleManager.Instance.EnemyUnits)
                {
                    if (enemyUnit.IsDead && enemyUnit.EnemyData != null)
                    {
                        string enemyID = enemyUnit.EnemyData.enemyID;
                        QuestManager.Instance.AdvanceObjective(enemyID, QuestObjectiveType.Kill, 1);
                        Debug.Log($"向任務系統報告擊殺: {enemyID}");
                    }
                }
            }
        }
        else
        {
            lastBattleWon = false;
        }
    }
}
```

#### 4. TitleManager.cs：
```
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class TitleManager : MonoBehaviour
{
    [Header("主選單按鈕")]
    [SerializeField] private Button newGameButton;
    [SerializeField] private Button loadGameButton;
    [SerializeField] private Button settingsButton;
    [SerializeField] private Button quitButton;

    [Header("UI 面板")]
    [Tooltip("請拖入場景中的 SaveLoadUI 物件 (預設應設為隱藏)")]
    [SerializeField] private SaveLoadUI saveLoadPanel;
    
    [Tooltip("請拖入設定面板物件 (預設應設為隱藏)")]
    [SerializeField] private GameObject settingsPanel;
    
    [Tooltip("設定面板中的關閉按鈕")]
    [SerializeField] private Button closeSettingsButton;

    [Header("遊戲設定")]
    [Tooltip("點擊新遊戲後要載入的第一個場景名稱 (例如 'Town_Beginner')")]
    [SerializeField] private string startingSceneName = "Town_Beginner";

    [SerializeField] private LoadingScreen loadingScreen; 

    private void Start()
    {
        newGameButton.onClick.AddListener(OnNewGameClicked);
        loadGameButton.onClick.AddListener(OnLoadGameClicked);
        settingsButton.onClick.AddListener(OnSettingsClicked);
        quitButton.onClick.AddListener(OnQuitClicked);
        if (closeSettingsButton != null)
        {
            closeSettingsButton.onClick.AddListener(OnCloseSettingsClicked);
        }
        if (saveLoadPanel != null) 
        {
            saveLoadPanel.SetTitleScreenMode(true);
            saveLoadPanel.HidePanel();
        }
        if (settingsPanel != null) settingsPanel.SetActive(false);
        if (InputManager.Instance != null)
        {
            InputManager.Instance.EnableGameplayInput(true);
        }
        Time.timeScale = 1f;
    }

    private void OnNewGameClicked()
    {
        Debug.Log("開始新遊戲...");
        if (loadingScreen != null)
        {
            loadingScreen.Show();
            loadingScreen.UpdateProgress(0, "正在前往新世界...");
        }
        SceneManager.LoadScene(startingSceneName);
    }

    private void OnLoadGameClicked()
    {
        if (saveLoadPanel != null)
        {
            saveLoadPanel.ShowPanel(false); 
        }
        else
        {
            Debug.LogError("SaveLoadUI 未指定！");
        }
    }

    private void OnSettingsClicked()
    {
        if (settingsPanel != null)
        {
            settingsPanel.SetActive(true);
        }
        else
        {
            Debug.Log("設定功能尚未實作 (UI面板未指定)。");
        }
    }

    private void OnCloseSettingsClicked()
    {
        if (settingsPanel != null)
        {
            settingsPanel.SetActive(false);
        }
    }

    private void OnQuitClicked()
    {
        Debug.Log("退出遊戲");
        #if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
        #else
        Application.Quit();
        #endif
    }
}
```

#### 5. CameraController.cs：
```
using UnityEngine;

public class CameraController : MonoBehaviour
{
    [Header("跟隨目標")]
    [Tooltip("如果不指定，會自動尋找 Tag 為 Player 的物件")]
    [SerializeField] private Transform target;

    [Header("移動設定")]
    [Tooltip("數值越小越有慣性，數值越大跟得越緊 (建議 5-10)")]
    [SerializeField] private float smoothing = 5f;

    [Header("地圖邊界限制")]
    [Tooltip("攝影機中心點能到達的左下角極限座標")]
    [SerializeField] private Vector2 minPosition;
    [Tooltip("攝影機中心點能到達的右上角極限座標")]
    [SerializeField] private Vector2 maxPosition;

    private void Start()
    {
        if (target == null)
        {
            GameObject playerObj = GameObject.FindGameObjectWithTag("Player");
            if (playerObj != null)
            {
                target = playerObj.transform;
            }
            else
            {
                Debug.LogWarning("[CameraController] 場景中找不到 Tag 為 Player 的物件，攝影機無法跟隨。");
            }
        }
        
        if (target != null)
        {
            Vector3 startPos = new Vector3(target.position.x, target.position.y, transform.position.z);
            startPos.x = Mathf.Clamp(startPos.x, minPosition.x, maxPosition.x);
            startPos.y = Mathf.Clamp(startPos.y, minPosition.y, maxPosition.y);
            transform.position = startPos;
        }
    }

    private void LateUpdate()
    {
        if (StoryManager.Instance != null && StoryManager.Instance.IsStorySceneActive)
        {
            return; 
        }
        if (target != null)
        {
            Vector3 targetPos = new Vector3(target.position.x, target.position.y, transform.position.z);
            targetPos.x = Mathf.Clamp(targetPos.x, minPosition.x, maxPosition.x);
            targetPos.y = Mathf.Clamp(targetPos.y, minPosition.y, maxPosition.y);
            transform.position = Vector3.Lerp(transform.position, targetPos, smoothing * Time.deltaTime);
        }
    }

    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.yellow;
        Vector3 center = new Vector3((minPosition.x + maxPosition.x) / 2, (minPosition.y + maxPosition.y) / 2, 0);
        Vector3 size = new Vector3(Mathf.Abs(maxPosition.x - minPosition.x), Mathf.Abs(maxPosition.y - minPosition.y), 0);
        Gizmos.DrawWireCube(center, size);
    }
}
```

#### 6. CursorManager.cs：
```
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class CursorManager : MonoBehaviour
{
    public static CursorManager Instance { get; private set; }

    [Header("游標元件")]
    [SerializeField] private Image customCursorImage;
    [SerializeField] private TextMeshProUGUI quantityText;
    [SerializeField] private Canvas parentCanvas;

    [Header("提示框元件")]
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TextMeshProUGUI tooltipText;
    [SerializeField] private Vector3 tooltipOffset = new Vector3(20, -20, 0);

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        ResetCursor();
        HideTooltip();
    }

    void Update()
    {
        Vector2 mousePos = Input.mousePosition;
        if (customCursorImage != null && customCursorImage.gameObject.activeSelf)
        {
            Vector2 pos;
            RectTransformUtility.ScreenPointToLocalPointInRectangle(
                parentCanvas.transform as RectTransform,
                mousePos,
                parentCanvas.worldCamera,
                out pos);
            customCursorImage.transform.position = mousePos;
        }
        if (tooltipPanel != null && tooltipPanel.activeSelf)
        {
            tooltipPanel.transform.position = mousePos + (Vector2)tooltipOffset;
        }
    }

    public void SetCursorIcon(Sprite icon)
    {
        if (customCursorImage != null && icon != null)
        {
            customCursorImage.sprite = icon;
            customCursorImage.gameObject.SetActive(true);
            customCursorImage.raycastTarget = false;
            Cursor.visible = false;
        }
    }

    public void SetQuantityText(string text)
    {
        if (quantityText != null)
        {
            quantityText.text = text;
            quantityText.gameObject.SetActive(!string.IsNullOrEmpty(text));
        }
    }

    public void ShowTooltip(string content)
    {
        if (tooltipPanel != null && tooltipText != null)
        {
            tooltipText.text = content;
            tooltipPanel.SetActive(true);
        }
    }

    public void HideTooltip()
    {
        if (tooltipPanel != null)
        {
            tooltipPanel.SetActive(false);
        }
    }

    public void ResetCursor()
    {
        if (customCursorImage != null)
        {
            customCursorImage.gameObject.SetActive(false);
        }
        if (quantityText != null)
        {
            quantityText.gameObject.SetActive(false);
        }
        Cursor.visible = true;
    }
}
```

---

#### 1. GameEventListener.cs：
```
using UnityEngine;
using UnityEngine.Events;
using System.Collections;

public class GameEventListener : MonoBehaviour
{
    [Header("事件監聽設定")]
    [Tooltip("此監聽器要響應的遊戲事件的唯一ID。")]
    [SerializeField] private string eventIDToListenFor;

    [Header("觸發行為控制")]
    [Tooltip("勾選此項，此監聽器只會成功觸發一次。之後即使再監聽到相同事件，也不會執行動作。")]
    [SerializeField] private bool triggerOnceGlobally = true;

    [Tooltip("勾選此項，當物件初始化時，如果該事件曾經發生過，則立即執行響應動作（例如銷毀物件）。這對於場景狀態恢復非常重要。")]
    [SerializeField] private bool checkOnStart = true;

    [Header("可選：直接觸發教學")]
    [Tooltip("（可選）當事件觸發時，直接啟動此ID對應的教學。")]
    [SerializeField] private string tutorialIDToTrigger;
    
    [Tooltip("如果觸發了教學，此監聽器是否應只觸發一次？")]
    [SerializeField] private bool triggerTutorialOnce = true;

    [Header("響應動作")]
    [Tooltip("當監聽到對應的事件ID時，要執行的通用動作。")]
    [SerializeField] private UnityEvent onEventTriggered;

    private bool hasTriggeredTutorial = false;

    private void OnEnable()
    {
        if (GameEventManager.Instance != null)
        {
            GameEventManager.OnEventTriggered += HandleEventTriggered;
        }
        else
        {
            StartCoroutine(DelayedSubscribe());
        }
    }

    private void Start()
    {
        if (checkOnStart)
        {
            StartCoroutine(CheckStateOnStart());
        }
    }

    private void OnDisable()
    {
        if (GameEventManager.Instance != null)
        {
            GameEventManager.OnEventTriggered -= HandleEventTriggered;
        }
    }

    private IEnumerator DelayedSubscribe()
    {
        yield return new WaitUntil(() => GameEventManager.Instance != null);
        GameEventManager.OnEventTriggered += HandleEventTriggered;
    }

    private IEnumerator CheckStateOnStart()
    {
        yield return new WaitUntil(() => GameEventManager.Instance != null && SaveManager.Instance != null);
        yield return null;
        if (GameEventManager.Instance.HasEventBeenTriggered(eventIDToListenFor))
        {
            if (triggerOnceGlobally)
            {
                Debug.Log($"[GameEventListener] 初始化檢查：事件 '{eventIDToListenFor}' 歷史記錄中已存在，立即執行響應動作。");
                onEventTriggered.Invoke();
            }
        }
    }

    private void HandleEventTriggered(string triggeredID)
    {
        if (triggeredID == eventIDToListenFor)
        {
            if (triggerOnceGlobally)
            {
                string listenerRespondedEventID = $"Listener_{gameObject.scene.name}_{gameObject.name}_{eventIDToListenFor}";
                if (GameEventManager.Instance.HasEventBeenTriggered(listenerRespondedEventID))
                {
                    Debug.Log($"[GameEventListener] '{gameObject.name}' 監聽到事件 '{triggeredID}'，但記錄顯示它已響應過，已忽略。");
                    return;
                }
                GameEventManager.Instance.TriggerEvent(listenerRespondedEventID);
            }
            Debug.Log($"[GameEventListener] 物件 '{gameObject.name}' 監聽到事件 '{triggeredID}'，並執行響應動作。");
            onEventTriggered.Invoke();
            
            if (!string.IsNullOrEmpty(tutorialIDToTrigger))
            {
                if (triggerTutorialOnce && hasTriggeredTutorial)
                {
                    return;
                }
                if (TutorialManager.Instance != null && !TutorialManager.Instance.GetCompletedTutorials().Contains(tutorialIDToTrigger))
                {
                    Debug.Log($"...並直接觸發教學 '{tutorialIDToTrigger}'。");
                    TutorialManager.Instance.ShowTutorial(tutorialIDToTrigger);
                }
                hasTriggeredTutorial = true;
            }
        }
    }
}
```

#### 2. QuestStateListener.cs：
```
using UnityEngine;
using UnityEngine.Events;
using System.Collections;

public enum QuestListenType { OnAccepted, OnCompleted, IsCompletable }

[System.Serializable]
public class QuestStateListenerState
{
    public bool hasAlreadyTriggered;
    // (可選) 如果 IsCompletable 類型的監聽器需要更精細的控制，可以把 hasTriggeredForCompletable 也放進來
    // public bool hasTriggeredForCompletable;
}

public class QuestStateListener : MonoBehaviour, ISceneSaveable
{
    [Header("監聽設定")]
    [Tooltip("要監聽的任務的唯一ID。")]
    [SerializeField] private string questIDToListenFor;
    
    [Tooltip("選擇要監聽的任務狀態事件類型。")]
    [SerializeField] private QuestListenType listenType = QuestListenType.OnCompleted;

    [Header("觸發行為")]
    [Tooltip("勾選此項，此監聽器在觸發一次後即失效，防止讀檔或重複滿足條件時重複觸發。")]
    [SerializeField] private bool triggerOnce = true;

    [Header("響應動作")]
    [Tooltip("當監聽到任務達到指定狀態時，要執行的動作。")]
    [SerializeField] private UnityEvent onStateMatched;

    private bool hasTriggeredForCompletable = false;
    private bool hasAlreadyTriggered_runtime = false;

    void OnEnable()
    {
        StartCoroutine(SubscribeAfterInitialization());
    }

    void OnDisable()
    {
        UnsubscribeFromEvents();
    }
    
    private IEnumerator SubscribeAfterInitialization()
    {
        yield return new WaitUntil(() => QuestManager.Instance != null && SaveManager.Instance != null);
        SubscribeToEvents();
        yield return null; 
        CheckInitialState();
    }

    private void SubscribeToEvents()
    {
        if (QuestManager.Instance == null) return;
        switch (listenType)
        {
            case QuestListenType.OnAccepted:
                QuestManager.Instance.OnQuestAccepted += HandleQuestStateChange;
                break;
            case QuestListenType.OnCompleted:
                QuestManager.Instance.OnQuestCompleted += HandleQuestStateChange;
                break;
            case QuestListenType.IsCompletable:
                QuestManager.Instance.OnQuestUpdated += HandleQuestStateChange;
                break;
        }
    }

    private void UnsubscribeFromEvents()
    {
        if (QuestManager.Instance == null) return;
        switch (listenType)
        {
            case QuestListenType.OnAccepted:
                QuestManager.Instance.OnQuestAccepted -= HandleQuestStateChange;
                break;
            case QuestListenType.OnCompleted:
                QuestManager.Instance.OnQuestCompleted -= HandleQuestStateChange;
                break;
            case QuestListenType.IsCompletable:
                QuestManager.Instance.OnQuestUpdated -= HandleQuestStateChange;
                break;
        }
    }

    private void CheckInitialState()
    {
        if (triggerOnce && hasAlreadyTriggered_runtime) return;
        bool isMatched = false;
        var questStatus = QuestManager.Instance.GetQuestStatus(questIDToListenFor);
        switch (listenType)
        {
            case QuestListenType.OnAccepted:
                isMatched = (questStatus == Quest.QuestStatus.InProgress || questStatus == Quest.QuestStatus.Completed);
                break;
            case QuestListenType.OnCompleted:
                isMatched = (questStatus == Quest.QuestStatus.Completed);
                break;
            case QuestListenType.IsCompletable:
                isMatched = (questStatus == Quest.QuestStatus.InProgress && QuestManager.Instance.IsQuestCompletable(questIDToListenFor));
                break;
        }

        if (isMatched)
        {
            HandleQuestStateChange(questIDToListenFor);
        }
    }

    private void HandleQuestStateChange(string changedQuestID)
    {
        if (changedQuestID != questIDToListenFor) return;
        if (triggerOnce && hasAlreadyTriggered_runtime)
        {
            return;
        }

        bool shouldTrigger = false;
        switch (listenType)
        {
            case QuestListenType.OnAccepted:
            case QuestListenType.OnCompleted:
                shouldTrigger = true;
                break;
            
            case QuestListenType.IsCompletable:
                if (QuestManager.Instance.IsQuestCompletable(questIDToListenFor) && !hasTriggeredForCompletable)
                {
                    shouldTrigger = true;
                    hasTriggeredForCompletable = true;
                }
                break;
        }

        if (shouldTrigger)
        {
            Debug.Log($"[QuestStateListener] 物件 '{gameObject.name}' 監聽到任務 '{changedQuestID}' 狀態匹配，正在執行響應動作。");
            onStateMatched.Invoke();
            
            hasAlreadyTriggered_runtime = true;
        }
    }
    
    public object CaptureState()
    {
        return new QuestStateListenerState
        {
            hasAlreadyTriggered = this.hasAlreadyTriggered_runtime
        };
    }

    public void RestoreState(object stateData)
    {
        if (stateData is string stateJson)
        {
            var state = JsonUtility.FromJson<QuestStateListenerState>(stateJson);
            this.hasAlreadyTriggered_runtime = state.hasAlreadyTriggered;
        }
    }
}
```