Unity 2D PRG 遊戲 Demo

### **系統架構總覽**

目前的遊戲系統是一個以**數據驅動 (Data-Driven)** 為核心的架構。
遊戲的內容，如物品、對話和任務，主要存放在外部檔案（ScriptableObject 和 XML）中，而 C# 腳本則作為這些數據的「執行引擎」。
這種架構的優點是**高靈活性**和**易於擴展**，策劃或設計師可以透過修改數據文件來改變遊戲內容，而不需要改動程式碼。

系統可以分為以下幾個核心模組：

1.  **玩家與輸入 (Player & Input & Interaction)**：負責玩家的基礎操作、與世界的互動或家可以互動的對象。
2.  **物品與背包 (Item & Inventory)**：管理所有遊戲內物品的數據、拾取、儲存和使用。
3.  **對話系統 (Dialogue System)**：處理所有遊戲中的文字互動，是一個基於 XML 的強大敘事引擎。
4.  **任務系統 (Quest System)**：管理任務的生命週期，從接取到完成，並與對話系統緊密耦合。
5.  **隊伍系統 (Party System & JSON System)**：管理所有遊戲內成員的數據、資料、儲存和使用，和玩家隊伍的檔案進度存取、讀取。
6.  **戰鬥系統 (Battle System)**：一個詳細的回合制戰術戰鬥系統，包含行動規劃、交錯執行、狀態管理等核心功能。

---

### **各腳本功能簡介**

### **一、 **玩家、輸入模組、互動模組 (Player & Input Module & Interaction Module)**

*   `Player.cs`:
    *   **職責**：玩家的物理控制器與互動發起者。
    *   **功能**：處理基於 `Rigidbody2D` 的移動。偵測並記錄周圍的可拾取物品 (`GroundItem`) 和可互動物件 (`IInteractable`)。提供 `TryPickupItem()` 和 `TryInteract()` 方法供 `KeyManager` 呼叫。

*   `PlayerState.cs`:
    *   **職責**：玩家的核心數據容器。
    *   **功能**：儲存玩家的非背包數據，目前主要是金錢 (`money`)。提供了增加和花費金錢的接口，是交易系統的基礎。

*   `KeyManager.cs`:
    *   **職責**：中央輸入處理器。
    *   **功能**：監聽所有非移動的鍵盤輸入（如 `I` 開背包, `Q` 開任務, `E` 互動, `Space` 拾取, `ESC` 關閉面板），並將這些指令分派給對應的管理系統（`InventoryManager`, `QuestUI`, `Player`）。

*   `IInteractable.cs` (Interface):
    *   **職責**：定義一個「可互動」的標準。
    *   **功能**：只包含一個 `Interact()` 方法。任何實現了此接口的類（如 `NPC`, `DialogueTrigger`）都可以被 `Player` 識別並與之互動。

*   `NPC.cs`:
    *   **職責**：非玩家角色的核心組件。
    *   **功能**：
        *   實現了 `IInteractable` 接口。包含唯一的 `npcID` 和一個可提供的**任務列表** (`availableQuestIDs`)。當玩家與其互動時，它會啟動 `DialogueManager`，觸發其指定的入口對話 (`mainDialogueID`)。
        *   **傳遞身份**：當玩家與其互動時，它在啟動 `DialogueManager` 的同時，會**將自己的 `npcID` 一併傳遞過去**。這一步對於實現精確的動態選項至關重要。

*   `DialogueTrigger.cs`:
    *   **職責**：通用的對話觸發器。
    *   **功能**：實現了 `IInteractable` 接口。可以放置在任何物件上（如一個告示牌、一本書），當玩家與其互動時，觸發一段指定的對話。是實現非 NPC 對話的便捷方式。

*   `BattleTrigger.cs`:
    *   **職責**：通用的戰鬥觸發器。
    *   **功能**：在非戰鬥場景中用於啟動戰鬥的「觸發器」，持有 BattleEncounterSO 的引用。

---

#### **二、 物品與背包模組 (Item & Inventory Module)**

*   `Item.cs` (ScriptableObject):
    *   **職責**：定義單個物品的所有靜態數據。
    *   **功能**：作為物品的模板，包含名稱、描述、圖標、類型、堆疊上限、唯一ID (`uniqueItemID`) 和交易價格等。

*   `ItemDatabase.cs` (ScriptableObject):
    *   **職責**：所有物品的總資料庫。
    *   **功能**：存放遊戲中所有 `Item` ScriptableObject 的列表，並提供一個靜態方法 `GetItemByID()`，讓其他系統可以透過唯一ID快速查找物品數據。

*   `Inventory.cs` (ScriptableObject):
    *   **職責**：定義一個背包的數據結構。
    *   **功能**：包含背包的容量 (`capacity`) 和一個 `InventorySlot` 列表，用於實際儲存物品。允許多個不同背包的存在（如玩家背包、倉庫）。

*   `InventorySlot.cs`:
    *   **職責**：背包中的單個格子。
    *   **功能**：儲存一個 `Item` 的引用和其數量 (`quantity`)。封裝了添加、移除、清空和交換物品的核心邏輯。

*   `GroundItem.cs`:
    *   **職責**：代表掉落在地上的物品實體。
    *   **功能**：掛載在一個遊戲物件上，使其可被玩家拾取。包含 `Item` 數據和數量，並透過 `AttemptPickup()` 方法與 `InventoryManager` 互動。

*   `InventoryManager.cs`:
    *   **職責**：背包系統的總管（單例）。
    *   **功能**：管理玩家的 `Inventory` 數據。處理添加 (`AddItem`)、移除 (`RemoveItem`)、查詢 (`HasItem`) 物品的邏輯。與 `InventoryUI` 溝通以刷新界面，並在拋棄物品時生成 `GroundItem`。

*   `InventoryUI.cs` & `InventorySlotUI.cs`:
    *   **職責**：背包的視覺表現。
    *   **功能**：`InventoryUI` 根據 `Inventory` 數據動態生成 `InventorySlotUI` 列表。`InventorySlotUI` 負責顯示單個格子的圖標和數量。同時處理拖拽 (`ItemDragHandler`) 和點擊顯示詳情 (`ItemDetailsPanel`) 的交互。

*   `ItemDetailsPanel.cs` & `ItemDropUI.cs`:
    *   **職責**：物品的交互面板。
    *   **功能**：`ItemDetailsPanel` 顯示被點擊物品的詳細資訊，並提供使用/丟棄按鈕。`ItemDropUI` 在丟棄物品時彈出，讓玩家可以選擇丟棄的數量。

*   `ItemDragHandler.cs`:
    *   **職責**：處理背包格子內物品的拖拽邏輯。
    *   **功能**：實現 Unity 的拖拽接口 (`IBeginDragHandler` 等)，允許玩家在背包內移動或堆疊物品。

---

#### **三、 對話系統模組 (Dialogue System Module)**

*   `DialogueData.cs`:
    *   **職責**：定義對話數據的 C# 類別結構。
    *   **功能**：完美映射了 `dialogues.xml` 的結構，包括 `DialogueSegment` (對話片段), `DialogueOption` (選項), `DialogueBranch` (條件分支) 和 `DialogueAction` (動作)，是 XML 數據在內存中的體現。`DynamicOptions` (動態選項請求) 和 `DialogueOptionTemplate` (選項範本) 的結構**，使程式能理解 XML 中動態生成選項的指令。

*   `DialogueManager.cs`:
    *   **職責**：對話系統的大腦（單例），具備**動態內容生成**能力。
    *   **功能**：
        *   負責載入和快取 XML 對話檔案，並管理整個對話流程。
        *   **動態選項生成**：能夠解析 `<DynamicOptions>` 標籤，主動向 `QuestManager` 等其他系統查詢數據（如可接任務列表），並根據查詢結果和範本 (`OptionTemplate`) 即時創建對話選項。
        *   當遇到被標記為 `IsEnd` 且沒有任何可用選項的對話片段時，會**自動生成一個 `[離開]` 按鈕**，防止遊戲流程卡死。
        *   **追蹤互動對象**：能記錄當前是哪個 `NPC` 觸發了對話，以便精準地處理針對該 NPC 的動態選項請求。
        *   **對話流程控制**：根據 `DialogueTrigger` 或 `NPC` 的請求，啟動和管理整個對話流程。核心功能是解析 `DialogueBranch`，執行 `QuestManager` 的條件檢查，並根據結果觸發對應的 `DialogueAction`（如跳轉片段、結束對話、啟動新對話模組）。

*   `DialogueUI.cs`:
    *   **職責**：對話的視覺界面。
    *   **功能**：接收 `DialogueManager` 的指令，顯示說話人姓名、對話文本，並動態生成選項按鈕。能夠**完美展示由 `DialogueManager` 靜態或動態生成的任何選項列表**。

---

#### **四、 任務系統模組 (Quest System Module)**

*   `QuestData.cs`:
    *   **職責**：定義任務數據的 C# 類別結構。
    *   **功能**：映射了 `quests.xml` 的結構，包含任務ID、名稱、描述、目標 (`QuestObjective`)、獎勵 (`ItemReward`)，以及核心的**前提條件** (`Prerequisites`) 和**可重複性** (`IsRepeatable`)。

*   `QuestDatabase.cs`:
    *   **職責**：任務的靜態資料庫。
    *   **功能**：在遊戲啟動時載入 `quests.xml`，並將所有任務數據存入字典中。提供靜態方法 `GetQuest()` 供 `QuestManager` 獲取任務的原始模板。

*   `QuestManager.cs`:
    *   **職責**：所有任務狀態的管理者（單例）。
    *   **功能**：
        *   追蹤每個任務的當前狀態 (`NotStarted`, `InProgress`, `Completed`) 和進度。提供接受 (`AcceptQuest`)、完成 (`CompleteQuest`) 任務的接口。
        *   **提供任務列表查詢**：新增了 `GetAvailableQuestsForNPC()` 和 `GetInProgressOrCompletableQuestsForNPC()` 等方法。這些方法不再只返回 `true/false`，而是**直接返回一個完整的任務物件列表 (`List<Quest>`)**，供 `DialogueManager` 用來動態生成選項。
        *   最重要的是，它提供了多種查詢方法（如 `HasAvailableQuests`, `IsQuestCompletable`）供 `DialogueManager` 進行條件判斷。

*   `QuestUI.cs`:
    *   **職責**：任務日誌的視覺界面。
    *   **功能**：顯示進行中和已完成的任務列表。點擊任務項可查看詳細描述、目標進度和獎勵。透過訂閱 `QuestManager` 的事件，實現任務狀態改變時的自動刷新。

---

#### **五、 隊伍系統、JSON 系統模組 (Party System Module & JSON System)**

*   `MemberDataSO.cs` (ScriptableObject):
    *   **職責**：定義一個成員的「原始設計藍圖」。
    *   **功能**：
        *   包含成員的靜態資料，如 ID、名稱、圖像、基礎屬性與成長規則。
        *   由開發者在 Unity 編輯器中設定，作為遊戲的基礎設定值，一旦設定好就不會改變。

*   `PartyDatabase.cs` (ScriptableObject):
    *   **職責**：為遊戲中所有成員設計藍圖 (`MemberDataSO`) 的「中央資料庫」。
    *   **功能**：
        *   持有一個遊戲中所有 `MemberDataSO` 的列表。
        *   提供一個全域靜態方法 (`GetMemberDataByID`)，讓任何腳本都能透過 ID 快速查詢到成員的原始資料，是整個系統的資料來源。

*   `MemberInstance.cs` (Serializable Class):
    *   **職責**：代表一個玩家「實際擁有、會成長」的成員個體。
    *   **功能**：
        *   儲存動態資料，如等級、經驗值、當前血量。
        *   透過 `memberDataSO_ID` 關聯到它的設計藍圖，並以此計算出當前的最大血量、攻擊力等屬性。
        *   擁有一個獨一無二的 `instanceID`，用於在存檔中識別每一個體。
        *   這個類別的物件會被寫入 JSON 存檔中，記錄玩家進度。

*   `PartyManager.cs`:
    *   **職責**：作為隊伍系統的「中央管理器」，處理所有隊伍相關的邏輯與狀態變更。
    *   **功能**：
        *   管理玩家的兩個核心列表：`AllMembers` (所有成員倉庫) 和 `BattleParty` (戰鬥隊伍)。
        *   提供方法來執行操作，如「上陣」、「卸下」、「交換順序」。
        *   當隊伍資料發生任何變動（如成員增減、順序變更）時，會觸發一個全域事件 (`OnPartyUpdated`)，通知所有 UI 介面進行更新。
        *   作為存檔和讀檔的發起點，會呼叫 `JSONSaveManager` 來執行實際的檔案操作。

*   `MemberCardUI.cs`:
    *   **職責**：作為可重用的 UI 元件，專門用來顯示成員的「基礎資訊卡片」（如倉庫列表）。
    *   **功能**：
        *   接收一個 `MemberInstance` 資料，並在卡片上顯示其名稱和圖像。
        *   處理點擊事件，通知上層管理器（如 `PartyHolderUI`）玩家選擇了哪個成員。
        *   根據傳入的狀態（如是否被選中、是否在戰鬥隊伍中）顯示不同的視覺效果，例如發光的邊框。

*   `MemberStatCardUI.cs`:
    *   **職責**：作為可重用的 UI 元件，專門用來顯示成員的「詳細戰鬥屬性卡片」（如戰鬥隊伍欄位）。
    *   **功能**：
        *   接收一個 `MemberInstance` 資料，並顯示更詳細的資訊，如名稱、圖像、當前/最大血量、攻擊力等。

*   `PartyHolderUI.cs`:
    *   **職責**：管理「全部成員倉庫」的 UI 介面。
    *   **功能**：
        *   監聽 `PartyManager` 的 `OnPartyUpdated` 事件。
        *   事件觸發時，它會根據 `PartyManager` 的 `AllMembers` 列表，動態生成或更新所有 `MemberCardUI`。
        *   當卡片被點擊時，它會呼叫 `PartyDetailUI` 來顯示該成員的詳細資料。

*   `PartyBattleUI.cs`:
    *   **職責**：管理「當前戰鬥隊伍」的 UI 介面。
    *   **功能**：
        *   同樣監聽 `OnPartyUpdated` 事件。
        *   事件觸發時，它會根據 `PartyManager` 的 `BattleParty` 列表，更新戰鬥隊伍欄位中的 `MemberStatCardUI`。
        *   負責顯示當前出戰成員的卡片，並處理拖曳交換順序等互動。

*   `PartyDetailUI.cs`:
    *   **職責**：管理「成員詳細資料」的彈出式面板。
    *   **功能**：
        *   平時隱藏，在玩家點擊任一成員卡片時被呼叫並顯示。
        *   展示指定 `MemberInstance` 的所有詳細數據（等級、經驗、屬性等）。
        *   面板上的「上陣/卸下」按鈕會根據該成員的當前狀態動態改變其文字和功能。

*   `JSONSaveManager.cs`:
    *   **職責**：專職的「存檔與讀檔工具人」，負責處理 JSON 序列化與檔案系統操作。
    *   **功能**：
        *   提供 `SavePartyData` 方法，將 `PartySaveData` 物件轉換成 JSON 格式的文字，並寫入硬碟檔案。
        *   提供 `LoadPartyData` 方法，從硬碟讀取 JSON 檔案，將其轉換回 `PartySaveData` 物件，並交還給 `PartyManager`。
        *   管理存檔路徑，並能在讀檔時進行資料驗證，確保存檔的相容性。

*   `PartySaveData.cs` (Serializable Class):
    *   **職責**：作為一個資料「包裹」或「容器」，專門用來配合 Unity 的 JSON 工具進行序列化。
    *   **功能**：
        *   它的存在是為了解決技術限制：Unity 的 `JsonUtility` 無法直接序列化一個根層級的 List。
        *   它將所有需要存檔的列表（如 `AllMembers` 和 `BattlePartyInstanceIDs`）打包成一個單一的物件，讓 `JSONSaveManager` 可以順利地處理。好的，這就為您口語化地整理一下剛剛那些腳本的功能介紹。

---

#### **六、 戰鬥系統模組 (Battle System Module)**

**戰鬥系統核心資料結構**
1. BattleEnums.cs(遊戲字典)：
(1) 戰鬥角色職責：[前衛][遠1][遠2][後勤]
(2) 玩家可執行的行動類型：[攻擊][防禦][休息][技能][道具][交換位置][跳過]
(3) UI 指令類型：[指揮官技能][返回][回合結束][清空規劃][取消單一行動]
(4) 回合管理器的狀態：[戰鬥開始][玩家規劃階段][玩家選擇目標階段][敵人回合][行動執行階段][戰鬥勝利][戰鬥失敗]
(5) 戰場位置：[玩家後勤][玩家遠2][玩家遠1][玩家前衛][敵人前衛][敵人遠1][敵人遠2][敵人後勤]

2. EnemyDataSO.cs (ScriptableObject)：
(1) 敵人基礎模板 (由開發者在Unity編輯器中設定)
*   **基礎資訊**: 敵人ID (獨一無二的編號)、敵人名稱、敵人圖像 (`Sprite` 引用)。
*   **基礎屬性**: 基礎血量、基礎攻擊力、體力(攻擊、施放技能消耗)、攻擊距離。
*   **技能槽位**: 從技能腳本中挑選技能ID輸入。
*   **物品掉落**: 會掉落的物品，如金錢、物品。

3. BattleEncounterSO.cs (戰鬥遭遇和配置)
介紹：它可以讓您把一場「戰鬥」打包成一個檔案。
(1) 隊伍配置：引用 `EnemyDataSO` 來定義敵方隊伍的組成、數量與初始位置，並將此配置提供給 `BattleManager`。
(2) 獎勵計算：根據配置的敵人，預先計算戰鬥勝利後的總獎勵，並將結果傳輸給 `BattleEndUI`。

4. ActionPlan.cs(資料容器)：
介紹：用於儲存單一、已規劃行動的數據結構。
(1) 行動數據：儲存一個行動的完整資訊，包含行動發起者、行動類型、行動目標。
(2) 階段索引：包含一個 `phaseIndex` 屬性 (值為 1-4)，標示此行動歸屬於回合中的哪一個行動階段。
(3) 傳遞資料：
    * 設立一個 `關聯行動ID`:public Guid TransactionID { get; set; }
    * 一個獨立的標識符，用於將多個 ActionPlan 標記為同一個「關聯行動」。
    * 對於獨立行動（如攻擊、防禦），這個行動ID為 0 (或 null)。
    * 對於需要多個行動格配合的特殊行動（如「交換位置」），所有的「關聯行動」都會被賦予同一個非 0 的行動ID（例如，1）。
    * 將自身作為數據包傳遞給 `TurnActionPlanner` 進行排程。

---

**Prefab (預製件盒 - 遊戲世界的實體零件)**
1. BattleUnit.cs(戰鬥單位)：
介紹：附加於角色 Prefab 上的核心組件，代表一個可參與戰鬥的獨立單位，處理所有即時戰鬥狀態。它是整個戰鬥單位的數據與邏輯中心。
(1) 核心狀態與數據分離：
*   實際核心數據 (Core Data)：
    *   位置數據：儲存該單位在戰場上的當前格子位置。此數值在單位初始化和位置交換時會被更新。
    *   範圍數據：儲存該單位的攻擊距離。此數值在初始化時從其對應的數據源（如玩家角色數據或 EnemyDataSO）讀取。
    *   體力數據：儲存該單位實際的體力值。此數值在初始化時從其對應的數據源讀取。
*   狀態管理：
        *   初始化單位屬性、處理傷害計算、判定單位陣亡、執行位置變更。提供公開的方法供 TurnManager 調用，用於直接修改自身的當前狀態。
        *   提供公開的方法供 TurnManager 或 BattleActions 調用，用於直接修改自身的核心數據。
            * (int amount): 扣除指定數量的體力。
            * (UnitStateSnapshot snapshot): 根據傳入的快照，將自身的體力等狀態恢復到快照中的數值。
(2) 戰術沙盤預演接口：
    *   此方法僅用於視覺預演，不觸及任何核心數據。
    *   接收來自 BattlefieldStateSimulator 的指令，將單位模型平滑移動到 previewPosition，並更新一個獨立的、僅用於預覽的UI元素（如一個半透明的體力條或一個數字標籤）來顯示 previewStamina。
    *   將單位的所有視覺表現（位置、UI顯示）重置，使其與實際核心數據 (CurrentPosition, CurrentStamina) 完全匹配。
(3) 狀態反饋：提供接口以改變自身視覺外觀，用於顯示「可被選為目標」、「不可選」或**「當前正在規劃的單位」**等狀態。
(4) 點擊事件：處理自身的點擊事件（主要用於玩家在選擇目標時），並將事件通知 `BattleUIManager`。

2. ActionButtonUI.cs (行動按鈕)：
介紹：一個標準化的行動UI按鈕模板。
(1) 事件傳遞: 被點擊時，通知 `BattleUIManager` 玩家選擇了何種行動。
(2) 內容顯示: 包含可配置的圖像與文字，用於顯示具體行動的資訊。

3. ActionSlotUI.cs(單一行動格內容)：
介紹：在戰術規劃板上，負責視覺化顯示一個已規劃行動的UI元件。
(1) 視覺化呈現：接收一個 `ActionPlan` 物件，並根據其數據更新自身的圖示與文字。
(2) 取消按鈕：當此取消按鈕被點擊時，它會將自身的階段索引（1-4）以及陣營信息（玩家方）回報給 BattleUIManager。

4. HealthUI.cs(血條)：
介紹：掛載於 `BattleUnit` 上的UI組件，用於顯示其生命值。
(1) 狀態追蹤：持續追蹤目標 `BattleUnit` 的當前血量。
(2) 更新顯示：在目標血量發生變化時，即時更新UI上的血條顯示。

5. BattleTrigger.cs (戰鬥觸發器)：
介紹：在非戰鬥場景中用於啟動戰鬥的觸發器。
(1) 數據引用：持有一個 `BattleEncounterSO` 的引用。
(2) 觸發戰鬥：當玩家角色與其發生交互時，通知 `GameManager` 啟動戰鬥，並將持有的 BattleEncounterSO 數據傳遞出去。

---

**UI (使用者介面盒 - 玩家的操作面板)**
(所有UI面板的職責均為：**接收來自 `BattleUIManager` 的指令來顯示或隱藏，並將玩家的輸入回報給 `BattleUIManager`**。)
1. ActionPanelUI.cs(行動按鈕面板)：
介紹：容納並管理當前所選角色所有可用行動按鈕的面板。
(1) 動態顯示：根據當前選擇的角色職責（[前衛]、[遠1]、[遠2]、[後勤]），顯示對應的專屬行動按鈕。
* [前衛]：攻擊、防禦、休息、技能、道具、位置交換、跳過。
* [遠1]：攻擊、技能、休息、道具、位置交換、跳過。
* [遠2]：攻擊、技能、休息、道具、位置交換、跳過。
* [後勤]：指揮官技能。(這個按鈕的操作獨立於行動格規劃。)
(2) 狀態同步：根據 `BattleRules` 的判斷結果，將不滿足使用條件(如行動次數耗盡、體力不足、距離不對、指揮官技能已使用)的按鈕設置為不可點擊的灰色狀態。

2. ActionSlotPanelUI.cs(戰術規劃板)：
介紹：視覺化呈現本回合所有行動規劃的面板，並在特定階段提供輸入功能。
(1) 行動格概念：一個回合由 4 個對稱的「行動階段」(Phase) 組成。玩家與敵人雙方都擁有這 4 個行動格的規劃權。此面板專門用於顯示玩家方的規劃。
(2) 結構生成：在畫面中生成代表4個行動階段的槽位。每個槽位應能**動態地**容納和顯示來自 [前衛] 或 [遠程] 的行動 (`ActionSlotUI`)。如果某個職位（如所有[遠程]單位）在隊伍中不存在，則對應的行動格區域不應顯示或應保持為空。
(3) 規劃更新：根據 `TurnActionPlanner` 中儲存的玩家方 `ActionPlan` 列表，更新所有 `ActionSlotUI` 的顯示內容。如果某個行動不存在，對應的UI應為空白（包含行動圖示和取消按鈕的可見性）。
(4) 規劃進度高亮：當 `TurnManager` 指示開始規劃某個行動格時，此面板上對應的 `ActionSlotUI` 應變為高亮狀態，以引導玩家的注意力。

3. BattleEndUI.cs(戰鬥結算畫面)：
介紹：顯示戰鬥結束後結果的UI介面。
(1) 顯示勝利：獲勝後顯示結算UI和退出按鈕。
(2) 顯示失敗：我方全滅時，顯示失敗面板和退出按鈕。

4. BattleLog.cs(戰鬥日誌)：
介紹：時間順序記錄並顯示戰鬥過程中所有關鍵事件的文本日誌。
(1) 事件記錄：接收戰鬥中各個階段轉換、行動執行、傷害造成等事件，並將其格式化為文字記錄。
(2) 日誌顯示：提供一個可滾動的文本區域，讓玩家可以回顧戰鬥過程。

5. BattleUI.cs(戰鬥場景UI總集)：
介紹：集合了戰鬥場景中所有全局性UI按鈕的管理器。
(1) 取消按鈕：在[玩家選擇目標階段]提供取消操作的功能。
(2) 回合結束按鈕：提供一個讓玩家可以隨時結束[玩家規劃階段]並進入下一流程的按鈕。
(3) 清空規劃按鈕：提供一個「重置規劃」的按鈕。點擊後，會通知 BattleUIManager 觸發「清空所有玩家規劃」的事件。
(4) 返回按鈕：回到上一個行動。(如：[前衛]選擇行動「攻擊」-> 選擇目標時「返回」-> 選擇行動「防禦」；選擇遠程 [遠1] -> [遠1]選擇行動時「返回」 -> 選擇遠程 [遠2])
(5) 指揮官技能按鈕：[指揮官技能]可以由[後勤]發動，一場戰鬥只能使用一次。(未實作)
(6) 系統按鈕：戰鬥系統專用UI，可以開啟系統功能。(未實作)
(7) 人物按鈕：顯示人物訊息UI。(未實作)

---

**Manager (管理器)**
1. TurnManager.cs(回合、邏輯管理器)：
介紹：戰鬥流程的核心控制器，使用狀態機來驅動整個戰鬥的節奏與階段轉換。
(1) 管理戰鬥的宏觀流程：依序切換並管理 `[玩家規劃階段]`, `[敵人回合]`, `[行動執行階段]` 等戰鬥狀態。
(1.5) 核心依賴：TurnManager 必須持有一個對 BattlefieldStateSimulator 實例的引用。
(2) 階段驅動與協調：
*   進入 [玩家規劃階段] 的引導式流程：
    1. 回合初始化：
    * 命令 BattleLog 顯示「玩家規劃階段」開始。
    * 命令 CharacterStateRule 執行所有單位體力回滿的邏輯。
    * 命令 BattlefieldStateSimulator 根據 CharacterStateRule 提供的快照，建立初始的「預覽狀態」副本。
    * 命令 BattleUIManager 顯示戰術規劃相關的UI（如 ActionPanelUI, ActionSlotPanelUI），並重置UI狀態。
    2. 啟動引導式規劃：TurnManager 內部維護一個「規劃進度」（[前衛]Phase 1 -> [遠程]Phase 1 -> ......[遠程]Phase 4）。
    * 判定規劃單位：根據當前的「規劃進度」（例如輪到[遠程]Phase 2），TurnManager 向 BattleRules 查詢：「此步驟應由哪個單位規劃？」
    * 處理自動跳過：如果 BattleRules 回應沒有符合資格的單位（例如所有[遠程]單位已行動2次），TurnManager 將自動跳過此步驟，並立即推進到下一個「規劃進度」。
    * 引導玩家操作：如果有合法的規劃單位，TurnManager 會命令 BattleUIManager 顯示當前規劃行動格和對應行動單位，並顯示該單位的專屬行動按鈕。
    * TurnManager 等待玩家做出選擇（選擇行動、跳過、或取消其他行動格），並根據收到的指令執行相應的邏輯（如進入目標選擇、記錄行動方案、推進規劃進度等）。
*   進入 [敵人回合]： 
    * 命令 BattleLog 顯示「敵人回合」開始。
    * 調用 EnemyBattleAI 的接口，命令其為所有敵方單位規劃本回合的行動。
    * 等待 EnemyBattleAI 完成規劃後，自動轉換至下一階段。
*   進入 [行動執行階段]：
    *   **介紹**：此階段的核心是按照一個固定的、交錯的順序，來執行雙方已經規劃好的行動。
    *   命令 BattleLog 顯示「行動執行階段」開始。
    *   執行迴圈：TurnManager 將嚴格遵循「玩家前衛 -> 敵人前衛 -> 玩家遠程 -> 敵人遠程」的順序，從階段1到階段4依序執行所有已規劃的行動。
    *   在**每一個單一行動**執行完畢後，都會立即向 `BattleRules` 查詢戰鬥是否已滿足勝利或失敗條件。若滿足，則立刻中斷執行迴圈，進入戰鬥結算。
    *   如果某個順位的行動不存在（例如該方沒有遠程單位，或沒有在該階段規劃行動），則直接跳過，執行下一個順位的行動。
    *   當 4 個行動階段全部執行完畢後，轉換至下一個[玩家規劃階段]。
(3) 引導式規劃下的玩家輸入處理：
A.  輪到[前衛]規劃時 (由TurnManager根據「規劃進度」觸發)：
    1.  `TurnManager` 命令 `BattleUIManager` 顯示[前衛]的專屬行動按鈕。
    2.  `BattleUIManager` 回報「玩家為[前衛]選擇了『攻擊』行動」。
    3.  `TurnManager` 進入[玩家選擇目標階段]，向 `BattleRules` 查詢合法目標並命令UI高亮。
    4.  `BattleUIManager` 回報「玩家選擇了目標B」。
    5.  `TurnManager` 已集齊所有資訊（發起者、行動、目標、以及當前的階段索引），創建 `ActionPlan`。
        a.  將新創建的 `ActionPlan` 存入 `TurnActionPlanner`。
        b.  立即將這個新的 `ActionPlan` 傳遞給 `BattlefieldStateSimulator`，並命令其 SimulateAction(newPlan)。
        c.  `BattlefieldStateSimulator` 執行模擬，並更新戰場上所有單位的視覺預演。
    6.  `TurnManager` 推進「規劃進度」到下一步。
B.  輪到[遠程]規劃時 (由TurnManager根據「規劃進度」觸發)：
    1.  `TurnManager` 向 `BattleRules` 查詢「此階段有哪些[遠程]單位符合資格行動？」。
    2.  情況一：只有一個單位符合資格 (`BattleRules` 返回 [遠1])。
        *   `TurnManager` 直接將[遠1]定為行動發起者，並跳至第 4 步。
    3.  情況二：有多個單位符合資格 (`BattleRules` 返回 [遠1], [遠2])。
        *   `TurnManager` 命令 `BattleUIManager` 高亮顯示[遠1]和[遠2]，提示玩家必須從中選擇一個。
        *   `BattleUIManager` 回報「玩家選擇了[遠1]作為行動發起者」。
    4.  後續流程 (與[前衛]類似)：
        *   TurnManager 命令 BattleUIManager 顯示所選遠程單位([遠1])的專屬行動按鈕。
        *   後續流程與上方 A 的 2-6 步完全相同，直至推進到下一個「規劃進度」。
C.  玩家的通用操作：
*   取消單個行動 (點擊「取消」按鈕)：
    1.  `BattleUIManager` 回報「請求取消行動格3的行動」。
    2.  `TurnManager` 從 `TurnActionPlanner` 移除對應的 `ActionPlan`，並命令 `BattleUnit` 返還資源。
    3.  `TurnManager` 命令 `BattlefieldStateSimulator` 執行 ResetAndReplayAll(remainingPlans)。模擬器會先將所有單位視覺恢復原狀，然後根據剩餘的計劃列表，快速地、一步一步地重新演算並呈現出最新的預覽結果。
    4.  `TurnManager` 命令 `BattleUIManager` 更新UI。
*   清空所有規劃 (點擊「清空規劃」按鈕)：
    1.  `BattleUIManager` 回報「請求清空所有玩家規劃」。
    2.  `TurnManager` 命令 `TurnActionPlanner` 移除所有玩家方的 `ActionPlan`。
    3.  `TurnManager` 命令 `BattlefieldStateSimulator` 執行完全重置，將所有單位的視覺恢復到回合開始時的狀態。
    4.  `TurnManager` 將「規劃進度」重置回起點，並命令 `BattleUIManager` 更新整個UI。
*   返回上一個流程 (點擊「返回」按鈕)：
    1.  `BattleUIManager` 回報「請求返回到上一個行動」。
    2.  情況一：如果當前處於 (正在選擇目標)
        *   含義：玩家不想選目標了，想重新選擇「行動」。
        *   TurnManager 將「操作步驟」的狀態從[正在選擇目標]切換回[正在選擇行動]。
    3.  情況二：如果當前處於 (已經選擇完遠程單位，且正在選擇行動)
        *   含義：玩家想重新選擇遠程單位了。
        *   TurnManager 將「操作步驟」的狀態從[正在選擇行動]切換回[正在選擇遠程單位]。
D.  處理「交換位置」的特殊流程 (玩家點擊了可用的「交換位置」按鈕)：
    1. `BattleUIManager` 回報「角色想要交換位置」。
    2. `TurnManager` 進入「選擇目標」狀態，向 `BattleRules` 查詢合法的交換目標及其類型。
    3. `BattleRules` 返回一個合法的交換目標列表。
    4. `TurnManager` 命令 `BattleUIManager` 高亮顯示所有合法的目標。
    5. `BattleUIManager` 回報玩家選擇了目標單位B，並將其關聯的交換類型 (例如 'PositionSwap') 一併回報。
    6. `TurnManager` 根據A和B的職位，執行對應的 ActionPlan 創建邏輯，並通知 `ActionPlan` 生成 TransactionID：
        *   如果交換類型是(前衛&遠程)：
        a.  創建兩個 ActionPlan（一個給A，一個給B），都標記為「交換位置」，並賦予相同的 TransactionID。
        b.  預扣資源：僅對主動發起者預扣體力。
        c.  將這兩個 ActionPlan 存入 TurnActionPlanner，它們會佔據不同職位的行動格（一個前衛格，一個遠程格）。
        d.  立即將這些新創建的 ActionPlan 逐一傳遞給 BattlefieldStateSimulator 進行模擬，從而實現交換位置的即時視覺預演。
        e.  推進規劃進度：TurnManager 推進到下一個「規劃進度」。
        *   如果交換類型是(遠程&遠程)：
        a.  創建一個 ActionPlan，發起者是A，行動類型是「交換位置」，目標是B，並賦予 TransactionID。
        b.  預扣資源：僅對主動發起者預扣體力。
        c.  將這個單一的 ActionPlan 存入 TurnActionPlanner，它只會佔據一個遠程行動格。
        d.  立即將這些新創建的 ActionPlan 逐一傳遞給 BattlefieldStateSimulator 進行模擬，從而實現交換位置的即時視覺預演。
        e.  推進規劃進度：TurnManager 推進到下一個「規劃進度」。
(4) 勝負流程終結：
*   當從 `BattleRules` 得知勝利或失敗條件已達成時，立即中斷當前流程。
*   進入 `[戰鬥勝利]` 或 `[戰鬥失敗]` 狀態。
*   命令 `BattleLog` 顯示對應的結果。
*   命令 `BattleUIManager` 顯示 `BattleEndUI` 的勝利或失敗面板，結束戰鬥循環。

2. BattleManager.cs(戰鬥場景總控制器。)：
介紹：負責整個戰鬥場景的初始化設置與資源管理。
(1) 數據載入：戰鬥開始時，讀取玩家隊伍數據與傳入的 `BattleEncounterSO` 敵人數據。
(2) 忠實的單位實例化與定位：
*   根據讀取的隊伍數據，**僅實例化當前隊伍中實際存在的成員**。
*   在實例化每個 BattleUnit 後，必須根據其職責為其 CurrentPosition 屬性賦予初始值。
(3) 數據分發：將生成的、**可能不完整的**單位列表 (`playerUnits`, `enemyUnits`) 提供給 `TurnManager` 和 `BattleRules` 等模組。
(4) 戰鬥結束處理：處理戰鬥結束後的獎勵發放與場景切換信號。

3. BattleUIManager.cs(系統協調)：
介紹：專職處理所有戰鬥UI顯示邏輯與玩家輸入傳遞的中介者。
(1) UI狀態同步：監聽 `TurnManager` 的狀態變更，並據此顯示、隱藏或更新對應的UI面板。
(2) 輸入中繼：接收來自各UI元件的點擊事件(如 `HealthUI`, `ActionPanelUI`, `ActionSlotPanelUI`, `BattleEndUI`, `BattleLog`)，將其打包成意圖明確的事件後，通知 `TurnManager`。
(3) 視覺反饋協調：根據 `TurnManager` 的指令，調用 `BattleUnit` 的接口來顯示目標選擇等視覺提示。

4. GameManager.cs(遊戲狀態管理器)：
介紹：遊戲最高層級的管理者，負責控制場景切換與跨場景的數據傳遞。
(1) 場景管理：執行戰鬥場景與非戰鬥場景之間的切換。
(2) 數據傳遞：接收 `BattleTrigger` 的戰鬥請求，並將 `BattleEncounterSO` 安全地傳遞給新場景的 `BattleManager`。

---

**戰鬥邏輯**
1. BattleRules.cs (戰鬥法典)：
介紹：作為戰鬥的「規則資料庫」與「仲裁者」，`BattleRules` 是一個被動的邏輯集合。它不主動發起任何行為，只負責儲存所有硬性規定，並精確地回答 `TurnManager` 提出的關於「是否可以做某事」的查詢。
(1) 行動資格與順位判定：
*   提供一個核心查詢方法，供 TurnManager 在「引導式規劃」的每一步調用。
*   接收一個「規劃步驟」（例如[遠程]Phase 2）作為參數，根據內部規則（如角色是否存在、剩餘行動次數、遠程衝突規則），準確地返回當前步驟應該由哪一個具體單位 (BattleUnit) 來規劃。如果沒有任何單位符合資格，則返回「無」。
*   遠程衝突規則：此規則僅在**玩家隊伍中同時存在 [遠1] 和 [遠2] 單位時**才觸發。規則為：「在遠程階段時，玩家選擇一名[遠程]單位規劃行動」。
(2) 目標合法性與指令失效規則：
*   提供一個核心方法，接收「行動發起者」與「行動類型」，返回一個「合法的目標列表」。
*   唯一目標規則：定義「不論敵我，所有『攻擊』行動的目標只能是敵方隊伍的[前衛]單位」。
*   攻擊距離規則：在判定目標合法性時，此方法會執行以下檢查：
    * 獲取攻擊者 (attacker) 和選擇目標 (target) 的位置，並計算 distance。
    * 判定：只有當 distance <= attacker.AttackRange 時，該目標才滿足距離要求。
    * 綜合判定：目標必須同時滿足「唯一目標規則」和「攻擊距離規則」，才會被加入最終的「合法目標列表」。如果列表為空，TurnManager 會據此將對應的「攻擊」按鈕設為灰色。
(3) 資源與狀態查詢：
*   提供一系列查詢方法，供 `TurnManager` 獲取行動相關的數據。
*   行動消耗查詢：提供方法，告知特定行動需要消耗多少體力或其他資源。
*   行動次數查詢：提供方法，查詢特定角色是否因「行動次數耗盡」而無法再行動。此查詢結果主要用於 `BattleUIManager` 將對應的行動按鈕變為灰色。
(4) 勝利與失敗條件判定：
*   定義單位陣亡後應觸發的連鎖反應規則。
    *   勝利條件：檢查 `BattleManager` 提供的敵方單位列表 (`enemyUnits`) 是否所有成員都已陣亡。
    *   失敗條件：檢查 `BattleManager` 提供的我方單位列表 (`playerUnits`) 是否所有成員都已陣亡。
(5) 單位陣亡後續處理規則：
*   定義單位陣亡後應觸發的連鎖反應規則。
*   位置替補規則：定義單位陣亡後，後排單位自動向前替補的詳細順序
    * 「[前衛]陣亡，[遠1]替補」
    * 「[遠1]無人，[遠2]替補」
    * 「[前衛]、[遠1]、[遠2]陣亡，[後勤]替補[前衛]位置」
*   行動刪除規則：定義當一個單位陣亡時，應通知 `TurnActionPlanner` 將其所有尚未執行的後續行動從規劃中移除。
(6) 特殊技能使用規則：
*   指揮官技能：記錄[指揮官技能]在本場戰鬥中是否已被使用。提供一個方法供 `TurnManager` 查詢，以決定是否顯示[指揮官技能]按鈕。

2. BattleActions.cs(行動邏輯)：
介紹：包含所有具體行動（如攻擊、防禦）實現邏輯的執行者。
**前言：職責明確化**：此模組的職責不參與任何預演邏輯。它只在[行動執行階段]被調用，負責在**「實際核心數據」**上執行已鎖定的、最終的 ActionPlan。這種分離確保了預演系統的複雜性不會污染核心的戰鬥執行邏輯。
(1) 執行行動：接收 `TurnManager` 的命令和一個 `ActionPlan`，並根據 `ActionPlan` 的內容執行具體的遊戲邏輯，如對目標造成傷害、為自身附加狀態等。
(2) 定義行動效果：
* 攻擊：消耗 3點 體力對敵人造成傷害。
* 防禦：該行動格受到傷害減半。
* 技能：(尚未設計)
* 道具：(尚未設計)
* 交換位置：接收到一個帶有 `TransactionID` 的「交換位置」`ActionPlan`。
    1. 交易驗證：
        * 查詢 `TurnActionPlanner`，獲取擁有相同 `TransactionID` 的所有 `ActionPlan` 及其參與者。
        * 檢查所有參與者是否依然存活。
    2. 執行邏輯(只在第一個關聯行動被調用時執行一次)：
        * 如果所有參與者都存活 (交易成功)：
        a.  據 `ActionPlan` 中的數據，執行實際的位置交換 (`unitA.CurrentPosition <=> unitB.CurrentPosition`)。
        b.  播放交換動畫。(未設計)
        * 如果任何參與者已陣亡 (交易失敗)：
        a.  執行「指令失效規則」，將本次行動的效果動態地替換為「休息」。
    3. [後勤]無法進行交換。
* 跳過：此方法為空，不執行任何操作。
(3) 指令失效規則：
*   備註：此規則的最終執行由 BattleActions 模組在**[行動執行階段]，根據實際核心數據**進行判斷和處理。
    1.  一般攻擊失效：
        * 若「攻擊」行動發起者是 [前衛]，其「攻擊」行動將被轉換為 「防禦」(其他行動不變)。
        * 若「攻擊」行動發起者是 [遠程]，其「攻擊」行動將被轉換為 「休息」(其他行動不變)。
    2.  關聯行動失效：
        * 如果一個關聯行動（由 TransactionID 標記）中的任何一個參與者在執行前已經陣亡，則整個「關聯行動」失敗。
        * 若是「交換位置」失效，失效方的行動改為「休息」。
    *   **備註**：此規則的最終執行由 `BattleActions` 模組在執行具體行動前進行判斷和處理。

3. TurnActionPlanner.cs(回合行動規劃器)：
介紹：負責記錄與管理**玩家與敵人雙方**在[玩家規劃階段]與[敵人回合]所安排的所有行動。
功能：
(1) 統一儲存：提供一個 `List<ActionPlan>` ，用於儲存本回合**雙方**所有已規劃的行動。
(2) 精確提供行動：提供一個查詢方法，能根據 `TurnManager` 傳入的「階段索引」、「陣營(玩家/敵人)」、「角色職責(前衛/遠程)」等參數，精準地返回對應的 `ActionPlan`。
(3) 計數查詢：提供方法以計算某個 `BattleUnit` 已規劃的行動數量，供 `BattleRules` 判斷行動次數是否耗盡。

4. CharacterStateRule.cs：
介紹：管理戰鬥中角色在特定時間點的狀態變化規則。
(1) 狀態儲存：UnitStateSnapshot 現在是整個「戰術沙盤」的絕對基準點。BattlefieldStateSimulator 在每次需要重置時，都會依賴此模組提供的初始狀態快照來建立最開始的「預覽狀態」。
(2) 體力恢復：提供一個方法，用於在[玩家規劃階段]開始時，將所有存活單位的體力恢復至全滿。此方法由 `TurnManager` 調用。
(**未來會再增加**)

5. EnemyBattleAI.cs(敵人進攻邏輯)：
介紹：負責在[敵人回合]為敵方單位規劃行動。
(1) 規劃行動：在[敵人回合]被 `TurnManager` 調用時，為所有敵方單位生成 `ActionPlan`，並將其添加到 `TurnActionPlanner` 中。AI需要遵循與玩家類似的規則（如前衛每階段行動、遠程行動分配等）。
(2) 每個行動格都使用攻擊行動，若體力耗盡，使用防禦。
(**未來再修改**)

6. BattlefieldStateSimulator.cs(戰場狀態模擬器)：
介紹：這是實現「戰鬥預演」功能的核心模組，一個獨立的「沙盤引擎」。它的職責是在不影響「實際戰鬥狀態」的前提下，計算並呈現玩家每一個規劃所產生的即時後果。
(1) 狀態管理：內部維護一個「預覽狀態」的數據副本 (List<UnitPreviewState>)，包含所有單位的預覽位置、預覽體力等。
(2) 接收指令：提供接口 SimulateAction(ActionPlan plan)，接收來自 TurnManager 的單個行動計劃。
(3) 模擬演算：根據接收到的 ActionPlan，更新其內部的「預覽狀態」。例如，收到「交換位置」的計劃，它會更新兩個單位在「預覽狀態」中的位置數據和體力數據。
(4) 驅動視覺：根據更新後的「預覽狀態」，命令相關的 BattleUnit 只更新其視覺表現（如移動模型、顯示預扣的體力條），而不改變其底層的核心數據。
(5) 重製與重算：提供接口 ResetAndReplayAll(List<ActionPlan> allPlayerPlans)，用於在玩家取消或修改行動時，從回合開始的「實際狀態」開始，重新演算並呈現整個預覽結果。












### **完整代碼**

### 第 一 部分：玩家、輸入模組、互動模組

#### 1.1. `Player.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// 確保 Player 物件上永遠有 Rigidbody2D 和 Collider2D 元件
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(Collider2D))]
public class Player : MonoBehaviour
{
    [Header("移動設定")]
    [SerializeField] private float moveSpeed = 5f;

    private Rigidbody2D rb;
    private Vector2 moveInput;

    // 分開管理物品和可互動物件
    private List<GroundItem> nearbyItems = new List<GroundItem>();
    private List<IInteractable> nearbyInteractables = new List<IInteractable>();

    [Header("隊伍初始設定")]
    [Tooltip("將定義玩家初始持有成員的 PartyDatabase 掛載於此。")]
    [SerializeField] private PartyDatabase initialMemberDatabase;
    private bool hasInitializedParty = false;

    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    void Start()
    {
        // 遊戲開始時，如果玩家沒有任何成員，則給予初始隊伍
        InitializeStartingParty();
    }

    void Update()
    {
        // 讀取玩家的移動輸入
        moveInput.x = Input.GetAxisRaw("Horizontal");
        moveInput.y = Input.GetAxisRaw("Vertical");

        if (moveInput.magnitude > 1)
        {
            moveInput.Normalize();
        }
    }

    void FixedUpdate()
    {
        // 在物理更新中移動角色
        rb.MovePosition(rb.position + moveInput * moveSpeed * Time.fixedDeltaTime);
    }
    
    // 這個 OnTriggerEnter2D 是關鍵。當 Player 的 Collider 進入另一個設為 "Trigger" 的 Collider 時，
    // Unity 會自動呼叫這個函式。BattleTrigger 就是利用這個機制來偵測玩家。
    // Player.cs 自身不需要寫偵測 BattleTrigger 的程式碼。
    private void OnTriggerEnter2D(Collider2D other)
    {
        // 物品偵測
        GroundItem item = other.GetComponent<GroundItem>();
        if (item != null && !nearbyItems.Contains(item))
        {
            nearbyItems.Add(item);
        }

        // 互動物件偵測
        IInteractable interactable = other.GetComponent<IInteractable>();
        if (interactable != null && !nearbyInteractables.Contains(interactable))
        {
            nearbyInteractables.Add(interactable);
            Debug.Log($"[Player] 進入可互動物件 '{other.gameObject.name}' 的範圍。");
        }
        
        // 注意：與 BattleTrigger 的互動邏輯寫在 BattleTrigger.cs 裡，而不是這裡。
        // 這樣可以保持 Player 腳本的乾淨，並且讓觸發器自己管理自己的邏輯。
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        GroundItem item = other.GetComponent<GroundItem>();
        if (item != null)
        {
            nearbyItems.Remove(item);
        }
        
        IInteractable interactable = other.GetComponent<IInteractable>();
        if (interactable != null)
        {
            nearbyInteractables.Remove(interactable);
            Debug.Log($"[Player] 離開可互動物件 '{other.gameObject.name}' 的範圍。");
        }
    }

    public void TryPickupItem()
    {
        nearbyItems.RemoveAll(item => item == null);
        if (nearbyItems.Count == 0) return;

        GroundItem closestItem = nearbyItems.OrderBy(item => 
            Vector2.Distance(transform.position, item.transform.position)
        ).FirstOrDefault();

        closestItem?.AttemptPickup();
    }
    
    public void TryInteract()
    {
        nearbyInteractables.RemoveAll(i => i == null || (i as MonoBehaviour) == null);
        
        if (nearbyInteractables.Count == 0)
        {
             Debug.Log("[Player] 附近沒有可互動的物件。");
            return;
        }

        IInteractable closestInteractable = nearbyInteractables.OrderBy(i => 
            Vector2.Distance(transform.position, (i as MonoBehaviour).transform.position)
        ).FirstOrDefault();
        
        if (closestInteractable != null)
        {
            closestInteractable.Interact();
        }
    }

    private void InitializeStartingParty()
    {
        if (hasInitializedParty || PartyManager.Instance == null) return;

        if (initialMemberDatabase == null || initialMemberDatabase.allMembers == null)
        {
            Debug.LogWarning("Player 物件上未指定初始成員資料庫，不新增任何初始成員。");
            return;
        }
        
        if (PartyManager.Instance.AllMembers.Count > 0)
        {
            Debug.Log("偵測到玩家已有成員(可能為讀檔)，跳過初始成員新增程序。");
            hasInitializedParty = true;
            return;
        }

        Debug.Log("正在根據 Player 物件上的設定初始化玩家隊伍...");
        foreach (var memberData in initialMemberDatabase.allMembers)
        {
            if (memberData != null)
            {
                PartyManager.Instance.AddMemberToHolder(memberData.memberID);
            }
        }
        
        // 假設初始隊伍的前幾位直接進入戰鬥隊伍
        var initialBattleParty = PartyManager.Instance.AllMembers.Take(4).ToList(); // 取前4位
        foreach (var member in initialBattleParty)
        {
            PartyManager.Instance.SetToBattleParty(member);
        }

        hasInitializedParty = true;
    }
}
```

#### 1.2. `PlayerState.cs`
```csharp
using UnityEngine;

public class PlayerState : MonoBehaviour
{
    [Header("玩家狀態")]
    [Tooltip("玩家目前擁有的金錢數量")]
    public int money = 0;

    // 未來可以增加更多狀態，例如：
    // public int level;
    // public float experience;

    // 這個腳本主要作為數據容器。
    // 背包數據由 InventoryManager 和 Inventory (ScriptableObject) 管理，
    // 所以這裡不需要直接引用背包。其他系統可以透過 FindObjectOfType<PlayerState>() 來存取玩家的金錢。

    public void AddMoney(int amount)
    {
        if (amount > 0)
        {
            money += amount;
            Debug.Log($"[PlayerState] 獲得金錢：{amount}。目前總額：{money}");
        }
    }

    public bool SpendMoney(int amount)
    {
        if (amount > 0 && money >= amount)
        {
            money -= amount;
            Debug.Log($"[PlayerState] 花費金錢：{amount}。目前餘額：{money}");
            return true;
        }
        else
        {
            Debug.LogWarning($"[PlayerState] 金錢不足！需要 {amount}, 但只有 {money}。");
            return false;
        }
    }
}
```

#### 1.3. `KeyManager.cs`
```csharp
using UnityEngine;

public clas
s KeyManager : MonoBehaviour
{
    // 對玩家控制器的引用，用於執行拾取等動作
    private Player playerController;
    
    
    [Header("UI 面板引用 (可選)")]
    [SerializeField] private QuestUI questUI;
    [SerializeField] private PartyHolderUI partyHolderUI;
    [SerializeField] private PartyBattleUI partyBattleUI;
    // UI 面板的引用 (未來實作)
    // public GameObject mapPanel;
    // public GameObject systemMenuPanel;

    void Start()
    {
        playerController = FindObjectOfType<Player>();
        if (playerController == null)
        {
            Debug.LogError("[KeyManager] 找不到 Player 物件！");
        }
    }

    void Update()
    {
        // 持續偵測按鍵輸入

        // E鍵：對話
        if (Input.GetKeyDown(KeyCode.E))
        {
            HandleInteraction();
        }

        // I鍵：開啟/關閉背包
        if (Input.GetKeyDown(KeyCode.I))
        {
            InventoryManager.Instance.ToggleInventoryUI();
        }

        // 空白鍵：拾取物品
        if (Input.GetKeyDown(KeyCode.Space))
        {
            HandlePickup();
        }

        // Q鍵：開啟/關閉任務面板
        if (Input.GetKeyDown(KeyCode.Q))
        {
            if (questUI != null)
            {
                questUI.TogglePanel();
            }
            else
            {
                Debug.Log("[KeyManager] 按下 Q 鍵：(QuestUI 未指定)");
            }
        }

        // P鍵：開啟/關閉隊伍倉庫面板
        if (Input.GetKeyDown(KeyCode.P))
        {
            if (partyHolderUI != null)
            {
                partyHolderUI.TogglePanel();
            }
            else
            {
                Debug.LogWarning("[KeyManager] PartyHolderUI 未在 Inspector 中指定！");
            }
        }

        // B鍵：開啟/關閉戰鬥隊伍面板
        if (Input.GetKeyDown(KeyCode.B))
        {
            if (partyBattleUI != null)
            {
                partyBattleUI.TogglePanel();
            }
            else
            {
                Debug.LogWarning("[KeyManager] PartyBattleUI 未在 Inspector 中指定！");
            }
        }

        // M鍵：開啟/關閉地圖 (未來實作)
        if (Input.GetKeyDown(KeyCode.M))
        {
            Debug.Log("[KeyManager] 按下 M 鍵：(地圖功能尚未實作)");
            // if (mapPanel != null) mapPanel.SetActive(!mapPanel.activeSelf);
        }

        // ESC鍵：關閉最上層面板或開啟系統選單
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            HandleEscapeKey();
        }
    }

    private void HandleInteraction()
    {
        // 讓玩家控制器處理尋找最近的NPC
        if (playerController != null)
        {
            playerController.TryInteract();
        }
    }

    private void HandlePickup()
    {
        if (playerController != null)
        {
            playerController.TryPickupItem();
        }
    }

    private void HandleEscapeKey()
    {
        bool anyPanelWasClosed = false;

        // 優先關閉對話框 (因為它通常在最上層)
        if (DialogueManager.Instance != null && DialogueManager.Instance.isActiveAndEnabled)
        {
            // 這部分需要 DialogueManager 提供一個 IsDialogueActive 的屬性
            // 暫時先這樣處理，或者讓ESC關閉對話的功能直接寫在 DialogueManager 裡
        }
        
        // 檢查背包UI
        if (InventoryManager.Instance.playerInventoryUI != null && 
            InventoryManager.Instance.playerInventoryUI.gameObject.activeInHierarchy)
        {
            InventoryManager.Instance.CloseInventoryUI();
            anyPanelWasClosed = true;
        }
        // 檢查任務UI
        else if (questUI != null && questUI.gameObject.activeInHierarchy)
        {
            questUI.TogglePanel(); // 使用 Toggle 比較方便
            anyPanelWasClosed = true;
        }

        // 檢查隊伍倉庫UI
        else if (partyHolderUI != null && partyHolderUI.gameObject.activeInHierarchy)
        {
            partyHolderUI.TogglePanel();
            anyPanelWasClosed = true;
        }
        // 檢查戰鬥隊伍UI
        else if (partyBattleUI != null && partyBattleUI.gameObject.activeInHierarchy)
        {
            partyBattleUI.TogglePanel();
            anyPanelWasClosed = true;
        }
        
        if (!anyPanelWasClosed)
        {
            Debug.Log("[KeyManager] 按下 ESC：(開啟系統面板功能尚未實作)");
        }
    }
}
```

#### 1.4. `IInteractable.cs`
```csharp
// 讓 Player.cs 可以偵測到此物件並與之互動
public interface IInteractable
{
    void Interact();
}
```

#### 1.5. `NPC.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[RequireComponent(typeof(Collider2D))]
public class NPC : MonoBehaviour, IInteractable
{
    [Header("NPC 資訊")]
    [Tooltip("唯一的 NPC ID，用於任務和對話系統的內部識別")]
    [SerializeField] private string npcID;
    
    [Header("任務設定")]
    [Tooltip("此 NPC 提供的所有任務 ID 列表")]
    [SerializeField] private List<string> availableQuestIDs = new List<string>();

    [Header("對話設定")]
    [Tooltip("此 NPC 的主要對話檔案路徑，相對於 'Resources/GameData/Dialogues/'。例如: 'NPCs/npc_mayor'")]
    [SerializeField] private string dialogueFileName;

    [Tooltip("與此 NPC 互動時的入口對話 ID")]
    [SerializeField] private string mainDialogueID;

    //[Header("功能設定")]
    //[Tooltip("此 NPC 是否為商人")]
    //[SerializeField] private bool isTrader = false;

    private void OnValidate()
    {
        // 確保此物件上的 Collider2D 是觸發器
        Collider2D col = GetComponent<Collider2D>();
        if (col != null && !col.isTrigger)
        {
            col.isTrigger = true;
        }
    }

    public string GetNpcID() => npcID;
    public List<string> GetQuestList() => availableQuestIDs;

    // 實現 IInteractable 接口，此方法由 Player 透過 E 鍵呼叫
    public void Interact()
    {
        Debug.Log($"[NPC] 與 {gameObject.name} (ID: {npcID}) 互動。");

        if (string.IsNullOrEmpty(dialogueFileName) || string.IsNullOrEmpty(mainDialogueID))
        {
            Debug.LogWarning($"[NPC] {gameObject.name} 未設定 dialogueFileName 或 mainDialogueID。");
            return;
        }

        QuestManager.Instance.SyncCollectionQuests();
        DialogueManager.Instance.StartDialogue(dialogueFileName, mainDialogueID, npcID);
    }
}
```

#### 1.6. `DialogueTrigger.cs`
```csharp
using UnityEngine;

public class DialogueTrigger : MonoBehaviour, IInteractable
{
    [Header("對話設定")]
    [Tooltip("此對話所在的 XML 檔案名稱 (不需要輸入 .xml 副檔名)")]
    [SerializeField] private string dialogueFileName;

    [Tooltip("要觸發的對話 ID (對應 XML 檔案中的 <Dialogue> 標籤的 id)")]
    [SerializeField] private string dialogueID;

    // 實現 IInteractable 接口，此方法由 Player 透過 E 鍵呼叫
    public void Interact()
    {
        if (string.IsNullOrEmpty(dialogueFileName) || string.IsNullOrEmpty(dialogueID))
        {
            Debug.LogWarning($"[DialogueTrigger] {gameObject.name} 未在 Inspector 中設定 dialogueFileName 或 dialogueID。");
            return;
        }
        
        Debug.Log($"[DialogueTrigger] 觸發對話: 檔案 '{dialogueFileName}', ID '{dialogueID}'");
        
        // 呼叫 DialogueManager，傳入檔案名和對話ID
        DialogueManager.Instance.StartDialogue(dialogueFileName, dialogueID);
    }
}
```

#### 1.7. `BattleTrigger.cs`
```csharp
using UnityEngine;

public class BattleTrigger : MonoBehaviour
{
    [SerializeField] private BattleEncounterSO battleEncounter;

    private void OnTriggerEnter(Collider other)
    {
        // 假設玩家物件帶有 "Player" 標籤
        if (other.CompareTag("Player"))
        {
            // 禁用觸發器避免重複觸發
            GetComponent<Collider>().enabled = false;
            
            // 通知 GameManager 啟動戰鬥
            GameManager.Instance.StartBattle(battleEncounter);
        }
    }
}
```
