#### ** 遊戲世界模組 (Game World Module)**

交易輔助系統已經有將 1、2 寫上去了

1. `GameEventManager.cs`:
    (1) 遊戲事件管理器。

2. `WorldTimeSystem.cs`:
    (1) 遊戲時間。

3. `GameManager.cs`:
    (1) 場景管理。
    
---

#### 事件系統

1. GameEventListener.cs：
(1) 監聽事件ID，響應事件動作。

2. QuestStateListener.cs：
(1) 監聽任務ID，響應事件動作。

---

### 總腳本

#### 1. `GameEventManager.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System;

public class GameEventManager : MonoBehaviour
{
    public static GameEventManager Instance { get; private set; }

    private HashSet<string> triggeredEvents = new HashSet<string>();
    
    public static event Action<string> OnEventTriggered;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    public void TriggerEvent(string eventID)
    {
        if (string.IsNullOrEmpty(eventID)) return;

        if (triggeredEvents.Add(eventID))
        {
            Debug.Log($"[GameEventManager] 遊戲事件觸發: {eventID}");
            OnEventTriggered?.Invoke(eventID);
        }
    }

    public bool HasEventBeenTriggered(string eventID)
    {
        if (string.IsNullOrEmpty(eventID)) return false;
        return triggeredEvents.Contains(eventID);
    }

    public HashSet<string> GetTriggeredEvents() => triggeredEvents;
    public void LoadTriggeredEvents(HashSet<string> events) => triggeredEvents = events;
}
```

#### 2. `GameManager.cs`
```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Linq;
using System.Collections.Generic;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    
    public BattleEncounterSO CurrentEncounter { get; private set; }
    
    [Header("場景名稱設定")]
    [SerializeField] private string mainSceneName = "Title";
    [SerializeField] private string battleSceneName = "BattleScene";

    [Header("場景管理UI")]
    [Tooltip("請將您場景中的讀取畫面 UI 物件拖曳至此")]
    [SerializeField] private GameObject loadingScreen; 

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
        else
        {
            Debug.LogError("[GameManager] 未在 Inspector 中指定 LoadingScreen 物件！非同步載入功能可能無法正確顯示讀取畫面。");
        }
    }

    public void StartBattle(BattleEncounterSO encounter)
    {
        if (encounter == null)
        {
            Debug.LogError("嘗試開始戰鬥，但傳入的 BattleEncounterSO 為空！");
            return;
        }
        StartCoroutine(LoadBattleSceneCoroutine(encounter));
    }

    public void EndBattle()
    {
        StartCoroutine(LoadMainSceneCoroutine());
    }

    private IEnumerator LoadBattleSceneCoroutine(BattleEncounterSO encounter)
    {
        CurrentEncounter = encounter;
        
        // 1. 顯示讀取畫面
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(true);
        }

        // 2. 開始非同步載入目標場景
        // LoadSceneAsync 會在背景線程中載入場景，不會凍結主線程
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(battleSceneName);

        // 3. 迴圈等待，直到場景載入完成
        // asyncLoad.isDone 會在場景載入完成後變為 true
        while (!asyncLoad.isDone)
        {
            // 在此處可以更新進度條 UI
            // 例如: loadingProgressBar.value = asyncLoad.progress;
            yield return null;
        }

        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
    }
    
    private IEnumerator LoadMainSceneCoroutine()
    {
        ProcessBattleResults();
        UpdatePartyStatusAfterBattle();
        CurrentEncounter = null;

        if (loadingScreen != null)
        {
            loadingScreen.SetActive(true);
        }

        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(mainSceneName);

        while (!asyncLoad.isDone)
        {
            yield return null;
        }

        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
    }

    private void UpdatePartyStatusAfterBattle()
    {
        if (BattleManager.Instance == null || PartyManager.Instance == null) return;

        foreach (var unit in BattleManager.Instance.PlayerUnits)
        {
            MemberInstance instanceToUpdate = PartyManager.Instance.AllMembers.FirstOrDefault(
                m => m.instanceID == unit.MemberInstance.instanceID
            );

            if (instanceToUpdate != null)
            {
                instanceToUpdate.currentHP = unit.CurrentHP;
                Debug.Log($"已更新成員 [{instanceToUpdate.BaseData.memberName}] 的血量為: {instanceToUpdate.currentHP}");
            }
        }
    }

    private void ProcessBattleResults()
    {
        if (BattleManager.Instance == null) return;
        if (BattleManager.Instance.IsBattleWon())
        {
            var encounterData = BattleManager.Instance.EncounterData;
            int totalGold = 0;
            // int totalExp = 0;
            foreach(var enemyUnit in BattleManager.Instance.EnemyUnits)
            {
                if(enemyUnit.EnemyData != null)
                {
                    totalGold += enemyUnit.EnemyData.goldDrop;
                    // totalExp += enemyUnit.EnemyData.expDrop;
                }
            }
            if(PlayerState.Instance != null)
            {
                PlayerState.Instance.AddMoney(totalGold);
                // PlayerState.Instance.GainExperience(totalExp);
                Debug.Log($"戰鬥勝利！獲得金幣: {totalGold}");
            }
            if (QuestManager.Instance != null)
            {
                foreach (var enemyUnit in BattleManager.Instance.EnemyUnits)
                {
                    if (enemyUnit.IsDead && enemyUnit.EnemyData != null)
                    {
                        string enemyID = enemyUnit.EnemyData.enemyID;
                        QuestManager.Instance.AdvanceObjective(enemyID, QuestObjectiveType.Kill, 1);
                        Debug.Log($"向任務系統報告擊殺: {enemyID}");
                    }
                }
            }
        }
    }
}
```

#### 3. `WorldTimeSystem.cs`
```csharp
using UnityEngine;
using System;

public class WorldTimeSystem : MonoBehaviour
{
    public static WorldTimeSystem Instance { get; private set; }
    public int CurrentDay { get; private set; } = 1;
    public static event Action<int> OnDayChanged;

    [SerializeField] private float secondsPerDay = 60f;
    private float dayTimer = 0f;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    void Update()
    {
        dayTimer += Time.deltaTime;
        if (dayTimer >= secondsPerDay)
        {
            dayTimer -= secondsPerDay;
            AdvanceDay();
        }
    }

    private void AdvanceDay()
    {
        CurrentDay++;
        Debug.Log($"[WorldTimeSystem] 新的一天開始了！今天是第 {CurrentDay} 天。");
        OnDayChanged?.Invoke(CurrentDay);
    }

    public void PassDays(int days)
    {
        for (int i = 0; i < days; i++)
        {
            AdvanceDay();
        }
    }
}
```

---

1. GameEventListener.cs：
```
using UnityEngine;
using UnityEngine.Events;

public class GameEventListener : MonoBehaviour
{
    [Header("事件監聽設定")]
    [Tooltip("此監聽器要響應的遊戲事件的唯一ID。")]
    [SerializeField] private string eventIDToListenFor;

    [Header("響應動作")]
    [Tooltip("當監聽到對應的事件ID時，要執行的動作。可以在 Inspector 中拖拽組件和選擇方法。")]
    [SerializeField] private UnityEvent onEventTriggered;

    private void OnEnable()
    {
        GameEventManager.OnEventTriggered += HandleEventTriggered;
    }

    private void OnDisable()
    {
        GameEventManager.OnEventTriggered -= HandleEventTriggered;
    }

    private void HandleEventTriggered(string triggeredID)
    {
        if (triggeredID == eventIDToListenFor)
        {
            Debug.Log($"[GameEventListener] 物件 '{gameObject.name}' 監聽到事件 '{triggeredID}'，正在執行響應動作。");
            onEventTriggered.Invoke();
        }
    }
}
```

2. QuestStateListener.cs：
```
using UnityEngine;
using UnityEngine.Events;

public enum QuestListenType { OnAccepted, OnCompleted, IsCompletable }

public class QuestStateListener : MonoBehaviour
{
    [Header("監聽設定")]
    [Tooltip("要監聽的任務的唯一ID。")]
    [SerializeField] private string questIDToListenFor;
    
    [Tooltip("選擇要監聽的任務狀態事件類型。")]
    [SerializeField] private QuestListenType listenType = QuestListenType.OnCompleted;

    [Header("響應動作")]
    [Tooltip("當監聽到任務達到指定狀態時，要執行的動作。")]
    [SerializeField] private UnityEvent onStateMatched;

    private bool hasTriggeredForCompletable = false;

    private void SubscribeToEvents()
    {
        if (QuestManager.Instance == null)
        {
            Debug.LogError($"[QuestStateListener] 在 '{gameObject.name}' 上找不到 QuestManager 實例，無法訂閱事件。請確保場景中有一個 QuestManager。");
            return;
        }

        switch (listenType)
        {
            case QuestListenType.OnAccepted:
                QuestManager.Instance.OnQuestAccepted += HandleQuestStateChange;
                break;
            case QuestListenType.OnCompleted:
                QuestManager.Instance.OnQuestCompleted += HandleQuestStateChange;
                break;
            case QuestListenType.IsCompletable:
                QuestManager.Instance.OnQuestUpdated += HandleQuestStateChange;
                break;
        }
    }

    private void UnsubscribeFromEvents()
    {
        if (QuestManager.Instance == null) return;
        
        switch (listenType)
        {
            case QuestListenType.OnAccepted:
                QuestManager.Instance.OnQuestAccepted -= HandleQuestStateChange;
                break;
            case QuestListenType.OnCompleted:
                QuestManager.Instance.OnQuestCompleted -= HandleQuestStateChange;
                break;
            case QuestListenType.IsCompletable:
                QuestManager.Instance.OnQuestUpdated -= HandleQuestStateChange;
                break;
        }
    }

    void OnEnable()
    {
        StartCoroutine(SubscribeAfterInitialization());
    }

    void OnDisable()
    {
        UnsubscribeFromEvents();
    }
    
    private System.Collections.IEnumerator SubscribeAfterInitialization()
    {
        yield return new WaitUntil(() => QuestManager.Instance != null);
        SubscribeToEvents();
        CheckInitialState();
    }

    private void CheckInitialState()
    {
        if (QuestManager.Instance.GetQuestStatus(questIDToListenFor) == Quest.QuestStatus.InProgress &&
            listenType == QuestListenType.IsCompletable &&
            QuestManager.Instance.IsQuestCompletable(questIDToListenFor))
        {
            HandleQuestStateChange(questIDToListenFor);
        }
    }

    private void HandleQuestStateChange(string changedQuestID)
    {
        if (changedQuestID != questIDToListenFor) return;

        bool shouldTrigger = false;
        switch (listenType)
        {
            case QuestListenType.OnAccepted:
            case QuestListenType.OnCompleted:
                shouldTrigger = true;
                break;
            
            case QuestListenType.IsCompletable:
                if (QuestManager.Instance.IsQuestCompletable(questIDToListenFor) && !hasTriggeredForCompletable)
                {
                    shouldTrigger = true;
                    hasTriggeredForCompletable = true;
                }
                break;
        }

        if (shouldTrigger)
        {
            Debug.Log($"[QuestStateListener] 物件 '{gameObject.name}' 監聽到任務 '{changedQuestID}' 狀態匹配，正在執行響應動作。");
            onStateMatched.Invoke();
        }
    }
}
```