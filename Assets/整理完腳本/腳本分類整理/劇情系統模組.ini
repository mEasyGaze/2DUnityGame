### 劇情系統模組(Story System Module)

1. `StoryAction.cs`：
    (1) 定義一個獨立的劇情動作的數據結構。
    (2) 引入「子劇情 (Sub-Story)」「函式 (Function)」的概念。

2. `StorySceneData.cs`：
    (1) 一個按順序執行的「階段 (Phase)」列表。
    (2) 每階段包含一個動作列表，動作將並行（同時）執行。

3. `StorySceneRunner.cs`(場景組件)：
    (1) 提供一個「角色名單 (Cast List)」。
    (2) 負責接收來自觸發器（如 GameEventListener）的指令。
    (3) 調用 StoryManager 來播放劇情，同時將自己作為上下文(物件引用提供者)傳遞過去。

4. `StoryManager.cs`：
    (1) 過場動畫(由系統幫忙完成角色動作)，接收來自 StorySceneRunner 的播放請求。
    (2) 按順序遍歷 StorySceneData 中的每一個階段，每個階段內，同時啟動所有 StoryAction ，所有動作完成後才進入下一階段。
    (3) 通過向 StorySceneRunner 查詢，獲取穩固的場景物件引用。
    (4) 通過監聽 DialogueManager 等全局事件。

5. StorySceneDataEditor.cs：
    (1) 為 StorySceneData 資產提供一個高度可視化、用戶友好的自定義 Inspector 界面。
    (2) 可折疊的階段和動作列表、根據動作類型智能顯示所需參數、快速添加/刪除/排序按鈕。

#### **劇情系統數據流向**

```mermaid
graph TD
    subgraph "數據配置 (遊戲資產)"
        A[StoryAction: 定義單個動作] --> B[StorySceneData: 編排並行階段與動作序列];
    end

    subgraph "場景綁定與觸發"
        Trigger((觸發源 <br> e.g., GameEventListener)) -- "啟動劇情" --> C[StorySceneRunner];
        B -- "作為劇本掛載" --> C;
        SceneObjects["場景中的物件<br>(主角, NPC等)"] -- "手動拖拽綁定" --> C;
    end

    subgraph "執行與交互"
        C -- "請求播放(傳遞劇本和自身)" --> D[StoryManager];
        D -- "向Runner查詢物件" --> C;
        D -- "導演/執行者" --> E{遊戲世界};
        E -- "控制" --> F[NPC];
        E -- "控制" --> G[主攝影機];
        E -- "控制" --> H[InputManager];
        E -- "觸發" --> I[DialogueManager];
        I -- "OnDialogueEnded事件" --> D;
    end

    style A fill:#D2E9FF,stroke:#333,stroke-width:2px
    style B fill:#D2E9FF,stroke:#333,stroke-width:2px
    style C fill:#FFF5CC,stroke:#333,stroke-width:2px
    style D fill:#FFE6CC,stroke:#333,stroke-width:2px
    style E fill:#E6FFCC,stroke:#333,stroke-width:2px
```

---

### 完整代碼

#### 1. `StoryAction.cs`
```csharp
using UnityEngine;

public enum StoryActionType
{
    // --- 角色與物件控制 ---
    MoveCharacter,      // 移動一個角色到指定位置
    SetCharacterActive, // 設置角色或物件的顯示/隱藏狀態
    SpawnObject,        // 在指定位置生成一個物件 (Prefab)
    DestroyObject,      // 銷毀一個場景中的物件

    // --- 流程與交互控制 ---
    StartDialogue,      // 強制開始一段對話 (通常是無選項的旁白)
    Wait,               // 暫停劇情流程一段時間
    DisableInput,       // 禁用玩家輸入
    EnableInput,        // 恢復玩家輸入
    RunSubStory,        // 執行一個子劇情

    // --- 鏡頭控制 ---
    MoveCameraToTarget, // 將攝影機移動到一個目標物件的位置
    MoveCameraToPosition,// 將攝影機移動到一個具體坐標
    FocusOnCharacter,   // 讓攝影機持續跟隨一個角色
    ReleaseCameraFocus, // 讓攝影機停止跟隨，恢復由玩家控制
    
    // --- 遊戲事件 ---
    TriggerGameEvent    // 觸發一個全局遊戲事件
}

[System.Serializable]
public class StoryAction
{
    [Tooltip("此動作的類型")]
    public StoryActionType actionType;

    [Header("通用參數")]
    [Tooltip("此動作的目標物件名稱 (例如：要移動的角色名、要銷毀的物件名)")]
    public string targetObjectName;

    [Tooltip("用於移動、生成等操作的目標位置")]
    public Vector2 targetPosition;

    [Tooltip("用於 Wait 動作的等待時間 (秒)")]
    public float duration;

    [Tooltip("布林值參數 (例如：SetCharacterActive 的狀態)")]
    public bool boolValue;

    [Header("對話專用參數")]
    [Tooltip("對話所在的 XML 檔案路徑")]
    public string dialogueFilePath;
    [Tooltip("要觸發的對話 ID")]
    public string dialogueID;

    [Header("生成物件專用參數")]
    [Tooltip("要生成的物件 Prefab (需放在 Resources 文件夾下)")]
    public GameObject objectToSpawn;

    [Header("遊戲事件專用參數")]
    [Tooltip("要觸發的 GameEvent 的 ID")]
    public string gameEventID;
    
    [Header("子劇情專用參數")]
    [Tooltip("要作為子劇情執行的 StorySceneData 檔案")]
    public StorySceneData subStoryToRun;
}
```

#### 2. `StorySceneData.cs`
```csharp
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class StoryPhase
{
    [Tooltip("此階段的描述性名稱（僅供編輯器內識別）")]
    public string phaseName = "New Phase";

    [Tooltip("此階段內將會【同時】執行的所有動作")]
    public List<StoryAction> actions = new List<StoryAction>();
}

[CreateAssetMenu(fileName = "NewStoryScene", menuName = "Story/Story Scene Data")]
public class StorySceneData : ScriptableObject
{
    [Header("劇情場景設定")]
    [Tooltip("此劇情場景的唯一ID，用於被其他系統觸發")]
    public string sceneID;

    [Header("劇情階段序列")]
    [Tooltip("按照執行順序排列的劇情階段列表。每個階段內的動作會同時執行。")]
    public List<StoryPhase> phases = new List<StoryPhase>();
}
```

#### 3. `StorySceneRunner.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class SceneActor
{
    [Tooltip("在 StoryAction 中使用的邏輯名稱，例如 '主角', '市長NPC', '城門'")]
    public string logicalName;
    [Tooltip("將場景中對應的 GameObject 拖拽到這裡")]
    public GameObject sceneObject;
}

public class StorySceneRunner : MonoBehaviour
{
    [Header("劇情數據")]
    [Tooltip("將要在此場景中播放的 StorySceneData 腳本資源拖拽於此")]
    [SerializeField] private StorySceneData sceneData;

    [Header("場景角色名單 (Cast List)")]
    [Tooltip("將此劇情中需要用到的所有場景物件在此處進行綁定")]
    [SerializeField] private List<SceneActor> sceneActors = new List<SceneActor>();

    private Dictionary<string, GameObject> actorDictionary;

    void Awake()
    {
        actorDictionary = new Dictionary<string, GameObject>();
        foreach (var actor in sceneActors)
        {
            if (actor.sceneObject == null)
            {
                Debug.LogWarning($"在 '{gameObject.name}' 的角色名單中, 邏輯名稱 '{actor.logicalName}' 沒有綁定任何場景物件！", this);
                continue;
            }
            if (!actorDictionary.ContainsKey(actor.logicalName))
            {
                actorDictionary.Add(actor.logicalName, actor.sceneObject);
            }
            else
            {
                Debug.LogWarning($"在 '{gameObject.name}' 的角色名單中發現重複的邏輯名稱: '{actor.logicalName}'", this);
            }
        }
    }

    public GameObject GetActor(string logicalName)
    {
        if (actorDictionary.TryGetValue(logicalName, out GameObject actorObject))
        {
            return actorObject;
        }

        Debug.LogError($"在 '{gameObject.name}' 的角色名單中找不到邏輯名稱為 '{logicalName}' 的物件！請檢查綁定。", this);
        return null;
    }
    
    public void StartScene()
    {
        if (sceneData == null)
        {
            Debug.LogError($"'{gameObject.name}' 沒有掛載任何 StorySceneData，無法啟動劇情。", this);
            return;
        }
        StoryManager.Instance.StartStoryScene(sceneData, this);
    }
}
```

#### 4. `StoryManager.cs`
```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class StoryManager : MonoBehaviour
{
    public static StoryManager Instance { get; private set; }
    public bool IsStorySceneActive { get; private set; } = false;

    private bool isWaitingForDialogueToEnd = false;
    private Camera mainCamera;
    private Coroutine storyCoroutine;
    private Transform cameraFollowTarget = null;
    private StorySceneRunner currentRunner;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        
        FindMainCamera();
    }

    #region 場景事件監聽與攝影機管理
    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }
    
    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        FindMainCamera();
        Debug.Log($"[StoryManager] 已在新場景 '{scene.name}' 中更新主攝影機引用。");
    }
    
    private void FindMainCamera()
    {
        mainCamera = Camera.main;
        if (mainCamera == null)
        {
            if (Time.timeSinceLevelLoad < 1f) 
            {
                Debug.LogError("[StoryManager] 嚴重錯誤：在初始場景中找不到標籤 (Tag) 為 'MainCamera' 的攝影機！");
            }
            else
            {
                Debug.LogWarning("[StoryManager] 警告：在當前場景中找不到主攝影機。攝影機相關的劇情動作將會失敗。");
            }
        }
    }
    #endregion

    private void LateUpdate()
    {
        if (cameraFollowTarget != null && mainCamera != null)
        {
            mainCamera.transform.position = new Vector3(
                cameraFollowTarget.position.x,
                cameraFollowTarget.position.y,
                mainCamera.transform.position.z
            );
        }
    }

    public void StartStoryScene(StorySceneData sceneData, StorySceneRunner runner)
    {
        if (IsStorySceneActive)
        {
            Debug.LogWarning("一個劇情場景正在播放中，無法啟動新的場景。");
            return;
        }
        if (sceneData == null || runner == null)
        {
            Debug.LogError("嘗試啟動一個空的劇情場景數據或沒有提供 Runner！");
            return;
        }
        if (GameManager.Instance != null)
        {
            GameManager.Instance.SetGameState(GameState.InStoryScene);
        }
        currentRunner = runner;
        IsStorySceneActive = true;
        storyCoroutine = StartCoroutine(StoryPlaybackController(sceneData));
    }

    private IEnumerator ExecuteStoryScene(StorySceneData sceneData)
    {
        Debug.Log($"--- 劇情場景開始: {sceneData.sceneID} ---");
        
        foreach (var phase in sceneData.phases)
        {
            Debug.Log($"-- 進入階段: {phase.phaseName} --");
            
            List<Coroutine> phaseCoroutines = new List<Coroutine>();
            foreach (var action in phase.actions)
            {
                Coroutine actionCoroutine = StartCoroutine(ExecuteAction(action));
                phaseCoroutines.Add(actionCoroutine);
            }

            foreach (var coroutine in phaseCoroutines)
            {
                yield return coroutine;
            }
            Debug.Log($"-- 階段結束: {phase.phaseName} --");
        }
        
        Debug.Log($"--- 劇情場景結束: {sceneData.sceneID} ---");
    }

    private IEnumerator ExecuteAction(StoryAction action)
    {
        bool isCameraAction = action.actionType == StoryActionType.MoveCameraToTarget || 
                              action.actionType == StoryActionType.MoveCameraToPosition || 
                              action.actionType == StoryActionType.FocusOnCharacter || 
                              action.actionType == StoryActionType.ReleaseCameraFocus;
        
        if (isCameraAction && mainCamera == null)
        {
            Debug.LogError($"[StoryManager] 無法執行攝影機動作 '{action.actionType}'，因為主攝影機引用為空。");
            yield break;
        }

        GameObject targetObject = null;
        if (!string.IsNullOrEmpty(action.targetObjectName))
        {
            if (currentRunner != null)
            {
                targetObject = currentRunner.GetActor(action.targetObjectName);
            }
        }
        
        switch (action.actionType)
        {
            case StoryActionType.MoveCharacter:
                if (targetObject != null)
                {
                    yield return MoveObjectCoroutine(targetObject.transform, action.targetPosition, action.duration);
                }
                break;
            
            case StoryActionType.SetCharacterActive:
                if (targetObject != null)
                {
                    targetObject.SetActive(action.boolValue);
                }
                break;
            
            case StoryActionType.SpawnObject:
                if (action.objectToSpawn != null)
                {
                    Instantiate(action.objectToSpawn, action.targetPosition, Quaternion.identity);
                }
                break;
            
            case StoryActionType.DestroyObject:
                if (targetObject != null)
                {
                    Destroy(targetObject);
                }
                break;

            case StoryActionType.StartDialogue:
                yield return null; 
                isWaitingForDialogueToEnd = true;
                DialogueManager.Instance.StartDialogue(action.dialogueFilePath, action.dialogueID);
                while (isWaitingForDialogueToEnd)
                {
                    yield return null;
                }
                break;

            case StoryActionType.Wait:
                yield return new WaitForSeconds(action.duration);
                break;
            
            case StoryActionType.MoveCameraToTarget:
                if (targetObject != null)
                {
                    yield return MoveObjectCoroutine(mainCamera.transform, targetObject.transform.position, action.duration, true);
                }
                break;

            case StoryActionType.MoveCameraToPosition:
                yield return MoveObjectCoroutine(mainCamera.transform, action.targetPosition, action.duration, true);
                break;
                
            case StoryActionType.FocusOnCharacter:
                if (targetObject != null)
                {
                    cameraFollowTarget = targetObject.transform;
                }
                break;
            
            case StoryActionType.ReleaseCameraFocus:
                cameraFollowTarget = null;
                break;

            case StoryActionType.TriggerGameEvent:
                GameEventManager.Instance.TriggerEvent(action.gameEventID);
                break;

            case StoryActionType.RunSubStory:
                if (action.subStoryToRun != null)
                {
                    Debug.Log($"<-- 進入子劇情: {action.subStoryToRun.sceneID} -->");
                    yield return ExecuteStoryScene(action.subStoryToRun);
                    Debug.Log($"<-- 子劇情結束: {action.subStoryToRun.sceneID} -->");
                }
                else
                {
                    Debug.LogWarning("RunSubStory 動作沒有指定 subStoryToRun！");
                }
                break;
        }
    }
    
    private void HandleDialogueEnded()
    {
        if (isWaitingForDialogueToEnd)
        {
            Debug.Log("[StoryManager] 監聽到對話結束事件，將繼續劇情。");
            isWaitingForDialogueToEnd = false;
        }
    }
    
    private IEnumerator MoveObjectCoroutine(Transform objectToMove, Vector2 endPosition, float duration, bool isCamera = false)
    {
        float elapsedTime = 0;
        Vector3 startPosition = objectToMove.position;
        Vector3 finalEndPosition = new Vector3(endPosition.x, endPosition.y, startPosition.z);

        if (duration <= 0)
        {
            objectToMove.position = finalEndPosition;
            yield break;
        }

        while (elapsedTime < duration)
        {
            objectToMove.position = Vector3.Lerp(startPosition, finalEndPosition, (elapsedTime / duration));
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        objectToMove.position = finalEndPosition;
    }

    private IEnumerator StoryPlaybackController(StorySceneData sceneData)
    {
        DialogueManager.OnDialogueEnded += HandleDialogueEnded;
        
        yield return ExecuteStoryScene(sceneData);
        
        DialogueManager.OnDialogueEnded -= HandleDialogueEnded;
        IsStorySceneActive = false;
        currentRunner = null;
        storyCoroutine = null;

        if (GameManager.Instance != null)
        {
            GameManager.Instance.SetGameState(GameState.Exploration);
        }
    }
}
```

#### 5. `StorySceneDataEditor.cs`
```csharp
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

[CustomEditor(typeof(StorySceneData))]
public class StorySceneDataEditor : Editor
{
    private Dictionary<int, bool> phaseFoldouts = new Dictionary<int, bool>();
    private GUIStyle headerStyle;
    private GUIStyle boxStyle;

    private void OnEnable()
    {
        headerStyle = new GUIStyle(EditorStyles.foldout)
        {
            fontStyle = FontStyle.Bold,
            fontSize = 13
        };

        boxStyle = new GUIStyle("box") 
        { 
            padding = new RectOffset(10, 10, 10, 10) 
        };
    }


    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        SerializedProperty sceneIDProp = serializedObject.FindProperty("sceneID");
        SerializedProperty phasesProp = serializedObject.FindProperty("phases");

        EditorGUILayout.LabelField("劇情場景設定", EditorStyles.boldLabel);
        EditorGUILayout.PropertyField(sceneIDProp);
        
        EditorGUILayout.Space(10);
        EditorGUILayout.LabelField("劇情階段序列", EditorStyles.boldLabel);
        EditorGUILayout.HelpBox("將劇情分解為多個階段。每個階段內的動作會同時執行，階段之間按順序執行。", MessageType.Info);

        for (int i = 0; i < phasesProp.arraySize; i++)
        {
            if (DrawPhase(phasesProp, i))
            {
                break; 
            }
        }

        if (GUILayout.Button("添加新階段", GUILayout.Height(30)))
        {
            phasesProp.InsertArrayElementAtIndex(phasesProp.arraySize);
            var newPhase = phasesProp.GetArrayElementAtIndex(phasesProp.arraySize - 1);
            newPhase.FindPropertyRelative("phaseName").stringValue = $"階段 {phasesProp.arraySize}";
        }
        serializedObject.ApplyModifiedProperties();
    }

    private bool DrawPhase(SerializedProperty phasesProp, int phaseIndex)
    {
        SerializedProperty phaseProp = phasesProp.GetArrayElementAtIndex(phaseIndex);
        SerializedProperty phaseNameProp = phaseProp.FindPropertyRelative("phaseName");
        SerializedProperty actionsProp = phaseProp.FindPropertyRelative("actions");
        
        if (!phaseFoldouts.ContainsKey(phaseIndex))
        {
            phaseFoldouts[phaseIndex] = true;
        }
        EditorGUILayout.BeginVertical(boxStyle);
        
        EditorGUILayout.BeginHorizontal();
        phaseFoldouts[phaseIndex] = EditorGUILayout.Foldout(phaseFoldouts[phaseIndex], $"階段 {phaseIndex + 1}: {phaseNameProp.stringValue}", true, headerStyle); // 優化 #1
        
        GUILayout.FlexibleSpace();
        if (DrawPhaseControls(phasesProp, phaseIndex))
        {
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
            return true;
        }
        EditorGUILayout.EndHorizontal();

        if (phaseFoldouts[phaseIndex])
        {
            EditorGUI.indentLevel++;

            EditorGUILayout.PropertyField(phaseNameProp, new GUIContent("階段名稱"));
            
            EditorGUILayout.Space(5);

            EditorGUILayout.LabelField("同時執行的動作:", EditorStyles.label);
            for (int j = 0; j < actionsProp.arraySize; j++)
            {
                if (DrawAction(actionsProp, j))
                {
                    break;
                }
            }

            if (GUILayout.Button("添加新動作"))
            {
                actionsProp.InsertArrayElementAtIndex(actionsProp.arraySize);
            }

            EditorGUI.indentLevel--;
        }
        EditorGUILayout.EndVertical();
        EditorGUILayout.Space(5);
        return false;
    }

    private bool DrawAction(SerializedProperty actionsProp, int actionIndex)
    {
        SerializedProperty actionProp = actionsProp.GetArrayElementAtIndex(actionIndex);
        SerializedProperty actionTypeProp = actionProp.FindPropertyRelative("actionType");
        
        EditorGUILayout.BeginVertical("helpbox");
        EditorGUILayout.BeginHorizontal();
        EditorGUILayout.PropertyField(actionTypeProp, GUIContent.none, GUILayout.Width(150));
        GUILayout.FlexibleSpace();
        if (GUILayout.Button("X", GUILayout.Width(25)))
        {
            actionsProp.DeleteArrayElementAtIndex(actionIndex);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
            return true;
        }
        EditorGUILayout.EndHorizontal();
        
        StoryActionType selectedType = (StoryActionType)actionTypeProp.enumValueIndex;
        DrawActionParameters(actionProp, selectedType);
        
        EditorGUILayout.EndVertical();
        return false;
    }

    private void DrawActionParameters(SerializedProperty actionProp, StoryActionType type)
    {
        switch (type)
        {
            case StoryActionType.MoveCharacter:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetObjectName"), new GUIContent("角色名"));
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetPosition"), new GUIContent("目標位置"));
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("duration"), new GUIContent("移動時間 (秒)"));
                break;
            
            case StoryActionType.SetCharacterActive:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetObjectName"), new GUIContent("物件名"));
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("boolValue"), new GUIContent("設為激活"));
                break;
                
            case StoryActionType.SpawnObject:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("objectToSpawn"), new GUIContent("生成 Prefab"));
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetPosition"), new GUIContent("生成位置"));
                break;

            case StoryActionType.DestroyObject:
                 EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetObjectName"), new GUIContent("物件名"));
                break;

            // --- 流程與交互控制 ---
            case StoryActionType.StartDialogue:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("dialogueFilePath"), new GUIContent("對話檔案路徑"));
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("dialogueID"), new GUIContent("對話 ID"));
                break;

            case StoryActionType.Wait:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("duration"), new GUIContent("等待時間 (秒)"));
                break;

            case StoryActionType.RunSubStory:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("subStoryToRun"), new GUIContent("子劇情檔案"));
                break;
                
            // --- 鏡頭控制 ---
            case StoryActionType.MoveCameraToTarget:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetObjectName"), new GUIContent("目標物件名"));
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("duration"), new GUIContent("移動時間 (秒)"));
                break;

            case StoryActionType.MoveCameraToPosition:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetPosition"), new GUIContent("目標位置"));
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("duration"), new GUIContent("移動時間 (秒)"));
                break;
                
            case StoryActionType.FocusOnCharacter:
                 EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("targetObjectName"), new GUIContent("跟隨目標名"));
                break;

            case StoryActionType.TriggerGameEvent:
                EditorGUILayout.PropertyField(actionProp.FindPropertyRelative("gameEventID"), new GUIContent("遊戲事件 ID"));
                break;

            case StoryActionType.DisableInput:
            case StoryActionType.EnableInput:
            case StoryActionType.ReleaseCameraFocus:
                EditorGUILayout.HelpBox("此動作無需額外參數。", MessageType.None);
                break;
        }
    }

    private bool DrawPhaseControls(SerializedProperty phasesProp, int phaseIndex)
    {
        GUI.enabled = phaseIndex > 0;
        if (GUILayout.Button("↑", EditorStyles.miniButton, GUILayout.Width(20)))
        {
            phasesProp.MoveArrayElement(phaseIndex, phaseIndex - 1);
        }

        GUI.enabled = phaseIndex < phasesProp.arraySize - 1;
        if (GUILayout.Button("↓", EditorStyles.miniButton, GUILayout.Width(20)))
        {
            phasesProp.MoveArrayElement(phaseIndex, phaseIndex + 1);
        }

        GUI.enabled = true;
        if (GUILayout.Button("刪除", EditorStyles.miniButton, GUILayout.Width(40)))
        {
            if (EditorUtility.DisplayDialog("確認刪除", $"確定要刪除階段 {phaseIndex + 1} 嗎？", "確定", "取消"))
            {
                phasesProp.DeleteArrayElementAtIndex(phaseIndex);
                return true;
            }
        }
        return false;
    }
}
```