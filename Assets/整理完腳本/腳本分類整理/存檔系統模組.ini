### **存檔系統模組(Save System Module)**

1. `GameSaveData.cs`(數據容器)：
(1) 定義了存檔檔案的結構。
(2) 全局數據（金錢、背包、任務）和場景數據（SceneSaveData）。
(3) SceneSaveData：
    * `objectStatesJsonMap`：活著的物件的狀態。
    * `destroyedObjectIDs`：死亡名單（已銷毀的原生物件）。
    * `runtimeSpawnedObjectData`：動態生成名單（如丟棄的物品）。

2. `SaveMnagaer.cs`：
(1) 負責檔案的讀寫 (Json 序列化/反序列化)。
(2) 管理存檔槽位 (Slot)。
(3) 協調非同步場景加載與數據恢復的流程。

3. `SaveLoadUI.cs`：
(1) 存檔、加載面板。
(2) 存檔、加載按鈕。
(3) 通知確認面板顯示。

4. `SaveSlotUI.cs`(Prefab)：
(1) 存檔格子：文字、按鈕。

5. `ConfirmationPanelUI.cs`：
(1) 確認面板：文字、按鈕。

6. `LoadingScreen.cs`：
(1) 加載面板，用一個布幕隱藏場景物件的加載或轉換。

7. `UniqueObjectIdentifier.cs`：
(1) 場景物件唯一 GUID，用於存檔識別。
(2) 監聽銷毀：在 OnDestroy 時通知 ScenePersistenceManager，將自己加入死亡名單（如果是原生物件）。

8. `ScenePersistenceManager`：
(1) 死亡名單：提供 `RecordObjectDestruction` 方法。
(2) 執行死刑：讀檔時，根據「死亡名單」銷毀場景中不該存在的物件。
(3) 執行重生：讀檔時，根據「動態生成名單」重新生成 `GroundItem`。
(4) 恢復狀態：遍歷場景中所有 `ISceneSaveable`，恢復其變數。

---

1. `IGameSaveable.cs`：
(1) 全局管理器，特定數據區塊接口。

2. `ISenceSaveable.cs`：
(1) 場景中的動態物件接口。

---

### **腳本**

#### 1. `GameSaveData.cs`
```
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class SceneSaveData
{
    public List<string> objectIDs = new List<string>();
    public List<string> objectStateJsons = new List<string>();
    public List<string> destroyedObjectIDs = new List<string>();
    public List<string> runtimeSpawnedObjectData = new List<string>();

    [System.NonSerialized]
    public Dictionary<string, string> objectStatesJsonMap = new Dictionary<string, string>();

    public void OnBeforeSerialize()
    {
        objectIDs.Clear();
        objectStateJsons.Clear();
        foreach (var pair in objectStatesJsonMap)
        {
            objectIDs.Add(pair.Key);
            objectStateJsons.Add(pair.Value);
        }
    }

    public void OnAfterDeserialize()
    {
        objectStatesJsonMap = new Dictionary<string, string>();
        for (int i = 0; i < objectIDs.Count && i < objectStateJsons.Count; i++)
        {
            objectStatesJsonMap[objectIDs[i]] = objectStateJsons[i];
        }
    }
}

[System.Serializable]
public class GameSaveData
{
    public string gameVersion;
    public string saveTimestamp;
    public float playtimeInSeconds;

    public PlayerStateData playerStateData;
    public InventoryData inventoryData;
    public QuestData questData;
    public PartyData partyData;
    public WorldData worldData;
    public TutorialData tutorialData;
    public ShopManagerData shopManagerData;
    public WorldTimeData worldTimeData;

    public List<string> sceneNames = new List<string>();
    public List<SceneSaveData> sceneSaveDataList = new List<SceneSaveData>();
    
    [System.NonSerialized]
    public Dictionary<string, SceneSaveData> sceneData = new Dictionary<string, SceneSaveData>();

    public GameSaveData()
    {
        playerStateData = new PlayerStateData();
        inventoryData = new InventoryData();
        questData = new QuestData();
        partyData = new PartyData();
        worldData = new WorldData();
        tutorialData = new TutorialData();
        shopManagerData = new ShopManagerData();
        worldTimeData = new WorldTimeData();
        sceneData = new Dictionary<string, SceneSaveData>();
    }
}

#region 子數據結構
[System.Serializable]
public class PlayerStateData
{
    public int money;
    public int level;
    public int currentExperience;
    public int experienceToNextLevel;
}

[System.Serializable]
public class InventoryData
{
    public List<InventorySlotData> slots;
}

[System.Serializable]
public class QuestStatusEntry
{
    public string questID;
    public Quest.QuestStatus status;
}

[System.Serializable]
public class ActiveQuestData
{
    public string questID;
    public List<int> objectiveProgress;
}

[System.Serializable]
public class QuestData
{
    public List<QuestStatusEntry> questStatuses;
    public List<ActiveQuestData> activeQuests;
    public List<string> permanentlyCompletedQuestIDs;
}

[System.Serializable]
public class PartyData
{
    public List<MemberInstance> allMembers;
    public List<string> battlePartyInstanceIDs;
}

[System.Serializable]
public class WorldData
{
    public string sceneName;
    public Vector3 playerPosition;
    public List<string> triggeredEvents;
}

[System.Serializable]
public class TutorialData
{
    public List<string> completedTutorials;
}

[System.Serializable]
public class ShopItemForSave
{
    public string itemID;
    public int quantity;
}

[System.Serializable]
public class ShopRuntimeDataForSave
{
    public string traderNpcID;
    public int currentFund;
    public List<ShopItemForSave> currentStock;
    public int lastRefreshDay;
}

[System.Serializable]
public class ShopManagerData
{
    public List<ShopRuntimeDataForSave> traderData;
    public ShopManagerData() { traderData = new List<ShopRuntimeDataForSave>(); }
}

[System.Serializable]
public class WorldTimeData
{
    public int currentDay;
    public float dayTimer;
}

[System.Serializable]
public class InventorySlotData
{
    public string itemID;
    public int quantity;
}

[System.Serializable]
public class RuntimeSpawnedObjectData
{
    public string prefabType;
    public string instanceID;
    public string stateJson;
}
#endregion
```

#### 2. `SaveMnagaer.cs`
```
using UnityEngine;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using UnityEngine.SceneManagement;
using System;
using System.Linq;

public class SaveManager : MonoBehaviour, IGameSaveable
{
    public static SaveManager Instance { get; private set; }
    public static event Action OnGameLoadComplete;
    private readonly string fileNameTemplate = "SaveSlot_{0}.json";
    private GameSaveData currentSessionData; 
    private List<IGameSaveable> saveableEntities = new List<IGameSaveable>();
    private LoadingScreen loadingScreen;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        Register(this);
        
        if (currentSessionData == null)
        {
            currentSessionData = new GameSaveData();
        }
    }

    #region 註冊機制
    public void Register(IGameSaveable entity)
    {
        if (!saveableEntities.Contains(entity))
        {
            saveableEntities.Add(entity);
        }
    }

    public void Unregister(IGameSaveable entity)
    {
        saveableEntities.Remove(entity);
    }
    #endregion

    private string GetSavePath(int slotIndex)
    {
        return Path.Combine(Application.persistentDataPath, string.Format(fileNameTemplate, slotIndex));
    }

    public void SaveSceneStateToMemory()
    {
        if (currentSessionData == null) currentSessionData = new GameSaveData();
        foreach (var entity in saveableEntities)
        {
            entity.PopulateSaveData(currentSessionData);
        }
        if (ScenePersistenceManager.Instance != null)
        {
            ScenePersistenceManager.Instance.PopulateSaveData(currentSessionData);
        }
        Debug.Log("<color=yellow>[SaveManager]</color> 已將當前場景狀態保存到內存。");
    }

    public void LoadSceneStateFromMemory()
    {
        if (currentSessionData == null) return;
        
        foreach (var entity in saveableEntities)
        {
            entity.LoadFromSaveData(currentSessionData);
        }
        
        if (ScenePersistenceManager.Instance != null)
        {
            ScenePersistenceManager.Instance.LoadFromSaveData(currentSessionData);
        }
        Debug.Log("<color=yellow>[SaveManager]</color> 已從內存恢復當前場景狀態。");
    }

    public void SaveGame(int slotIndex)
    {
        SaveSceneStateToMemory();
        currentSessionData.gameVersion = Application.version;
        currentSessionData.saveTimestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

        currentSessionData.sceneNames.Clear();
        currentSessionData.sceneSaveDataList.Clear();
        foreach(var pair in currentSessionData.sceneData)
        {
            pair.Value.OnBeforeSerialize();
            currentSessionData.sceneNames.Add(pair.Key);
            currentSessionData.sceneSaveDataList.Add(pair.Value);
        }
        string json = JsonUtility.ToJson(currentSessionData, true);
        string path = GetSavePath(slotIndex);
        string backupPath = path + ".bak";
        try
        {
            if (File.Exists(path))
            {
                File.Copy(path, backupPath, true);
            }
            File.WriteAllText(path, json);
            if (File.Exists(backupPath))
            {
                File.Delete(backupPath);
            }
            Debug.Log($"<color=cyan>[SaveManager]</color> 遊戲已安全儲存至槽位 {slotIndex}。");
        }
        catch (Exception e)
        {
            Debug.LogError($"[SaveManager] 保存至槽位 {slotIndex} 時發生嚴重錯誤: {e.Message}");
            if (File.Exists(backupPath))
            {
                File.Copy(backupPath, path, true);
            }
        }
    }

    public void LoadGame(int slotIndex)
    {
        string path = GetSavePath(slotIndex);
        string backupPath = path + ".bak";

        if (!File.Exists(path) && File.Exists(backupPath))
        {
            Debug.LogWarning($"[SaveManager] 找不到主存檔，但發現備份檔案。正在嘗試從備份恢復...");
            File.Copy(backupPath, path, true);
        }

        if (!File.Exists(path))
        {
            Debug.LogError($"找不到槽位 {slotIndex} 的存檔檔案！");
            return;
        }

        try
        {
            string json = File.ReadAllText(path);
            currentSessionData = JsonUtility.FromJson<GameSaveData>(json);
            currentSessionData.sceneData = new Dictionary<string, SceneSaveData>();
            if (currentSessionData.sceneNames != null && currentSessionData.sceneSaveDataList != null)
            {
                for(int i = 0; i < currentSessionData.sceneNames.Count; i++)
                {
                    if (i < currentSessionData.sceneSaveDataList.Count)
                    {
                        currentSessionData.sceneSaveDataList[i].OnAfterDeserialize();
                        currentSessionData.sceneData[currentSessionData.sceneNames[i]] = currentSessionData.sceneSaveDataList[i];
                    }
                }
            }
            StartCoroutine(LoadSceneAndApplyData());
        }
        catch (Exception e)
        {
            Debug.LogError($"[SaveManager] 讀取槽位 {slotIndex} 存檔失敗，檔案可能已損壞: {e.Message}");
            currentSessionData = null;
        }
    }

    public void DeleteSaveFile(int slotIndex)
    {
        string path = GetSavePath(slotIndex);
        if (File.Exists(path))
        {
            File.Delete(path);
            Debug.Log($"<color=orange>[SaveManager]</color> 已刪除槽位 {slotIndex} 的存檔檔案。");
        }
    }

    private IEnumerator LoadSceneAndApplyData()
    {
        loadingScreen = FindObjectOfType<LoadingScreen>(true);
        loadingScreen?.Show();
        loadingScreen?.UpdateProgress(0.1f, "正在載入場景...");

        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(currentSessionData.worldData.sceneName);
        asyncLoad.allowSceneActivation = false;

        while (asyncLoad.progress < 0.9f)
        {
            loadingScreen?.UpdateProgress(0.1f + asyncLoad.progress * 0.5f, "正在構建世界...");
            yield return null;
        }
        
        loadingScreen?.UpdateProgress(0.6f, "準備完成...");
        asyncLoad.allowSceneActivation = true;
        while (!asyncLoad.isDone)
        {
            yield return null;
        }
        yield return new WaitForEndOfFrame(); 

        loadingScreen?.UpdateProgress(0.7f, "正在恢復進度...");
        Debug.Log("<color=yellow>[SaveManager]</color> 開始靜默數據恢復...");
        
        LoadSceneStateFromMemory();
        
        Debug.Log("<color=yellow>[SaveManager]</color> 靜默數據恢復完成。");
        loadingScreen?.UpdateProgress(0.9f, "正在同步狀態...");
        Debug.Log("<color=green>[SaveManager]</color> 廣播 OnGameLoadComplete 事件...");
        OnGameLoadComplete?.Invoke();
        Debug.Log("<color=green>[SaveManager]</color> 全局刷新事件已廣播。");

        if (currentSessionData.worldData != null)
        {
            Player player = FindObjectOfType<Player>();
            if (player != null)
            {
                player.SetPosition(currentSessionData.worldData.playerPosition);
            }
        }

        loadingScreen?.UpdateProgress(1.0f, "載入完成！");
        yield return new WaitForSecondsRealtime(0.5f);
        if (loadingScreen != null)
        {
            yield return StartCoroutine(loadingScreen.FadeOut(0.5f));
        }
        Debug.Log("<color=cyan>[SaveManager]</color> 遊戲讀取完成！");
    }
    
    public bool DoesSaveFileExist(int slotIndex)
    {
        return File.Exists(GetSavePath(slotIndex));
    }

    public GameSaveData GetSaveFileSummary(int slotIndex)
    {
        if (!DoesSaveFileExist(slotIndex)) return null;
        try
        {
            string json = File.ReadAllText(GetSavePath(slotIndex));
            return JsonUtility.FromJson<GameSaveData>(json);
        }
        catch (Exception e)
        {
            Debug.LogError($"[SaveManager] 讀取槽位 {slotIndex} 的存檔摘要時失敗: {e.Message}");
            return null;
        }
    }

    #region 世界數據
    public void PopulateSaveData(GameSaveData data)
    {
        Player player = FindObjectOfType<Player>();
        if (player != null)
        {
            data.worldData.sceneName = SceneManager.GetActiveScene().name;
            data.worldData.playerPosition = player.transform.position;
        }
    }

    public void LoadFromSaveData(GameSaveData data)
    {
        if (data.worldData != null)
        {
            Player player = FindObjectOfType<Player>();
            if (player != null)
            {
                player.SetPosition(data.worldData.playerPosition);
                Debug.Log($"[SaveManager] 已恢復玩家位置至: {data.worldData.playerPosition}");
            }
        }
    }
    #endregion
}
```

#### 3. `SaveLoadUI.cs`
```
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class SaveLoadUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject mainPanel;
    [SerializeField] private TextMeshProUGUI titleText;
    [SerializeField] private Transform slotsContainer;
    [SerializeField] private GameObject slotPrefab;
    [SerializeField] private Button closeButton;
    [SerializeField] private ConfirmationPanelUI confirmationPanel;

    private bool isSaveMode = true;
    private bool isTitleScreenMode = false;
    private const int MAX_SLOTS = 3;

    void Awake()
    {
        closeButton.onClick.AddListener(HidePanel);
        if (mainPanel != null) mainPanel.SetActive(false);
        if (confirmationPanel != null) confirmationPanel.Hide();
    }

    public void SetTitleScreenMode(bool isTitle)
    {
        isTitleScreenMode = isTitle;
    }

    public void ShowPanel(bool forSaving)
    {
        isSaveMode = forSaving;
        mainPanel.SetActive(true);
        if (titleText != null)
        {
            titleText.text = isSaveMode ? "儲存進度" : "讀取進度";
        }
        RefreshSlots();
    }

    public void HidePanel()
    {
        if (mainPanel != null) mainPanel.SetActive(false);
    }

    private void RefreshSlots()
    {
        foreach (Transform child in slotsContainer)
        {
            Destroy(child.gameObject);
        }
        for (int i = 0; i < MAX_SLOTS; i++)
        {
            GameObject slotGO = Instantiate(slotPrefab, slotsContainer);
            SaveSlotUI slotUI = slotGO.GetComponent<SaveSlotUI>();
            GameSaveData summary = SaveManager.Instance.GetSaveFileSummary(i);
            slotUI.Setup(i, summary, OnSlotClicked, OnDeleteRequested);
            if (!isSaveMode && summary == null)
            {
                slotUI.SetInteractable(false);
            }
        }
    }

    private void OnSlotClicked(int slotIndex)
    {
        if (isSaveMode)
        {
            if (StoryManager.Instance != null && StoryManager.Instance.IsStorySceneActive)
            {
                Debug.LogWarning("劇情演出中，禁止存檔。");
                return;
            }
            
            if (SaveManager.Instance.DoesSaveFileExist(slotIndex))
            {
                confirmationPanel.Show(
                    "覆蓋存檔？",
                    $"您確定要覆蓋槽位 {slotIndex + 1} 的進度嗎？此操作無法復原。",
                    () => {
                        SaveManager.Instance.SaveGame(slotIndex);
                        RefreshSlots();
                    }
                );
            }
            else
            {
                SaveManager.Instance.SaveGame(slotIndex);
                RefreshSlots();
            }
        }
        else
        {
            if (SaveManager.Instance.DoesSaveFileExist(slotIndex))
            {
                GameSaveData summary = SaveManager.Instance.GetSaveFileSummary(slotIndex);
                string currentVersion = Application.version;
                if (summary != null && summary.gameVersion != currentVersion)
                {
                    confirmationPanel.Show(
                        "版本不匹配",
                        $"此存檔來自舊版本 ({summary.gameVersion})，當前遊戲版本為 {currentVersion}。\n繼續載入可能導致未知問題，您確定要繼續嗎？",
                        () => PerformLoad(slotIndex)
                    );
                    return;
                }
                bool isAtTitleScreen = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name == "Title";
                string confirmMessage;
                if (isAtTitleScreen)
                {
                    confirmMessage = $"是否要讀取槽位 {slotIndex + 1} 的存檔？";
                }
                else
                {
                    confirmMessage = $"您確定要讀取槽位 {slotIndex + 1} 的進度嗎？任何未儲存的進度將會遺失。";
                }
                confirmationPanel.Show(
                    "讀取遊戲？",
                    confirmMessage,
                    () => PerformLoad(slotIndex)
                );
            }
            else
            {
                Debug.Log($"槽位 {slotIndex + 1} 是空的，無法讀取。");
            }
        }
    }

    private void PerformLoad(int slotIndex)
    {
        SaveManager.Instance.LoadGame(slotIndex);
        
        var gameSystemUI = FindObjectOfType<GameSystemUI>();
        if (gameSystemUI != null)
        {
            gameSystemUI.CloseAllPanels();
        }
        else
        {
            HidePanel();
        }
    }

    private void OnDeleteRequested(int slotIndex)
    {
        confirmationPanel.Show(
            "刪除存檔？",
            $"您確定要永久刪除槽位 {slotIndex + 1} 的存檔嗎？此操作無法復原。",
            () => {
                SaveManager.Instance.DeleteSaveFile(slotIndex);
                RefreshSlots();
            }
        );
    }
}
```

#### 4. `SaveSlotUI.cs`
```
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;

public class SaveSlotUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private TextMeshProUGUI slotIndexText;
    [SerializeField] private TextMeshProUGUI timestampText;
    [SerializeField] private TextMeshProUGUI sceneNameText;
    [SerializeField] private GameObject emptySlotInfo;
    [SerializeField] private GameObject filledSlotInfo;
    [SerializeField] private Button slotButton;
    [SerializeField] private Button deleteButton;

    private int slotIndex;
    private Action<int> onClickCallback;
    private Action<int> onDeleteCallback;

    public void Setup(int index, GameSaveData data, Action<int> clickCallback, Action<int> deleteCallback)
    {
        this.slotIndex = index;
        this.onClickCallback = clickCallback;
        this.onDeleteCallback = deleteCallback;

        slotIndexText.text = $"槽位 {index + 1}";

        bool hasData = (data != null);
        bool isCorrupted = SaveManager.Instance.DoesSaveFileExist(index) && !hasData;

        filledSlotInfo.SetActive(hasData || isCorrupted);
        emptySlotInfo.SetActive(!hasData && !isCorrupted);

        if (deleteButton != null)
        {
            deleteButton.gameObject.SetActive(hasData || isCorrupted);
            if (hasData || isCorrupted)
            {
                deleteButton.onClick.RemoveAllListeners();
                deleteButton.onClick.AddListener(OnDeleteButtonClicked);
            }
        }

        if (isCorrupted)
        {
            timestampText.text = "<color=red>存檔已損壞</color>";
            sceneNameText.text = "請刪除此存檔";
            slotButton.interactable = false;
        }
        else if (hasData)
        {
            timestampText.text = data.saveTimestamp;
            sceneNameText.text = $"場景: {data.worldData.sceneName}";
            slotButton.interactable = true;
        }

        slotButton.onClick.RemoveAllListeners();
        slotButton.onClick.AddListener(OnSlotButtonClicked);
    }

    private void OnSlotButtonClicked()
    {
        onClickCallback?.Invoke(slotIndex);
    }

    private void OnDeleteButtonClicked()
    {
        onDeleteCallback?.Invoke(slotIndex);
    }

    public void SetInteractable(bool interactable)
    {
        if (slotButton != null)
        {
            slotButton.interactable = interactable;
        }
    }
}
```

#### 5. `ConfirmationPanelUI.cs`
```
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;

public class ConfirmationPanelUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject panel;
    [SerializeField] private TextMeshProUGUI titleText;
    [SerializeField] private TextMeshProUGUI messageText;
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button cancelButton;

    private void Awake()
    {
        if (panel != null) panel.SetActive(false);
        if (cancelButton != null) cancelButton.onClick.AddListener(Hide);
    }

    public void Show(string title, string message, Action onConfirm)
    {
        if (panel == null)
        {
            Debug.LogError("ConfirmationPanelUI 的 panel 物件未指定！");
            return;
        }
        if (titleText != null) titleText.text = title;
        if (messageText != null) messageText.text = message;
        if (confirmButton != null) confirmButton.onClick.RemoveAllListeners();
        if (confirmButton != null)
        {
            confirmButton.onClick.AddListener(() => onConfirm?.Invoke());
            confirmButton.onClick.AddListener(Hide);
        }
        panel.SetActive(true);
        panel.transform.SetAsLastSibling();
    }

    public void Hide()
    {
        if (panel != null) panel.SetActive(false);
    }
}
```

#### 6. `LoadingScreen.cs`
```
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections;

[RequireComponent(typeof(CanvasGroup))]
public class LoadingScreen : MonoBehaviour
{
    [Header("UI 元素連結")]
    [SerializeField] private Slider progressBar;
    [SerializeField] private TextMeshProUGUI statusText;

    private CanvasGroup canvasGroup;
    private bool isInitialized = false;

    void Awake()
    {
        canvasGroup = GetComponent<CanvasGroup>();
        isInitialized = true;
        gameObject.SetActive(false);
    }

    public void Show()
    {
        if (!isInitialized)
        {
            canvasGroup = GetComponent<CanvasGroup>();
            isInitialized = true;
        }
        UpdateProgress(0f, "正在準備...");
        gameObject.SetActive(true); 
        canvasGroup.alpha = 1f;
    }

    public void UpdateProgress(float progress, string text)
    {
        if (progressBar != null)
        {
            progressBar.value = progress;
        }
        if (statusText != null)
        {
            statusText.text = text;
        }
    }

    public void Hide()
    {
        gameObject.SetActive(false);
    }

    public IEnumerator FadeOut(float duration)
    {
        float elapsedTime = 0f;
        while (elapsedTime < duration)
        {
            elapsedTime += Time.unscaledDeltaTime;
            canvasGroup.alpha = 1.0f - (elapsedTime / duration);
            yield return null;
        }
        Hide();
    }
}
```

#### 7. `UniqueObjectIdentifier.cs`
```
using UnityEngine;
using System;

[ExecuteInEditMode]
public class UniqueObjectIdentifier : MonoBehaviour
{
    [Header("場景內唯一ID")]
    [Tooltip("此ID在當前場景中必須是唯一的。用於存檔系統識別。")]
    [SerializeField]
    private string id;
    public string ID => id;

    [HideInInspector]
    public bool IsRuntimeInstantiated = false;

    private bool isQuitting = false;

    private void Reset()
    {
        GenerateID();
    }
    
    private void OnValidate()
    {
        if (string.IsNullOrEmpty(id))
        {
            GenerateID();
        }
    }

    [ContextMenu("Generate New ID")]
    private void GenerateID()
    {
        id = Guid.NewGuid().ToString();
        #if UNITY_EDITOR
        if (!Application.isPlaying)
        {
            UnityEditor.EditorUtility.SetDirty(this);
            UnityEditor.SceneManagement.EditorSceneManager.MarkSceneDirty(gameObject.scene);
        }
        #endif
    }

    public void SetID(string newId)
    {
        if (!string.IsNullOrEmpty(newId))
        {
            id = newId;
        }
    }

    private void OnApplicationQuit()
    {
        isQuitting = true;
    }

    private void OnDestroy()
    {
        if (isQuitting) return;
        if (ScenePersistenceManager.Instance != null)
        {
            if (!IsRuntimeInstantiated)
            {
                ScenePersistenceManager.Instance.RecordObjectDestruction(id);
            }
        }
    }
}
```

#### 8. `ScenePersistenceManager.cs`
```
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.SceneManagement;

public class ScenePersistenceManager : MonoBehaviour, IGameSaveable
{
    public static ScenePersistenceManager Instance { get; private set; }
    private HashSet<string> destroyedObjectIDs = new HashSet<string>();

    [Header("動態生成設定")]
    [SerializeField] private GameObject groundItemPrefab;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        
        if (SaveManager.Instance != null)
        {
            SaveManager.Instance.Register(this);
        }
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    void OnDestroy()
    {
        if (SaveManager.Instance != null)
        {
            SaveManager.Instance.Unregister(this);
        }
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        destroyedObjectIDs.Clear();
    }

    public void RecordObjectDestruction(string id)
    {
        if (!string.IsNullOrEmpty(id))
        {
            if (!destroyedObjectIDs.Contains(id))
            {
                destroyedObjectIDs.Add(id);
                Debug.Log($"[ScenePersistenceManager] 記錄物件銷毀: {id}");
            }
        }
    }
    
    public void PopulateSaveData(GameSaveData data)
    {
        string currentSceneName = SceneManager.GetActiveScene().name;
        
        if (!data.sceneData.ContainsKey(currentSceneName))
        {
            data.sceneData[currentSceneName] = new SceneSaveData();
        }
        SceneSaveData sceneSaveData = data.sceneData[currentSceneName];
        
        sceneSaveData.objectStatesJsonMap.Clear();
        sceneSaveData.destroyedObjectIDs = new List<string>(destroyedObjectIDs);
        sceneSaveData.runtimeSpawnedObjectData.Clear();
        
        var saveableEntities = FindObjectsOfType<MonoBehaviour>(true).OfType<ISceneSaveable>();
        foreach (var entity in saveableEntities)
        {
            var component = entity as Component;
            if (component != null && component.TryGetComponent<UniqueObjectIdentifier>(out var identifier))
            {
                if (identifier.IsRuntimeInstantiated)
                {
                    object state = entity.CaptureState();
                    string jsonState = JsonUtility.ToJson(state);
                    
                    string prefabType = "";
                    if (component is GroundItem) prefabType = "GroundItem";
                    if (!string.IsNullOrEmpty(prefabType))
                    {
                        var runtimeData = new RuntimeSpawnedObjectData
                        {
                            prefabType = prefabType,
                            instanceID = identifier.ID,
                            stateJson = jsonState
                        };
                        sceneSaveData.runtimeSpawnedObjectData.Add(JsonUtility.ToJson(runtimeData));
                    }
                }
                else
                {
                    if (!destroyedObjectIDs.Contains(identifier.ID))
                    {
                        object state = entity.CaptureState();
                        string jsonState = JsonUtility.ToJson(state);
                        sceneSaveData.objectStatesJsonMap[identifier.ID] = jsonState;
                    }
                }
            }
        }
        Debug.Log($"[ScenePersistenceManager] 場景 '{currentSceneName}' 狀態已保存到內存: {sceneSaveData.objectStatesJsonMap.Count} 個原生物件, {sceneSaveData.destroyedObjectIDs.Count} 個已銷毀, {sceneSaveData.runtimeSpawnedObjectData.Count} 個動態生成。");
    }

    public void LoadFromSaveData(GameSaveData data)
    {
        string currentSceneName = SceneManager.GetActiveScene().name;
        
        if (!data.sceneData.ContainsKey(currentSceneName))
        {
            destroyedObjectIDs.Clear();
            return;
        }
        SceneSaveData sceneSaveData = data.sceneData[currentSceneName];
        
        destroyedObjectIDs = new HashSet<string>(sceneSaveData.destroyedObjectIDs);
        
        var allIdentifiers = FindObjectsOfType<UniqueObjectIdentifier>(true);
        foreach (var identifier in allIdentifiers)
        {
            if (!identifier.IsRuntimeInstantiated && destroyedObjectIDs.Contains(identifier.ID))
            {
                Debug.Log($"[ScenePersistenceManager] 銷毀已記錄死亡的物件: {identifier.name} ({identifier.ID})");
                Destroy(identifier.gameObject);
            }
        }
        
        var existingRuntimeObjects = FindObjectsOfType<UniqueObjectIdentifier>().Where(i => i.IsRuntimeInstantiated).ToList();
        foreach(var obj in existingRuntimeObjects)
        {
            DestroyImmediate(obj.gameObject);
        }
        
        if (sceneSaveData.runtimeSpawnedObjectData != null)
        {
            foreach (var json in sceneSaveData.runtimeSpawnedObjectData)
            {
                var runtimeData = JsonUtility.FromJson<RuntimeSpawnedObjectData>(json);
                if (runtimeData.prefabType == "GroundItem" && groundItemPrefab != null)
                {
                    GameObject newObj = Instantiate(groundItemPrefab);
                    var identifier = newObj.GetComponent<UniqueObjectIdentifier>();
                    if (identifier == null) identifier = newObj.AddComponent<UniqueObjectIdentifier>();
                    
                    identifier.SetID(runtimeData.instanceID);
                    identifier.IsRuntimeInstantiated = true;
                    
                    var saveable = newObj.GetComponent<ISceneSaveable>();
                    if (saveable != null)
                    {
                        saveable.RestoreState(runtimeData.stateJson);
                    }
                }
            }
        }
        
        var entityMap = new Dictionary<string, ISceneSaveable>();
        var allSaveables = FindObjectsOfType<MonoBehaviour>(true)
            .OfType<ISceneSaveable>()
            .Where(e => (e as Component).GetComponent<UniqueObjectIdentifier>() != null);
        foreach (var entity in allSaveables)
        {
            var idComponent = (entity as Component).GetComponent<UniqueObjectIdentifier>();
            if (entityMap.ContainsKey(idComponent.ID))
            {
                Debug.LogWarning($"[ScenePersistenceManager] 發現重複 ID 的物件: {idComponent.name} (ID: {idComponent.ID})。這可能會導致狀態恢復錯誤，請檢查場景設置。忽略此重複項。");
            }
            else
            {
                entityMap.Add(idComponent.ID, entity);
            }
        }
        
        foreach (var savedState in sceneSaveData.objectStatesJsonMap)
        {
            string objectID = savedState.Key;
            string stateJson = savedState.Value;
            
            if (entityMap.TryGetValue(objectID, out ISceneSaveable entity))
            {
                entity.RestoreState(stateJson);
            }
        }
        Debug.Log($"[ScenePersistenceManager] 場景 '{currentSceneName}' 狀態已從內存恢復。");
    }
}
```

---

#### 9. `IGameSaveable.cs`
```
public interface IGameSaveable
{
    void PopulateSaveData(GameSaveData data);
    void LoadFromSaveData(GameSaveData data);
}
```

#### 10. `ISceneSaveable.cs`
```
public interface ISceneSaveable
{
    object CaptureState();
    void RestoreState(object stateData);
}
```