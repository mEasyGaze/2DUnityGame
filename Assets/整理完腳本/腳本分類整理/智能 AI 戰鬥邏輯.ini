### **智能 AI 戰鬥模組 (AI Battle Logic Module)**

1. `EnemyBattleAI.cs` - AI 總司令 (AI Controller)
*   核心職責：作為 AI 的決策主腦，負責在「敵人回合」開始時，為所有己方單位制定出一整套的行動計劃。
*   工作流程：
    1. 接收命令：在敵人回合開始時，被 `TurnManager` 調用，並接收由 `BattleEncounterSO` 指定的 `AIPersonalitySO` (軍師)。
    2. 模式切換：如果接收到了「軍師」，則啟動**智能決策模式** (`ExecuteSmartAI`)；如果沒有，則退回到可靠的**通用後備戰術** (`ExecuteSimpleFallbackAI`)。
    3. 逐一決策 (智能模式)：以「單位」為中心進行思考。遍歷己方所有存活單位，為每個單位規劃其本回合的所有行動（前衛4次，遠程2次）。
    4. 生成 & 評分：在為單位的某個行動次序做決策時，會先生成所有合法的**候選行動**（攻擊、防禦、交換等），然後調用**評分核心邏輯** (`CalculateScoreForAction`) 為每個選項打分。
    5. 下達指令：選出得分最高的行動，將其記錄到 `TurnActionPlanner` 中，並更新內部的體力追蹤器，以便為該單位的下一次行動提供準確的決策依據。

2. `AIPersonalitySO.cs` - 軍師 (AI Personality)
*   核心職責：定義一個 AI 的**宏觀戰術風格**。它本身不思考，而是像一個文件櫃，存放著為不同戰場位置（前衛、遠程1/2、後勤）準備的專屬「戰術文件夾」。
*   工作流程：
    1. 提供手冊：當「總司令」(`EnemyBattleAI`) 詢問：「現在輪到位於『前衛』的單位行動了，我該如何評估？」，這位「軍師」會從自己的文件櫃裡，拿出標有「前衛」的**戰術文件夾** (`PositionalStrategy`)。

3. `AITacticSO.cs` - 戰術文件 (AI Tactic)
*   核心職責：一份具體的**戰術指導文件**，本身不包含任何條件判斷，而是直接匯集了一組「參謀」。
*   工作流程：
    1. 提供參謀名單：當「總司令」(`EnemyBattleAI`) 拿到這份戰術文件後，他會看到裡面列出了一系列需要諮詢的「參謀」(`scoringModifiers` 列表)。他會逐一諮詢這些參謀，綜合他們的意見來為行動打分。

4. `SM_BaseSO.cs` - 參謀基類 (Scoring Modifier Base)
*   核心職責：AI 系統中所有「**參謀**」的抽象基類，定義了他們的標準工作方式。
*   工作流程：
    1. 標準化接口：規定了所有參謀都必須實現一個 `CalculateScore` 方法。這個方法是他們回答「總司令」詢問的唯一方式。
    2. 上下文傳遞：定義了 `AIContext` 類，確保在評分時，參謀們能獲取到足夠的戰場信息（雙方隊伍、回合數）來做出判斷。
    3. 權重調整：內置 `weight` 屬性，讓設計師可以方便地調整同一份戰術文件中，不同參謀意見的相對重要性。

5. `SM_MultiCondSO.cs` - 條件參謀 (Multi-Condition Scorer)
*   核心職責：AI 系統的**原子級規則顧問**。它的職責非常專一：回答一個問題：「對於這個正在考慮的行動，在滿足 A、B、C 等多個條件下，我應該給它加多少分或減多少分？」
*   工作流程：
    1. 多重條件核查：當被「總司令」諮詢時，這位參謀會檢查自己手頭上的所有條件 (`conditions` 列表)，例如：「行動者的血量是否在 20% 到 60% 之間？」「他的攻擊距離是否為 1？」
    2. 給出評分：只有當**所有條件都滿足**時，這位參謀才會根據預設的評分標準 (`scores` 列表) 給出一個具體的分數（例如，「攻擊：+50分」）。如果任何一個條件不滿足，他就不發表意見（返回 0 分）。

6. `SM_OutcomeSO.cs` - 結果預測參謀 (Outcome Prediction Scorer)
*   核心職責：一位「未來預測官」。專門負責評估一個行動可能導致的**直接後果**。
*   工作流程：
    1. 斬殺判斷：當被諮詢一個「攻擊」行動時，它會判斷這次攻擊是否能直接擊殺目標。如果可以，它會給出一個很高的獎勵分 (`killTargetScore`)。
    2. 自我風險評估：（未來可擴展）評估行動是否會導致自身陷入危險（例如，被反擊致死），並給出懲罰分 (`actorDiesScore`)。

7. `SM_CommanderSkillSO.cs` - 指揮官技能參謀 (Commander Skill Scorer)
*   核心職責：一位「最高參謀」。專門負責評估是否應該動用戰場上的王牌——「指揮官技能」。
*   工作流程：
    1.  時機判斷：只有當被諮詢的行動是「指揮官技能」時，這位參謀才會發表意見。
    2.  戰略評估：它會根據技能的類型（攻擊、治療等）和當前的宏觀戰局（敵我雙方血量、回合數）來給出一個基礎分和額外的獎勵分，以判斷現在是否是使用大招的最佳時機。

---

### 腳本結構

1. `EnemyBattleAI.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System;

[CreateAssetMenu(fileName = "EnemyBattleAI", menuName = "Battle System/AI/Enemy AI Controller")]
public class EnemyBattleAI : ScriptableObject
{
    [Header("核心戰鬥邏輯")]
    [Tooltip("【必須指定!】用於定義行動消耗與效果的 BattleActions 檔案。")]
    [SerializeField] private BattleActions battleActions;

    private class ScoredAction
    {
        public ActionPlan Plan { get; }
        public float Score { get; }
        public string Log { get; }
        public ScoredAction(ActionPlan plan, float score, string log) 
        { 
            Plan = plan; 
            Score = score; 
            Log = log;
        }
    }

    public void PlanActions(AIPersonalitySO personality, List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules, int turnCount)
    {
        if (battleActions == null)
        {
            Debug.LogError($"AI 控制器 '{this.name}' 未在 Inspector 中指定 'Battle Actions' ScriptableObject！AI 無法行動。");
            BattleLog.Instance.AddLog("錯誤：敵人 AI 配置不完整，無法行動。");
            return;
        }
        Debug.Log($"<color=purple>===== AI TURN {turnCount} PLANNING (Personality: {personality?.name ?? "Fallback"}) =====</color>");
        
        if (personality != null)
        {
            ExecuteSmartAI(personality, selfUnits, opponentUnits, planner, rules, turnCount);
        }
        else
        {
            Debug.Log("<color=orange>No personality assigned for this encounter. Using simple fallback AI.</color>");
            ExecuteSimpleFallbackAI(selfUnits, opponentUnits, planner, rules);
        }
        
        Debug.Log($"<color=purple>===== AI TURN PLANNING COMPLETE =====</color>");
        BattleLog.Instance.AddLog("敵人已完成行動規劃。");
    }
    
    #region 智能AI邏輯
    private void ExecuteSmartAI(AIPersonalitySO personality, List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules, int turnCount)
    {
        var staminaTracker = selfUnits.Where(u => !u.IsDead).ToDictionary(u => (IBattleUnit_ReadOnly)u, u => u.CurrentStamina);
        var context = new AIContext(selfUnits, opponentUnits, turnCount);
        foreach (var actor in selfUnits.Where(u => !u.IsDead).OrderBy(u => u.Role))
        {
            int maxActions = (actor.Role == BattleRole.Vanguard) ? 4 : 2;
            int actionsPlannedByThisUnit = 0;

            while(actionsPlannedByThisUnit < maxActions)
            {
                int currentPhaseIndex = actionsPlannedByThisUnit + 1;
                Debug.Log($"\n--- Planning action #{actionsPlannedByThisUnit + 1} for '{actor.UnitName}' (Phase: {currentPhaseIndex}) ---");

                var candidateActions = GenerateCandidateActions(actor, rules, staminaTracker[actor], currentPhaseIndex);
                if (!candidateActions.Any())
                {
                    Debug.Log($"  - Unit '{actor.UnitName}' has no candidate actions for this turn. Breaking loop.");
                    break;
                }

                var allPossibleActions = new List<ScoredAction>();
                foreach (var action in candidateActions)
                {
                    var logBuilder = new StringBuilder();
                    float totalScore = CalculateScoreForAction(personality, action, actor, context, logBuilder);
                    allPossibleActions.Add(new ScoredAction(action, totalScore, logBuilder.ToString()));
                }

                if (allPossibleActions.Any())
                {
                    var bestAction = allPossibleActions.OrderByDescending(sa => sa.Score).First();
                    
                    foreach (var scoredAction in allPossibleActions.OrderByDescending(sa => sa.Score))
                    {
                        bool isWinner = (scoredAction == bestAction);
                        string color = isWinner ? "lime" : "grey";
                        Debug.Log($"<color={color}>{scoredAction.Log}</color>");
                    }
                    Debug.Log($"<b><color=lime>  >> WINNER for {actor.UnitName}'s action: {FormatActionPlan(bestAction.Plan)} with Score: {bestAction.Score:F2}</color></b>");
                    
                    planner.AddPlan(bestAction.Plan, -1);
                    
                    if (staminaTracker.ContainsKey(actor))
                    {
                        staminaTracker[actor] = CalculateResultingStamina(staminaTracker[actor], bestAction.Plan);
                    }
                }
                else
                {
                    Debug.LogWarning($"No valid actions were found for '{actor.UnitName}'.");
                }
                actionsPlannedByThisUnit++;
            }
        }
    }
    #endregion

    #region 評分核心邏輯
    private float CalculateScoreForAction(AIPersonalitySO personality, ActionPlan action, IBattleUnit_ReadOnly actor, AIContext context, StringBuilder logBuilder)
    {
        float totalScore = 0f;
        logBuilder.AppendLine($"  Evaluating action for '{actor.UnitName}': <b>{FormatActionPlan(action)}</b>");

        if (action.Type == ActionType.Exchange && action.Target != null)
        {
            logBuilder.AppendLine("    (Exchange action - scoring both participants)");
            float actorTacticScore = GetScoreFromTactics(personality, action, actor, context, logBuilder, "Actor");
            float targetTacticScore = GetScoreFromTactics(personality, action, action.Target, context, logBuilder, "Target");
            float actorPositionalBonus = GetPositionalBonusScore(action, actor);
            float targetPositionalBonus = GetPositionalBonusScore(action, action.Target);

            if (actorPositionalBonus != 0) logBuilder.AppendLine($"    - [Universal] Positional Bonus (Actor): {actorPositionalBonus:F2}");
            if (targetPositionalBonus != 0) logBuilder.AppendLine($"    - [Universal] Positional Bonus (Target): {targetPositionalBonus:F2}");
            
            totalScore = actorTacticScore + targetTacticScore + actorPositionalBonus + targetPositionalBonus;
        }
        else
        {
            float scoreFromTactics = GetScoreFromTactics(personality, action, actor, context, logBuilder, "Actor");
            float positionalBonus = GetPositionalBonusScore(action, actor);
            if (positionalBonus != 0) logBuilder.AppendLine($"    - [Universal] Positional Bonus: {positionalBonus:F2}");
            
            totalScore = scoreFromTactics + positionalBonus;
        }

        logBuilder.AppendLine($"    <color=#ADD8E6>  -> Subtotal Score: {totalScore:F2}</color>");
        return totalScore;
    }
    
    private float GetScoreFromTactics(AIPersonalitySO personality, ActionPlan action, IBattleUnit_ReadOnly unit, AIContext context, StringBuilder logBuilder, string participantLabel)
    {
        float score = 0f;
        var strategy = personality.GetStrategyForRole(unit.Role);
        if (strategy == null) return 0f;

        foreach (var tactic in strategy.tactics)
        {
            foreach (var scorer in tactic.scoringModifiers)
            {
                float singleScore = scorer.CalculateScore(action, unit, context);
                if (singleScore != 0)
                {
                    score += singleScore;
                    logBuilder.AppendLine($"    - ({participantLabel}) Tactic '{tactic.name}' -> Scorer '{scorer.name}': {singleScore:F2}");
                }
            }
        }
        return score;
    }
    #endregion

    #region 通用位置評分功能
    private float GetPositionalBonusScore(ActionPlan action, IBattleUnit_ReadOnly actor)
    {
        if (actor == null) return 0f;

        switch (actor.Role)
        {
            case BattleRole.Vanguard:
                if (actor.AttackRange >= 2)
                {
                    switch (action.Type)
                    {
                        case ActionType.Attack: return 20f;
                        case ActionType.Defend: return 20f;
                        case ActionType.Exchange:
                            if (action.Target != null && action.Target.Role == BattleRole.Ranged1)
                                return 50f;
                            break;
                    }
                }
                break;

            case BattleRole.Ranged1:
                if (actor.AttackRange == 1)
                {
                    switch (action.Type)
                    {
                        case ActionType.Attack: return -50f;
                        case ActionType.Exchange:
                            if (action.Target != null)
                            {
                                if (action.Target.Role == BattleRole.Vanguard) return 50f;
                                if (action.Target.Role == BattleRole.Ranged2) return -100f;
                            }
                            break;
                    }
                }
                break;

            case BattleRole.Ranged2:
                if (actor.AttackRange <= 2)
                {
                     switch (action.Type)
                    {
                        case ActionType.Attack: return -50f;
                        case ActionType.Exchange:
                            if (action.Target != null && action.Target.Role == BattleRole.Ranged1)
                                return 50f;
                            break;
                    }
                }
                break;
        }
        return 0f;
    }
    #endregion

    #region AI 輔助方法
    private List<ActionPlan> GenerateCandidateActions(BattleUnit actor, BattleRules rules, int currentStamina, int phaseIndex)
    {
        var candidates = new List<ActionPlan>();
        var allUnitsSnap = BattleManager.Instance.GetAllUnits().Select(u => new CharacterStateRule.UnitStateSnapshot(u)).ToList();
        var context = new CharacterStateRule.BattleStateSnapshot(allUnitsSnap, null);

        if (currentStamina >= battleActions.GetAttackStaminaCost())
        {
            var attackTargets = rules.GetValidTargets(actor, context.UnitSnapshots);
            foreach (var target in attackTargets)
                candidates.Add(ActionPlan.CreateAIAction(actor, target.CurrentPosition, ActionType.Attack, phaseIndex, actor.Role));
        }
        candidates.Add(ActionPlan.CreateNoTargetAction(actor, ActionType.Defend, phaseIndex, actor.Role));
        candidates.Add(ActionPlan.CreateNoTargetAction(actor, ActionType.Rest, phaseIndex, actor.Role));
        
        if (currentStamina >= battleActions.GetExchangeStaminaCost())
        {
            var exchangeTargets = rules.GetValidExchangeTargets(actor, context.UnitSnapshots);
            foreach(var target in exchangeTargets)
                candidates.Add(ActionPlan.CreatePlayerAction(actor, target, ActionType.Exchange, phaseIndex, actor.Role));
        }
        
        return candidates;
    }
    
    private int CalculateResultingStamina(int currentStamina, ActionPlan plan)
    {
        switch (plan.Type)
        {
            case ActionType.Attack: return currentStamina - battleActions.GetAttackStaminaCost();
            case ActionType.Rest: return Mathf.Min(plan.Source.MaxStamina, currentStamina + battleActions.GetRestStaminaRecovery());
            case ActionType.Exchange: return currentStamina - battleActions.GetExchangeStaminaCost();
            case ActionType.Skill: return (plan.SkillUsed != null) ? currentStamina - plan.SkillUsed.staminaCost : currentStamina;
            default: return currentStamina;
        }
    }
    
    private string FormatActionPlan(ActionPlan plan)
    {
        if (plan == null) return "NULL PLAN";
        if (plan.Source == null) return "Empty Action";
        string sourceName = plan.Source.UnitName;
        string actionName = plan.Type.ToActionName();
        string targetName = "N/A";
        if (plan.Target != null)
        {
            targetName = plan.Target.UnitName;
        }
        else if (plan.TargetPosition != GridPosition.None)
        {
            var unitAtPos = BattleManager.Instance?.GetUnitAtPosition(plan.TargetPosition);
            targetName = unitAtPos != null ? unitAtPos.UnitName : plan.TargetPosition.ToString();
        }
        return $"{sourceName} -> {actionName} -> {targetName}";
    }
    #endregion

    #region 通用後備 AI
    private void ExecuteSimpleFallbackAI(List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules) 
    {
        foreach (var unit in selfUnits.Where(u => !u.IsDead))
        {
            int maxActions = (unit.Role == BattleRole.Vanguard) ? 4 : 2;
            int actionsPlanned = 0;
            int currentStamina = unit.CurrentStamina;
            int attackCost = (this.battleActions != null) ? this.battleActions.GetAttackStaminaCost() : 3;
            while (actionsPlanned < maxActions)
            {
                int phaseIndex = actionsPlanned + 1; 
                var allUnitsSnap = BattleManager.Instance.GetAllUnits().Select(u => new CharacterStateRule.UnitStateSnapshot(u)).ToList();
                var targets = rules.GetValidTargets(unit, allUnitsSnap);
                if (targets.Any() && currentStamina >= attackCost)
                {
                    planner.AddPlan(ActionPlan.CreateAIAction(unit, targets.First().CurrentPosition, ActionType.Attack, phaseIndex, unit.Role), -1);
                    currentStamina -= attackCost;
                }
                else
                {
                    planner.AddPlan(ActionPlan.CreateNoTargetAction(unit, ActionType.Defend, phaseIndex, unit.Role), -1);
                }
                actionsPlanned++;
            }
        }
    }
    #endregion
}
```

2. `AIPersonalitySO.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class PositionalStrategy
{
    [Tooltip("此位置單位在決策時會參考的所有戰術文件。")]
    public List<AITacticSO> tactics;
}

[CreateAssetMenu(fileName = "NewAIPersonality", menuName = "Battle System/AI/AI Personality")]
public class AIPersonalitySO : ScriptableObject
{
    [Header("各位置戰術文件夾")]
    [Tooltip("前衛單位的戰術文件。")]
    public PositionalStrategy vanguardStrategy;

    [Tooltip("遠程1號位單位的戰術文件。")]
    public PositionalStrategy ranged1Strategy;

    [Tooltip("遠程2號位單位的戰術文件。")]
    public PositionalStrategy ranged2Strategy;
    
    [Tooltip("後勤單位的戰術文件 (主要用於指揮官技能)。")]
    public PositionalStrategy supportStrategy;

    public PositionalStrategy GetStrategyForRole(BattleRole role)
    {
        switch (role)
        {
            case BattleRole.Vanguard: return vanguardStrategy;
            case BattleRole.Ranged1:  return ranged1Strategy;
            case BattleRole.Ranged2:  return ranged2Strategy;
            case BattleRole.Support:  return supportStrategy;
            default:                  return null;
        }
    }
}
```

3. `AITacticSO.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewAITactic", menuName = "Battle System/AI/AI Tactic")]
public class AITacticSO : ScriptableObject
{
    [Header("評分策略 (參謀列表)")]
    [Tooltip("此戰術文件包含的所有評分參謀。AI 會綜合所有參謀的意見。")]
    public List<SM_BaseSO> scoringModifiers;
}
```

4. `SM_BaseSO.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

public class AIContext
{
    public readonly List<BattleUnit> SelfTeam;
    public readonly List<BattleUnit> OpponentTeam;
    public readonly int TurnCount;

    public AIContext(List<BattleUnit> self, List<BattleUnit> opponents, int turn)
    {
        SelfTeam = self;
        OpponentTeam = opponents;
        TurnCount = turn;
    }
}

public abstract class SM_BaseSO : ScriptableObject
{
    [Tooltip("此評分規則的權重，會乘以計算出的分數。")]
    public float weight = 1.0f;
    public abstract float CalculateScore(ActionPlan candidateAction, IBattleUnit_ReadOnly actor, AIContext context);
}
```

5. `SM_MultiCondSO.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[System.Serializable]
public class StatCondition
{
    public enum StatType { HealthPercent, Stamina, AttackRange }

    public StatType stat;
    [Tooltip("條件檢查的值範圍 (X: 最小值, Y: 最大值)。例如血量在 20% 到 60% 之間，就填 (0.2, 0.6)。")]
    public Vector2 valueRange = new Vector2(0, 1);

    public bool IsMet(IBattleUnit_ReadOnly actor)
    {
        if (actor == null) return false;

        float subjectValue = 0;
        switch (stat)
        {
            case StatType.HealthPercent:
                subjectValue = (actor.MaxHP > 0) ? (float)actor.CurrentHP / actor.MaxHP : 0;
                break;
            case StatType.Stamina:
                subjectValue = actor.CurrentStamina;
                break;
            case StatType.AttackRange:
                subjectValue = actor.AttackRange;
                break;
        }
        return subjectValue >= valueRange.x && subjectValue <= valueRange.y;
    }
}

[System.Serializable]
public class ActionScore
{
    public ActionType action;
    public float scoreAdjustment;
}

[CreateAssetMenu(fileName = "SM_MultiCond", menuName = "Battle System/AI/Scorer/Multi-Condition Scorer")]
public class SM_MultiCondSO : SM_BaseSO
{
    [Header("觸發條件 (必須全部滿足)")]
    public List<StatCondition> conditions;

    [Header("滿足條件後的分數調整")]
    public List<ActionScore> scores;

    public override float CalculateScore(ActionPlan candidateAction, IBattleUnit_ReadOnly actor, AIContext context)
    {
        // 1. 檢查所有條件是否都對行動者(actor)滿足
        foreach (var condition in conditions)
        {
            if (!condition.IsMet(actor))
            {
                return 0;
            }
        }

        // 2. 如果所有條件都滿足，則查找對應行動的分數
        var scoreEntry = scores.FirstOrDefault(s => s.action == candidateAction.Type);
        if (scoreEntry != null)
        {
            return scoreEntry.scoreAdjustment * weight;
        }
        return 0;
    }
}
```

6. `SM_OutcomeSO.cs`
```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "SM_Outcome", menuName = "Battle System/AI/Scorer/Outcome Prediction Scorer")]
public class SM_OutcomeSO : SM_BaseSO
{
    [Header("後果評分")]
    [Tooltip("如果此行動能擊殺目標，給予的分數。")]
    public float killTargetScore = 200f;
    
    [Tooltip("如果執行此行動會導致自己死亡（例如反傷），給予的負分。")]
    public float actorDiesScore = -500f;

    public override float CalculateScore(ActionPlan candidateAction, IBattleUnit_ReadOnly actor, AIContext context)
    {
        if (candidateAction.Type != ActionType.Attack || candidateAction.Target == null)
        {
            return 0;
        }
        if (candidateAction.Target.CurrentHP <= actor.CurrentAttack)
        {
            return killTargetScore * weight;
        }
        return 0;
    }
}
```

7. `SM_CommanderSkillSO.cs`
```csharp
using UnityEngine;
using System.Linq;

[CreateAssetMenu(fileName = "SM_CommanderSkill", menuName = "Battle System/AI/Scorer/Commander Skill Scorer")]
public class SM_CommanderSkillSO : SM_BaseSO
{
    public enum CommanderSkillType { Attack, Defend, Heal, Buff_Debuff }

    [Header("技能評估")]
    [Tooltip("此評分器針對的指揮官技能類型")]
    public CommanderSkillType skillType;
    
    [Tooltip("基礎分數")]
    public float baseScore = 50f;

    [Header("觸發條件與加成")]
    [Tooltip("當敵方團隊平均血量低於此值時，觸發分數加成 (適用於攻擊型技能)")]
    [Range(0,1)] public float enemyHealthThreshold = 0.5f;
    public float enemyHealthBonusScore = 100f;
    
    [Tooltip("當我方團隊平均血量低於此值時，觸發分數加成 (適用於防禦/治療型技能)")]
    [Range(0,1)] public float selfHealthThreshold = 0.5f;
    public float selfHealthBonusScore = 100f;

    [Tooltip("當回合數大於此值時，觸發分數加成 (用於後期決戰)")]
    public int turnThreshold = 5;
    public float lateGameBonusScore = 75f;
    
    public override float CalculateScore(ActionPlan candidateAction, IBattleUnit_ReadOnly actor, AIContext context)
    {
        if (candidateAction.SkillUsed == null || !candidateAction.SkillUsed.isCommanderSkill_OneTimeUse)
        {
            return 0;
        }
        float score = baseScore;
        switch (skillType)
        {
            case CommanderSkillType.Attack:
                if (GetAverageHealth(context.OpponentTeam) < enemyHealthThreshold)
                    score += enemyHealthBonusScore;
                break;
            case CommanderSkillType.Defend:
            case CommanderSkillType.Heal:
                if (GetAverageHealth(context.SelfTeam) < selfHealthThreshold)
                    score += selfHealthBonusScore;
                break;
        }
        
        if (context.TurnCount > turnThreshold)
        {
            score += lateGameBonusScore;
        }

        return score * weight;
    }

    private float GetAverageHealth(System.Collections.Generic.List<BattleUnit> team)
    {
        if (team == null || team.Count == 0) return 0;
        var alive = team.Where(u => !u.IsDead).ToList();
        if (alive.Count == 0) return 0;
        return alive.Sum(u => (float)u.CurrentHP) / alive.Sum(u => (float)u.MaxHP);
    }
}
```