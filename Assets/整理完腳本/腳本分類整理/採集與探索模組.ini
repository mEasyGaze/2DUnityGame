### **探索系統(Exploration System Module)**

1. LootTableSO.cs(ScriptableObject)：
(1) 基本屬性：掉落物(數量)、掉落機率。

2. ResourceNode.cs(資源點採集)：
(1) 代表地圖上所有可重複採集的資源點，如礦脈、草藥叢、伐木堆等。
(2) 數據配置：採集可能獲得物品及其概率、玩家必須擁有此工具(物品ID)（如稿子、斧頭）才能採集、採集所需的秒數(驅動`行動條`)、資源點枯竭後的重生時間(遊戲天數或秒數)。
(3) 狀態管理：Depleted (枯竭) 狀態下，物件的視覺表現會改變（例如，礦脈變暗，草藥變禿），並且暫時不可交互。
(4) 交互邏輯：如果滿足條件，則通知 ExplorationUIManager 顯示一個進度條；進度條滿後，從 lootTable 中隨機抽取獎勵並給予玩家，然後將自身狀態設為 Depleted 並開始重生計時。

3. LootContainer.cs(可搜刮容器)：
(1) 代表一次性的可搜刮容器，如寶箱、木桶、書架等。
(2) 數據配置：一個固定的物品列表(定義了容器內的物品和數量)、是否上鎖、需要用來解鎖的鑰匙物品ID、搜刮所需的秒數。
(3) 狀態管理：確保只能被搜刮一次、搜刮後，視覺表現會改變（例如，寶箱蓋子打開）。
(4) 交互邏輯：如果上鎖，檢查玩家背包中是否有對應的鑰匙；如果解鎖或無需鑰匙，則顯示進度條；進度條滿後，將所有物品添加到玩家背包，並使物件永久不可交互。

4. PuzzleMechanism.cs(解謎機關)：
(1) 各種直接交互的機關，如拉桿、按鈕、壓力板。
(2) 事件廣播：當機關被觸發時，這個事件會被調用。
(3) 狀態切換：可以配置為一次性觸發或可重複切換狀態、觸發時播放對應的動畫和音效(動畫和音效屬於未來工作)。

5. InteractableBarrier.cs(可交互障礙物)：
(1) 特定物品才能移除的障礙物，如被藤蔓覆蓋的洞口、脆弱的牆壁。
(2) 數據配置：移除障礙物所需的物品ID、決定使用後是否消耗該物品、
(3) 交互邏輯：檢查玩家是否擁有物品ID，如果有播放移除動畫（如藤蔓被砍斷），如果 consumeItem 為 true 則從玩家背包中移除一個物品，然後銷毀自身或禁用交互；如果沒有顯示缺少物品。

6. ExplorationUIManager.cs(探索UI管理器)：
(1) 管理所有與探索相關的臨時UI元素，主要是進度條。
(2) 觸發 1~4 的交互邏輯，並更新`進度條`，當進度條填滿時，觸發實際的獎勵發放邏輯。

7. ExploreProgressBar.cs(進度條)：
(1) 顯示進度條，並根據玩家的進度進行動畫和音效的播放。
(2) 事件廣播：當進度條填滿時，這個事件會被調用，並觸發實際的獎勵發放邏輯。

---

### **腳本**

#### 1. `LootTableSO.cs`
```
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class LootDropItem
{
    public Item item;
    [Range(0f, 1f)]
    public float dropChance = 1f;
    public int minQuantity = 1;
    public int maxQuantity = 1;
}

public struct LootResult
{
    public List<Item> items;
    public int money;
}

[CreateAssetMenu(fileName = "NewLootTable", menuName = "Exploration/Loot Table")]
public class LootTableSO : ScriptableObject
{
    [Header("金錢掉落設定")]
    [Range(0f, 1f)]
    [Tooltip("掉落金錢的總體機率")]
    public float moneyDropChance = 0.5f;
    public int minMoney = 5;
    public int maxMoney = 20;

    [Header("物品掉落設定")]
    [Tooltip("定義所有可能掉落的物品及其各自的機率")]
    public List<LootDropItem> possibleItems = new List<LootDropItem>();

    public LootResult GetLoot()
    {
        LootResult result = new LootResult
        {
            items = new List<Item>(),
            money = 0
        };

        if (Random.value <= moneyDropChance)
        {
            result.money = Random.Range(minMoney, maxMoney + 1);
        }
        foreach (var drop in possibleItems)
        {
            if (Random.value <= drop.dropChance)
            {
                int quantity = Random.Range(drop.minQuantity, drop.maxQuantity + 1);
                for (int i = 0; i < quantity; i++)
                {
                    result.items.Add(drop.item);
                }
            }
        }
        return result;
    }
}
```

#### 2. `ResourceNode.cs`
```
using UnityEngine;
using System.Collections;

[System.Serializable]
public class ResourceNodeState
{
    public bool isDepleted;
    public float respawnTimer;
}

[RequireComponent(typeof(Collider2D))]
[RequireComponent(typeof(UniqueObjectIdentifier))]
public class ResourceNode : MonoBehaviour, IInteractable, ISceneSaveable
{
    [Header("資源配置")]
    [SerializeField] private LootTableSO lootTable;
    [SerializeField] private string requiredToolID;
    [SerializeField] private float gatheringTime = 3f;

    [Header("重生設定")]
    [SerializeField] private float respawnTimeInSeconds = 60f;

    [Header("視覺狀態")]
    [SerializeField] private GameObject activeVisual;
    [SerializeField] private GameObject depletedVisual;
    [SerializeField] private string actionText = "採集中...";

    [Header("掉落設定")]
    [SerializeField] private float spawnRadius = 1.0f;
    
    [Header("事件廣播")]
    [Tooltip("當此類型的資源【首次】被成功採集時，廣播此事件ID。留空則不廣播。")]
    [SerializeField] private string onFirstGatherCompleteEventID;

    private bool isDepleted = false;
    private float currentRespawnTimer = 0f;
    private static bool hasAnyNodeOfTypeBroadcasted = false;

    void Start()
    {
        if (!isDepleted)
        {
            SetState(false);
        }
    }

    public void Interact()
    {
        if (isDepleted)
        {
            Debug.Log("這個資源點已經枯竭了。");
            return;
        }

        if (!string.IsNullOrEmpty(requiredToolID))
        {
            Item tool = ItemDatabase.Instance.GetItemByID(requiredToolID);
            if (tool == null || !InventoryManager.Instance.HasItem(tool))
            {
                Debug.Log($"缺少必要的工具: {tool?.itemName ?? requiredToolID}");
                return;
            }
        }
        
        Transform targetTransform = (activeVisual != null && activeVisual.activeInHierarchy) ? activeVisual.transform : this.transform;
        ExplorationUIManager.Instance.StartProgressBar(targetTransform, gatheringTime, OnGatheringComplete, actionText);
    }

    private void OnGatheringComplete()
    {
        if (isDepleted) return;
        if (!string.IsNullOrEmpty(onFirstGatherCompleteEventID) && !hasAnyNodeOfTypeBroadcasted)
        {
            GameEventManager.Instance.TriggerEvent(onFirstGatherCompleteEventID);
            hasAnyNodeOfTypeBroadcasted = true;
        }

        LootResult loot = lootTable.GetLoot();
        
        Vector3 spawnCenter = (activeVisual != null && activeVisual.activeInHierarchy) 
                            ? activeVisual.transform.position 
                            : this.transform.position;

        foreach(var item in loot.items)
        {
            Vector2 offset = Random.insideUnitCircle * spawnRadius;
            Vector3 spawnPosition = spawnCenter + (Vector3)offset;
            InventoryManager.Instance.SpawnGroundItem(item, 1, spawnPosition);
        }
        if (loot.money > 0) PlayerState.Instance.AddMoney(loot.money);
        
        Debug.Log($"採集完成！獲得 {loot.items.Count} 件物品和 {loot.money} 金錢。");
        
        SetState(true);
        StartCoroutine(RespawnCoroutine());
    }

    private void SetState(bool depleted)
    {
        isDepleted = depleted;
        if (activeVisual != null) activeVisual.SetActive(!depleted);
        if (depletedVisual != null) depletedVisual.SetActive(depleted);
    }

    private IEnumerator RespawnCoroutine()
    {
        currentRespawnTimer = respawnTimeInSeconds;
        while (currentRespawnTimer > 0)
        {
            currentRespawnTimer -= Time.deltaTime;
            yield return null;
        }
        currentRespawnTimer = 0;
        SetState(false);
    }
    
    private IEnumerator RespawnFromSave()
    {
        while (currentRespawnTimer > 0)
        {
            currentRespawnTimer -= Time.deltaTime;
            yield return null;
        }
        currentRespawnTimer = 0;
        SetState(false);
    }

    #region 存檔資料
    public object CaptureState()
    {
        return new ResourceNodeState
        {
            isDepleted = this.isDepleted,
            respawnTimer = this.currentRespawnTimer
        };
    }

    public void RestoreState(object stateData)
    {
        if (stateData is string stateJson)
        {
            var state = JsonUtility.FromJson<ResourceNodeState>(stateJson);
            
            this.isDepleted = state.isDepleted;
            this.currentRespawnTimer = state.respawnTimer;
            
            SetState(this.isDepleted);
            
            if (this.isDepleted && this.currentRespawnTimer > 0)
            {
                StartCoroutine(RespawnFromSave());
            }
        }
        else
        {
            Debug.LogError($"[ResourceNode] RestoreState 接收到的數據類型錯誤，期望為 string，實際為 {stateData.GetType()}");
        }
    }
    #endregion
}
```

#### 3. `LootContainer.cs`
```
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class LootContainerState
{
    public bool hasBeenLooted;
}

[RequireComponent(typeof(Collider2D))]
[RequireComponent(typeof(UniqueObjectIdentifier))]
public class LootContainer : MonoBehaviour, IInteractable, ISceneSaveable
{
    [Header("容器內容")]
    [Tooltip("定義容器內固定的物品和數量")]
    [SerializeField] private List<ItemReward> fixedLoot = new List<ItemReward>();

    [Header("交互設定")]
    [SerializeField] private float searchTime = 2f;
    [SerializeField] private bool isLocked = false;
    [Tooltip("如果上鎖，需要用來解鎖的鑰匙物品ID")]
    [SerializeField] private string keyItemID;

    [Header("狀態與視覺")]
    [SerializeField] private Sprite openedSprite;
    [SerializeField] private string actionText = "搜刮中...";

    [Header("掉落設定")]
    [Tooltip("物品掉落在容器周圍的擴散半徑")]
    [SerializeField] private float spawnRadius = 1.0f;

    private bool hasBeenLooted = false;
    private SpriteRenderer spriteRenderer;

    void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
    }

    public void Interact()
    {
        if (hasBeenLooted) return;

        if (isLocked)
        {
            Item key = ItemDatabase.Instance.GetItemByID(keyItemID);
            if (key == null || !InventoryManager.Instance.HasItem(key))
            {
                Debug.Log("這個容器是鎖著的，需要對應的鑰匙。");
                return;
            }
        }
        ExplorationUIManager.Instance.StartProgressBar(this.transform, searchTime, OnSearchComplete, actionText);
    }

    private void OnSearchComplete()
    {
        if (hasBeenLooted) return;
        hasBeenLooted = true;
        
        Vector3 spawnCenter = this.transform.position;

        foreach (var reward in fixedLoot)
        {
            Item item = ItemDatabase.Instance.GetItemByID(reward.itemID);
            if (item != null)
            {
                Vector2 offset = Random.insideUnitCircle * spawnRadius;
                Vector3 spawnPosition = spawnCenter + (Vector3)offset;

                InventoryManager.Instance.SpawnGroundItem(item, reward.amount, spawnPosition);
            }
        }
        Debug.Log($"從 {gameObject.name} 中搜刮了 {fixedLoot.Count} 種物品，它們已掉落在周圍。");
        ApplyLootedStateVisuals();
    }

    private void ApplyLootedStateVisuals()
    {
        if (spriteRenderer != null && openedSprite != null)
        {
            spriteRenderer.sprite = openedSprite;
        }
        var collider = GetComponent<Collider2D>();
        if(collider != null) collider.enabled = false;
    }

    #region 存檔資料
    public object CaptureState()
    {
        return new LootContainerState
        {
            hasBeenLooted = this.hasBeenLooted
        };
    }

    public void RestoreState(object stateData)
    {
        if (stateData is string stateJson)
        {
            var state = JsonUtility.FromJson<LootContainerState>(stateJson);
            
            this.hasBeenLooted = state.hasBeenLooted;
            
            if (this.hasBeenLooted)
            {
                if (spriteRenderer != null && openedSprite != null)
                {
                    spriteRenderer.sprite = openedSprite;
                }
                var collider = GetComponent<Collider2D>();
                if(collider != null) collider.enabled = false;
            }
        }
        else
        {
            Debug.LogError($"[LootContainer] RestoreState 接收到的數據類型錯誤，期望為 string，實際為 {stateData.GetType()}");
        }
    }
    #endregion
}
```

#### 4. `PuzzleMechanism.cs`
```
using UnityEngine;
using UnityEngine.Events;

[System.Serializable]
public class PuzzleMechanismState
{
    public bool isActive;
    public bool hasBeenUsed;
}

[RequireComponent(typeof(Collider2D))]
[RequireComponent(typeof(UniqueObjectIdentifier))] // 確保有 ID
public class PuzzleMechanism : MonoBehaviour, IInteractable, ISceneSaveable
{
    public enum TriggerType{Toggle, ActivateOnly, DeactivateOnly, TriggerEveryTime}

    [Header("機關行為設定")]
    [Tooltip("選擇此機關的交互行為模式")]
    [SerializeField] private TriggerType triggerType = TriggerType.Toggle;
    [Tooltip("勾選此項，機關在遊戲開始時處於 '激活' 狀態")]
    [SerializeField] private bool startsActive = false;

    [Header("狀態視覺化")]
    [Tooltip("當機關處於 '激活' 狀態時顯示的物件 (例如：亮的燈)")]
    [SerializeField] private GameObject activeVisual;
    [Tooltip("當機關處於 '未激活' 狀態時顯示的物件 (例如：暗的燈)")]
    [SerializeField] private GameObject inactiveVisual;

    [Header("觸發事件")]
    [Tooltip("當機關被 '激活' (開啟) 時觸發")]
    public UnityEvent onActivate;
    [Tooltip("當機關被 '取消激活' (關閉) 時觸發")]
    public UnityEvent onDeactivate;

    // --- 未來工作 ---
    // [Header("音效")]
    // [SerializeField] private AudioClip activateSound;
    // [SerializeField] private AudioClip deactivateSound;
    // private AudioSource audioSource;

    private bool isActive;
    private bool hasBeenUsed = false;

    void Start()
    {
        if (!SaveManager.Instance)
        {
            isActive = startsActive;
            UpdateVisualState();
        }
        else if (!hasBeenUsed){}
        UpdateVisualState();
    }

    public void Interact()
    {
        switch (triggerType)
        {
            case TriggerType.Toggle:
                ToggleState();
                break;

            case TriggerType.ActivateOnly:
                if (!hasBeenUsed && !isActive)
                {
                    Activate();
                    hasBeenUsed = true;
                }
                break;

            case TriggerType.DeactivateOnly:
                if (!hasBeenUsed && isActive)
                {
                    Deactivate();
                    hasBeenUsed = true;
                }
                break;

            case TriggerType.TriggerEveryTime:
                Debug.Log($"觸發了重複性機關: {gameObject.name}");
                onActivate.Invoke();
                // PlaySound(activateSound);
                break;
        }
    }

    private void ToggleState()
    {
        if (isActive) Deactivate();
        else Activate();
    }

    private void Activate()
    {
        isActive = true;
        onActivate.Invoke();
        UpdateVisualState();
    }

    private void Deactivate()
    {
        isActive = false;
        onDeactivate.Invoke();
        UpdateVisualState();
    }

    private void UpdateVisualState()
    {
        if (activeVisual != null) activeVisual.SetActive(isActive);
        if (inactiveVisual != null) inactiveVisual.SetActive(!isActive);
    }
    
    // 輔助方法：播放音效 (未來工作)
    // private void PlaySound(AudioClip clip)
    // {
    //     if (audioSource != null && clip != null)
    //     {
    //         audioSource.PlayOneShot(clip);
    //     }
    // }

    #region ISceneSaveable
    public object CaptureState()
    {
        return new PuzzleMechanismState
        {
            isActive = this.isActive,
            hasBeenUsed = this.hasBeenUsed
        };
    }

    public void RestoreState(object stateData)
    {
        if (stateData is string stateJson)
        {
            var state = JsonUtility.FromJson<PuzzleMechanismState>(stateJson);
            this.isActive = state.isActive;
            this.hasBeenUsed = state.hasBeenUsed;
            UpdateVisualState();
        }
    }
    #endregion
}
```

#### 5. `InteractableBarrier.cs`
```
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(Collider2D))]
[RequireComponent(typeof(UniqueObjectIdentifier))]
public class InteractableBarrier : MonoBehaviour, IInteractable
{  
    [Header("移除設定")]
    [SerializeField] private string requiredItemID;
    [SerializeField] private bool consumeItem = true;
    [SerializeField] private float removalTime = 1.5f;
    [SerializeField] private string actionText = "移除中...";

    private bool isBeingRemoved = false; 
    
    public void Interact()
    {
        if (isBeingRemoved) return;
        Item requiredItem = ItemDatabase.Instance.GetItemByID(requiredItemID);
        if (requiredItem == null)
        {
            Debug.LogError($"在物品資料庫中找不到ID為 {requiredItemID} 的物品！");
            return;
        }

        if (InventoryManager.Instance.HasItem(ItemDatabase.Instance.GetItemByID(requiredItemID)))
        {
            isBeingRemoved = true;
            if (removalTime > 0)
            {
                ExplorationUIManager.Instance.StartProgressBar(this.transform, removalTime, OnRemovalComplete, actionText);
            }
            else
            {
                OnRemovalComplete();
            }
        }
        else
        {
            Debug.Log($"缺少 {requiredItem.itemName} 來移除這個障礙物。");
        }
    }

    private void OnRemovalComplete()
    {
        Item requiredItem = ItemDatabase.Instance.GetItemByID(requiredItemID);
        if (requiredItem == null || !InventoryManager.Instance.HasItem(requiredItem)) 
        {
            isBeingRemoved = false;
            return;
        }
        Debug.Log($"使用物品移除了障礙物 {gameObject.name}");
        if (consumeItem)
        {
            InventoryManager.Instance.RemoveItem(requiredItem, 1);
        }
        
        var identifier = GetComponent<UniqueObjectIdentifier>();
        if (identifier != null && ScenePersistenceManager.Instance != null)
        {
            ScenePersistenceManager.Instance.RecordObjectDestruction(identifier.ID);
        }
        Destroy(gameObject); 
    }
}
```

#### 6. `ExplorationUIManager.cs`
```
using UnityEngine;
using System;
using UnityEngine.SceneManagement;

public class ExplorationUIManager : MonoBehaviour
{
    public static ExplorationUIManager Instance { get; private set; }

    [Header("UI 預製件")]
    [SerializeField] private ExploreProgressBar progressBarPrefab;
    
    [Header("UI 畫布標籤")]
    [Tooltip("請確保您場景中的主UI畫布(Canvas)被設置了這個標籤(Tag)")]
    [SerializeField] private string uiCanvasTag = "UICanvas";
    private Canvas parentCanvas;

    [Header("定位設定")]
    [Tooltip("進度條相對於目標物件的屏幕位置偏移量 (像素)")]
    [SerializeField] private Vector2 positionOffset = new Vector2(0, 50f);

    private ExploreProgressBar activeProgressBar;
    private Action onProgressCompleteCallback;
    public bool IsProgressBarActive { get; private set; } = false;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
        FindCanvas();
    }

    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        Debug.Log($"[ExplorationUIManager] 偵測到新場景 '{scene.name}' 已加載，正在重新尋找Canvas...");
        FindCanvas();
    }
    
    private void FindCanvas()
    {
        GameObject canvasGO = GameObject.FindWithTag(uiCanvasTag);
        if (canvasGO != null)
        {
            parentCanvas = canvasGO.GetComponent<Canvas>();
            if (parentCanvas == null)
            {
                Debug.LogError($"[ExplorationUIManager] 找到了帶有 '{uiCanvasTag}' 標籤的物件，但它上面沒有 Canvas 組件！");
            }
        }
        else
        {
            Debug.LogError($"[ExplorationUIManager] 在場景中找不到帶有 '{uiCanvasTag}' 標籤的 Canvas！請檢查您的場景設置。");
        }
    }

    public void StartProgressBar(Transform targetTransform, float duration, Action onComplete, string actionText)
    {
        if (parentCanvas == null)
        {
            Debug.LogError("[ExplorationUIManager] 無法啟動進度條，因為 parentCanvas 為空！");
            FindCanvas();
            if (parentCanvas == null) return;
        }

        if (activeProgressBar != null && activeProgressBar.gameObject.activeInHierarchy)
        {
            activeProgressBar.Cancel();
        }
        
        if (activeProgressBar == null || activeProgressBar.transform.parent != parentCanvas.transform)
        {
            if (activeProgressBar != null) Destroy(activeProgressBar.gameObject);
            activeProgressBar = Instantiate(progressBarPrefab, parentCanvas.transform);
        }
        
        onProgressCompleteCallback = onComplete;
        activeProgressBar.gameObject.SetActive(true);
        
        IsProgressBarActive = true;
        Vector3 screenPosition = Camera.main.WorldToScreenPoint(targetTransform.position);

        activeProgressBar.transform.position = (Vector2)screenPosition + positionOffset;
        activeProgressBar.StartProgress(duration, actionText);
    }
    
    public void OnProgressComplete()
    {
        IsProgressBarActive = false;
        onProgressCompleteCallback?.Invoke();
        onProgressCompleteCallback = null;
    }

    public void CancelCurrentProgress()
    {
        if (IsProgressBarActive && activeProgressBar != null)
        {
            activeProgressBar.Cancel();
            IsProgressBarActive = false;
            onProgressCompleteCallback = null; 
            Debug.Log("[ExplorationUIManager] 進度條已被取消。");
        }
    }
}
```

#### 7. `ExploreProgressBar.cs`
```
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections;

public class ExploreProgressBar : MonoBehaviour
{
    [SerializeField] private Slider slider;
    [SerializeField] private TextMeshProUGUI actionText;

    private Coroutine fillCoroutine;

    public void StartProgress(float duration, string text)
    {
        if (slider == null || actionText == null)
        {
            Debug.LogError("進度條UI元件未正確連結！");
            gameObject.SetActive(false);
            return;
        }

        actionText.text = text;
        
        if (fillCoroutine != null)
        {
            StopCoroutine(fillCoroutine);
        }
        fillCoroutine = StartCoroutine(FillBarCoroutine(duration));
    }

    public void Cancel()
    {
        if (fillCoroutine != null)
        {
            StopCoroutine(fillCoroutine);
            fillCoroutine = null;
        }
        gameObject.SetActive(false);
    }

    private IEnumerator FillBarCoroutine(float duration)
    {
        float elapsedTime = 0f;
        slider.value = 0;

        while (elapsedTime < duration)
        {
            elapsedTime += Time.deltaTime;
            slider.value = elapsedTime / duration;
            yield return null;
        }
        slider.value = 1;
        
        ExplorationUIManager.Instance.OnProgressComplete();
        
        gameObject.SetActive(false);
        fillCoroutine = null;
    }
}
```