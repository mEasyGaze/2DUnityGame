## 腳本結構

### **戰鬥系統核心資料結構**

1. `BattleEnums.cs`
```csharp
using System;

public enum BattleRole
{Vanguard,Ranged1,Ranged2,Support}

public enum ActionType
{Attack,Defend,Rest,Skill,Item,Exchange,Skip}

public enum UICommandType
{Back,EndTurn,ResetAll,CancelSingleAction,UseCommanderSkill,CancelCommanderSkill}

public enum BattleState
{Setup,PlayerPlanning,EnemyTurn,ActionExecution,Won,Lost}

public enum PlanningSubState
{
    None,                   // 無操作
    SelectingRangedUnit,    // 正在等待玩家選擇行動的遠程單位
    SelectingAction,        // 正在等待玩家為已選單位選擇行動
    SelectingTarget,        // 正在等待玩家為已選行動選擇目標
    SelectingExchangeTarget,// 正在等待玩家選擇交換位置的目標
    SelectingItem,          // 正在等待玩家選擇使用道具的目標
    SelectingItemTarget,    // 正在等待玩家選擇使用道具的目標
    SelectingSkill,         // 正在等待玩家選擇要使用的技能
    SelectingSkillTarget    // 正在等待玩家為已選技能選擇目標
}

[Serializable]
public enum GridPosition
{
    PlayerSupport = 0,
    PlayerRanged2 = 1,
    PlayerRanged1 = 2,
    PlayerVanguard = 3,
    EnemyVanguard = 4,
    EnemyRanged1 = 5,
    EnemyRanged2 = 6,
    EnemySupport = 7,
    None = -1
}

public static class ActionTypeExtensions
{
    public static string ToActionName(this ActionType type)
    {
        switch (type)
        {
            case ActionType.Attack:   return "攻擊";
            case ActionType.Defend:   return "防禦";
            case ActionType.Rest:     return "休息";
            case ActionType.Skill:    return "技能";
            case ActionType.Item:     return "道具";
            case ActionType.Exchange: return "交換";
            case ActionType.Skip:     return "跳過";
            default:                  return type.ToString();
        }
    }
}
```

2. `EnemyDataSO.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewEnemyData", menuName = "Battle System/Enemy Data")]
public class EnemyDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string enemyID;
    public string enemyName;
    public Sprite enemyIcon;
    public GameObject enemyPrefab;

    [Header("基礎屬性")]
    public int baseHealth;
    public int baseAttack;
    public int baseStamina;
    public int attackRange;

    [Header("技能槽位")]
    [Tooltip("輸入對應 SkillData 的技能ID")]
    public List<string> skillIDs;

    [Header("物品掉落")]
    public int goldDrop;
    // public List<ItemDropInfo> itemDrops; // 未來可擴充為物品掉落
}
```

3. `BattleEncounterSO.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class EnemyPositioning
{
    public EnemyDataSO enemyData;
    public BattleRole role;
}

public enum DefeatActionType
{
    ReturnToTitle,      // 默認：回到標題或讀取存檔 (一般戰鬥)
    TeleportToScene,    // 傳送到指定場景的指定位置 (例如：被打回城鎮、或進入劇情場景)
    TriggerStoryEvent   // 直接觸發一段劇情 (StoryScene) - 如果在同一場景
}

[CreateAssetMenu(fileName = "NewBattleEncounter", menuName = "Battle System/Battle Encounter")]
public class BattleEncounterSO : ScriptableObject
{
    [Header("敵人隊伍配置")]
    public List<EnemyPositioning> enemyTeam;

    [Header("AI 行為配置")]
    [Tooltip("指定此遭遇戰中敵方隊伍使用的人格(軍師)。如果留空，將使用 EnemyBattleAI 中定義的通用後備戰術。")]
    public AIPersonalitySO enemyPersonality;

    [Header("戰鬥獎勵")]
    public int totalGoldReward;
    // public List<ItemReward> itemRewards;

    [Header("戰敗處理 (劇情殺專用)")]
    [Tooltip("玩家戰敗後會發生什麼事？")]
    public DefeatActionType defeatType = DefeatActionType.ReturnToTitle;

    [Tooltip("如果類型是 TeleportToScene，填寫場景名稱。")]
    public string defeatSceneName;
    
    [Tooltip("如果類型是 TeleportToScene，填寫傳送後的坐標。")]
    public Vector3 defeatPosition;

    [Tooltip("如果類型是 TriggerStoryEvent，填寫劇情事件ID (GameEvent)。")]
    public string defeatEventID;

    private void OnValidate()
    {
        int calculatedGold = 0;
        if (enemyTeam != null)
        {
            foreach (var enemyPos in enemyTeam)
            {
                if (enemyPos.enemyData != null)
                {
                    calculatedGold += enemyPos.enemyData.goldDrop;
                }
            }
        }
        totalGoldReward = calculatedGold;
    }
}
```

4. `ActionPlan.cs`
```csharp
using System;

public class ActionPlan
{
    public IBattleUnit_ReadOnly Source { get; }
    public IBattleUnit_ReadOnly Target { get; }
    public ActionType Type { get; }
    public int PhaseIndex { get; }
    public BattleRole PlannedForRole { get; }
    public Guid TransactionID { get; }
    public GridPosition TargetPosition { get; }
    public Item ItemUsed { get; }
    public SkillData SkillUsed { get; }

    private ActionPlan(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly target, ActionType type, int phaseIndex, BattleRole plannedForRole, Guid transactionID, Item item, GridPosition targetPosition, SkillData skill)
    {
        Source = source;
        Target = target;
        Type = type;
        PhaseIndex = phaseIndex;
        PlannedForRole = plannedForRole;
        TransactionID = transactionID;
        ItemUsed = item;
        TargetPosition = targetPosition;
        SkillUsed = skill;
    }

    #region 靜態工廠方法
    // 1: 用於玩家操作 (人事契約)
    public static ActionPlan CreatePlayerAction(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly target, ActionType type, int phaseIndex, BattleRole plannedForRole, Guid transactionID = default, Item item = null)
    {
        GridPosition position = (target != null) ? target.CurrentPosition : GridPosition.None;
        return new ActionPlan(source, target, type, phaseIndex, plannedForRole, transactionID, item, position, null);
    }

    // 2: 用於 AI 操作 (地域契約)
    public static ActionPlan CreateAIAction(IBattleUnit_ReadOnly source, GridPosition targetPosition, ActionType type, int phaseIndex, BattleRole plannedForRole)
    {
        return new ActionPlan(source, null, type, phaseIndex, plannedForRole, default, null, targetPosition, null);
    }

    // 3: 用於無目標的行動 (如休息、防禦、跳過)
    public static ActionPlan CreateNoTargetAction(IBattleUnit_ReadOnly source, ActionType type, int phaseIndex, BattleRole plannedForRole)
    {
        return new ActionPlan(source, null, type, phaseIndex, plannedForRole, default, null, GridPosition.None, null);
    }
    
    // 4: 用於完全空的行動 (如自動跳過)
    public static ActionPlan CreateEmptyAction(int phaseIndex, BattleRole plannedForRole)
    {
        return new ActionPlan(null, null, ActionType.Skip, phaseIndex, plannedForRole, default, null, GridPosition.None, null);
    }

    // 5: 用於技能行動
    public static ActionPlan CreateSkillAction(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly target, SkillData skill, int phaseIndex, BattleRole plannedForRole)
    {
        GridPosition position = (target != null) ? target.CurrentPosition : GridPosition.None;
        return new ActionPlan(source, target, ActionType.Skill, phaseIndex, plannedForRole, default, null, position, skill);
    }
    #endregion
}
```

### **Prefab (預製件盒 - 遊戲世界的實體零件)**

1. `BattleUnit.cs`
```csharp
using UnityEngine;
using UnityEngine.Events;
using TMPro;
using System.Collections.Generic;

public interface IBattleUnit_ReadOnly
{
    string UnitName { get; }
    int CurrentHP { get; }
    int MaxHP { get; }
    int CurrentStamina { get; }
    int MaxStamina { get; }
    int CurrentAttack { get; }
    int AttackRange { get; }
    bool IsDead { get; }
    bool IsPlayerTeam { get; }

    GridPosition CurrentPosition { get; }
    BattleRole Role { get; }
    
    MemberDataSO MemberData { get; }
    EnemyDataSO EnemyData { get; }

    MemberInstance MemberInstance { get; }

    List<SkillData> Skills { get; }
    
    BattleUnit GetMonoBehaviour();
}

public class BattleUnit : MonoBehaviour, IBattleUnit_ReadOnly
{   
    #region 核心數據與屬性 (Core Data & Properties)
    public MemberDataSO MemberData { get; private set; }
    public EnemyDataSO EnemyData { get; private set; }

    public MemberInstance MemberInstance { get; private set; }

    public BattleRole Role { get; private set; }
    public GridPosition CurrentPosition { get; private set; }
    public int AttackRange { get; private set; }
    public string UnitName { get; private set; }
    public int MaxHP { get; private set; }
    public int CurrentHP { get; private set; }
    public int CurrentAttack
    {
        get
        {
            int baseAttack = (MemberInstance != null) ? MemberInstance.CurrentAttack : EnemyData.baseAttack;

            if (buffController == null) return baseAttack;

            // 固定值加成/減成
            float flatBonus = buffController.GetBuffValue(BuffType.IncreaseAttack_Value);
            float flatPenalty = buffController.GetBuffValue(BuffType.DecreaseAttack_Value);
            float finalAttack = baseAttack + flatBonus - flatPenalty;

            // 百分比加成/減成
            float percentBonus = buffController.GetBuffValue(BuffType.IncreaseAttack_Percent);
            float percentPenalty = buffController.GetBuffValue(BuffType.DecreaseAttack_Percent);
            finalAttack *= (1.0f + percentBonus - percentPenalty);

            return Mathf.Max(0, Mathf.RoundToInt(finalAttack));
        }
    }
    public int MaxStamina { get; private set; }
    public int CurrentStamina { get; private set; }
    public List<SkillData> Skills { get; private set; }
    public bool IsPlayerTeam { get; private set; }
    public bool IsDead { get; private set; } = false;
    private bool isDefending = false;

    public static event System.Action<IBattleUnit_ReadOnly> OnUnitDiedGlobal;
    #endregion

    #region 元件與事件連結
    [Header("元件連結")]
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private HealthUI healthUI;
    [SerializeField] private StaminaUI staminaUI;
    
    [Header("狀態反饋")]
    [SerializeField] private GameObject selectionHighlight;
    [SerializeField] private GameObject planningHighlight; 

    [Header("戰術預演UI")]
    [SerializeField] private TextMeshProUGUI previewStaminaText;

    private BuffController buffController;
    public UnityAction<BattleUnit> OnUnitClicked;
    #endregion
    
    #region 初始化
    public void Setup(MemberInstance instance, BattleRole role, GridPosition initialPosition)
    {
        MemberInstance = instance;
        MemberData = instance.BaseData;
        UnitName = MemberData.memberName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = MemberData.attackRange;
        IsPlayerTeam = true;
        
        MaxHP = instance.MaxHP;
        CurrentHP = instance.currentHP;
        MaxStamina = instance.MaxStamina;
        CurrentStamina = instance.MaxStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = MemberData.memberIcon;

        Skills = new List<SkillData>();
        if (MemberData.skillIDs != null)
        {
            foreach (var id in MemberData.skillIDs)
            {
                SkillData skill = SkillManager.Instance.Database.GetSkillDataByID(id);
                if (skill != null)
                {
                    Skills.Add(skill);
                }
            }
        }
        buffController = GetComponent<BuffController>();
        ResetVisualsToCoreState();
    }

    public void Setup(EnemyDataSO data, BattleRole role, GridPosition initialPosition)
    {
        EnemyData = data;
        UnitName = EnemyData.enemyName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = data.attackRange;
        IsPlayerTeam = false;
        
        MaxHP = data.baseHealth;
        CurrentHP = data.baseHealth;
        MaxStamina = data.baseStamina;
        CurrentStamina = data.baseStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = EnemyData.enemyIcon;

        Skills = new List<SkillData>();
        if (EnemyData.skillIDs != null)
        {
            foreach (var id in EnemyData.skillIDs)
            {
                SkillData skill = SkillManager.Instance.Database.GetSkillDataByID(id);
                if (skill != null)
                {
                    Skills.Add(skill);
                }
            }
        }
        buffController = GetComponent<BuffController>();
        ResetVisualsToCoreState();
    }
    #endregion

    #region 狀態變更方法
    public void TakeDamage(int damage)
    {
        Debug.Log($"[TakeDamage] {UnitName} 嘗試受到 {damage} 點傷害。當前HP: {CurrentHP}");
        if (IsDead) return;

        int absorbedByShield = buffController.AbsorbDamage(damage);
        int remainingDamage = damage - absorbedByShield;

        if (absorbedByShield > 0 && BattleVFXManager.Instance != null)
        {
            BattleVFXManager.Instance.ShowText(transform.position + Vector3.up * 0.5f, $"-{absorbedByShield}", VFXType.Text_Shield);
        }

        if (remainingDamage <= 0) return;
        float finalDamage = remainingDamage;

        float defensePercent = buffController.GetBuffValue(BuffType.IncreaseDefense_Percent);
        finalDamage *= (1.0f - defensePercent);
        float defenseFlat = buffController.GetBuffValue(BuffType.IncreaseDefense_Value);
        finalDamage -= defenseFlat;
        if (isDefending)
        {
            finalDamage /= 2;
            ConsumeStamina(1);
            BattleLog.Instance.AddLog($"{UnitName} 處於防禦狀態，消耗 1 點體力。");
        }
        finalDamage = Mathf.Max(0, finalDamage);

        int damageToApply = Mathf.RoundToInt(finalDamage);
        CurrentHP -= damageToApply;
        if (BattleVFXManager.Instance != null)
        {
            BattleVFXManager.Instance.ShowText(transform.position + Vector3.up, damageToApply.ToString(), VFXType.Text_Damage);
        }
        if (CurrentHP <= 0)
        {
            CurrentHP = 0;
            Die();
        }
    }

    public void Heal(int amount)
    {
        if (IsDead) return;
        CurrentHP += amount;
        CurrentHP = Mathf.Min(CurrentHP, MaxHP);
        BattleLog.Instance.AddLog($"{UnitName} 恢復了 {amount} 點生命值。");
        if (BattleVFXManager.Instance != null)
        {
            BattleVFXManager.Instance.ShowText(transform.position + Vector3.up, $"+{amount}", VFXType.Text_Heal);
        }
    }

    private void Die()
    {
        IsDead = true;
        gameObject.SetActive(false);
        BattleLog.Instance.AddLog($"{UnitName} 已陣亡！");

        OnUnitDiedGlobal?.Invoke(this); 
    }

    public void ConsumeStamina(int amount)
    {
        CurrentStamina = Mathf.Max(0, CurrentStamina - amount);
    }

    public void RestoreStamina(int amount)
    {
        CurrentStamina = Mathf.Min(MaxStamina, CurrentStamina + amount);
    }

    public void SetStamina(int value)
    {
        CurrentStamina = Mathf.Clamp(value, 0, MaxStamina);
    }

    public void SetNewPosition(GridPosition newPosition)
    {
        this.CurrentPosition = newPosition;
    }

    public void SetRole(BattleRole newRole)
    {
        this.Role = newRole;
    }

    public void SetDefenseState(bool defending)
    {
        isDefending = defending;
    }
    #endregion

    #region 視覺與互動 (Visual & Interaction)
    public void UpdatePreviewVisuals(GridPosition previewPosition, int previewStamina, BattleRole previewRole)
    {
        if (BattleManager.Instance != null && BattleManager.Instance.GridSpawns[(int)previewPosition] != null)
        {
            transform.position = BattleManager.Instance.GridSpawns[(int)previewPosition].position;
        }

        if (previewStaminaText != null)
        {
            int staminaChange = previewStamina - this.CurrentStamina;
            if (staminaChange != 0)
            {
                previewStaminaText.text = staminaChange > 0 ? $"+{staminaChange}" : staminaChange.ToString();
                previewStaminaText.color = staminaChange < 0 ? Color.red : Color.green;
                previewStaminaText.gameObject.SetActive(true);
            }
            else
            {
                previewStaminaText.gameObject.SetActive(false);
            }
        }
    }

    public void ResetVisualsToCoreState()
    {
        if (BattleManager.Instance != null && BattleManager.Instance.GridSpawns[(int)this.CurrentPosition] != null)
        {
            transform.position = BattleManager.Instance.GridSpawns[(int)this.CurrentPosition].position;
        }

        if (previewStaminaText != null)
        {
            previewStaminaText.gameObject.SetActive(false);
        }
    }

    private void OnMouseDown()
    {
        OnUnitClicked?.Invoke(this);
    }
    
    public void SetHighlight(bool state)
    {
        if (selectionHighlight != null) selectionHighlight.SetActive(state);
    }
    
    public void SetPlanningHighlight(bool state)
    {
        if (planningHighlight != null) planningHighlight.SetActive(state);
    }
    #endregion
    public BattleUnit GetMonoBehaviour() => this;
}
```

2. `ActionButtonUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionButtonUI : MonoBehaviour
{
    [SerializeField] private Button button;
    [SerializeField] private TextMeshProUGUI buttonText;
    
    private ActionType actionType;
    
    public void Setup(ActionType type, System.Action<ActionType> onClickCallback)
    {
        buttonText.text = type.ToActionName();
        
        button.onClick.RemoveAllListeners();
        button.onClick.AddListener(() => onClickCallback(type));
    }
    
    public void SetInteractable(bool interactable)
    {
        button.interactable = interactable;
    }
}
```

3. `ActionSlotUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionSlotUI : MonoBehaviour
{
    [Header("內容UI")]
    [SerializeField] private Image icon;
    [SerializeField] private TextMeshProUGUI actionText;

    [Header("狀態物件")]
    [SerializeField] private GameObject emptyStateObject;
    [SerializeField] private GameObject filledStateObject;

    [Header("互動元件")]
    [SerializeField] private Button cancelButton;

    private ActionPlan currentPlan;

    public void Setup(System.Action<ActionPlan> onCancelClicked)
    {
        cancelButton.onClick.RemoveAllListeners();
        cancelButton.onClick.AddListener(() =>
        {
            if (currentPlan != null)
            {
                onCancelClicked(currentPlan);
            }
        });
    }

    public void UpdateView(ActionPlan plan)
    {
        currentPlan = plan;
        if (plan == null)
        {
            emptyStateObject.SetActive(true);
            filledStateObject.SetActive(false);
        }
        else
        {
            emptyStateObject.SetActive(false);
            filledStateObject.SetActive(true);
            
            if (plan.Source != null)
            {
                if (plan.Source.MemberData != null) icon.sprite = plan.Source.MemberData.memberIcon;
                else if (plan.Source.EnemyData != null) icon.sprite = plan.Source.EnemyData.enemyIcon;
                
                actionText.text = $"{plan.Source.UnitName[0]} > {plan.Type.ToActionName()}";
            }
            else
            {
                if (icon != null) icon.sprite = null;
                actionText.text = "跳過";
            }
        }
    }

    public void SetCancelButtonInteractable(bool isInteractable)
    {
        cancelButton.interactable = isInteractable;
    }
}
```

4. `HealthUI.c`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HealthUI : MonoBehaviour
{
    [Header("核心單位")]
    [SerializeField] private BattleUnit targetUnit;
    private BuffController buffController;

    [Header("UI 連結")]
    [SerializeField] private Slider healthSlider;
    [SerializeField] private Slider shieldSlider;
    [SerializeField] private TextMeshProUGUI healthText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if (targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (targetUnit != null)
        {
            buffController = targetUnit.GetComponent<BuffController>();
        }
        else
        {
            Debug.LogError("HealthUI 找不到目標 BattleUnit！", gameObject);
            this.enabled = false;
            return;
        }
        
        if (shieldSlider == null)
        {
            Debug.LogError("HealthUI 未指定 Shield Slider！護盾將無法正確顯示。", gameObject);
        }
    }

    void LateUpdate()
    {
        if (targetUnit == null || targetUnit.IsDead)
        {
            if (gameObject.activeSelf)
            {
                gameObject.SetActive(false);
            }
            return;
        }
        
        float currentHP = targetUnit.CurrentHP;
        float maxHP = targetUnit.MaxHP;
        float currentShield = (buffController != null) ? buffController.CurrentShield : 0;
        
        if (shieldSlider != null && shieldSlider.gameObject.activeSelf != (currentShield > 0))
        {
            shieldSlider.gameObject.SetActive(currentShield > 0);
        }

        float totalCombined = currentHP + currentShield;
        float displayMaxValue;

        if (totalCombined > maxHP)
        {
            displayMaxValue = totalCombined;
        }
        else
        {
            displayMaxValue = maxHP;
        }

        if (healthSlider != null) healthSlider.maxValue = displayMaxValue;
        if (shieldSlider != null) shieldSlider.maxValue = displayMaxValue;
        
        if (shieldSlider != null) shieldSlider.value = totalCombined;
        if (healthSlider != null) healthSlider.value = currentHP;
        if (healthText != null)
        {
            int displayHP = Mathf.RoundToInt(currentHP);
            int displayMaxHP = Mathf.RoundToInt(maxHP);
            int displayShield = Mathf.RoundToInt(currentShield);

            if (currentShield > 0)
            {
                healthText.text = $"{displayHP}+({displayShield}) / {displayMaxHP}";
            }
            else
            {
                healthText.text = $"{displayHP} / {displayMaxHP}";
            }
        }
        
        if (mainCamera != null)
        {
            transform.rotation = mainCamera.transform.rotation;
        }
    }
}
```

5. `StaminaUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class StaminaUI : MonoBehaviour
{
    [SerializeField] private BattleUnit targetUnit;
    [SerializeField] private Slider staminaSlider;
    [SerializeField] private TextMeshProUGUI staminaText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if(targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (staminaSlider != null)
        {
            staminaSlider.minValue = 0;
            staminaSlider.maxValue = 1;
        }
    }

    void Update()
    {
        if (targetUnit != null && !targetUnit.IsDead)
        {
            staminaSlider.value = (float)targetUnit.CurrentStamina / targetUnit.MaxStamina;
            
            if (staminaText != null)
            {
                staminaText.text = $"{targetUnit.CurrentStamina} / {targetUnit.MaxStamina}";
            }            
            transform.rotation = mainCamera.transform.rotation;            
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}
```

6. `SkillButtonUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class StaminaUI : MonoBehaviour
{
    [SerializeField] private BattleUnit targetUnit;
    [SerializeField] private Slider staminaSlider;
    [SerializeField] private TextMeshProUGUI staminaText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if(targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (staminaSlider != null)
        {
            staminaSlider.minValue = 0;
            staminaSlider.maxValue = 1;
        }
    }

    void Update()
    {
        if (targetUnit != null && !targetUnit.IsDead)
        {
            staminaSlider.value = (float)targetUnit.CurrentStamina / targetUnit.MaxStamina;
            
            if (staminaText != null)
            {
                staminaText.text = $"{targetUnit.CurrentStamina} / {targetUnit.MaxStamina}";
            }            
            transform.rotation = mainCamera.transform.rotation;            
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}
```

7. `FloatingText.cs`
```
using UnityEngine;
using TMPro;
using System.Collections;

public class FloatingText : MonoBehaviour
{
    [SerializeField] private TextMeshPro textMesh;
    [SerializeField] private float floatSpeed = 1.5f;
    [SerializeField] private float fadeDuration = 1.0f;
    
    private Color originalColor;
    private float timer;

    public void Setup(string content, Color color, float size)
    {
        if (textMesh == null) textMesh = GetComponent<TextMeshPro>();
        
        textMesh.text = content;
        textMesh.color = color;
        textMesh.fontSize = size;
        originalColor = color;
        timer = 0;
        // transform.rotation = Camera.main.transform.rotation; 
    }

    void Update()
    {
        timer += Time.deltaTime;
        transform.position += Vector3.up * floatSpeed * Time.deltaTime;
        if (timer > fadeDuration * 0.5f)
        {
            float alpha = 1.0f - ((timer - fadeDuration * 0.5f) / (fadeDuration * 0.5f));
            Color c = originalColor;
            c.a = alpha;
            textMesh.color = c;
        }
        if (timer >= fadeDuration)
        {
            gameObject.SetActive(false);
        }
    }
}
```

### **UI (使用者介面盒 - 玩家的操作面板)**

1. `ActionPanelUI.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionPanelUI : MonoBehaviour
{
    [SerializeField] private GameObject panel;
    [SerializeField] private Transform buttonContainer;
    [SerializeField] private ActionButtonUI buttonPrefab;
    
    private List<ActionButtonUI> spawnedButtons = new List<ActionButtonUI>();
    private Dictionary<ActionType, ActionButtonUI> buttonMap = new Dictionary<ActionType, ActionButtonUI>();

    public void ShowPanel(BattleUnit unit, System.Action<ActionType> onActionSelected)
    {
        ClearButtons();
        
        List<ActionType> availableActions = GetActionsForRole(unit.Role);

        foreach (var actionType in availableActions)
        {
            ActionButtonUI newButton = Instantiate(buttonPrefab, buttonContainer);
            newButton.Setup(actionType, onActionSelected);
            spawnedButtons.Add(newButton);
            buttonMap.Add(actionType, newButton);
        }
        panel.SetActive(true);
    }

    public void UpdateButtonStates(Dictionary<ActionType, bool> feasibility)
    {
        foreach (var pair in feasibility)
        {
            if (buttonMap.TryGetValue(pair.Key, out ActionButtonUI button))
            {
                button.SetInteractable(pair.Value);
            }
        }
    }
    
    private List<ActionType> GetActionsForRole(BattleRole role)
    {
        switch (role)
        {
            case BattleRole.Vanguard:
            case BattleRole.Ranged1:
            case BattleRole.Ranged2:
                return new List<ActionType>
                {
                    ActionType.Attack,
                    ActionType.Defend,
                    ActionType.Skill,
                    ActionType.Rest,
                    ActionType.Item,
                    ActionType.Exchange,
                    ActionType.Skip
                };
            // case BattleRole.Support: // 後勤的行動可以在這裡定義
            default:
                return new List<ActionType>();
        }
    }

    public void UpdateButtonStates(BattleUnit unit, BattleRules rules)
    {
        foreach (var btnUI in spawnedButtons)
        {
            // 簡化：這裡可以加入更複雜的規則，例如體力檢查
            // bool isInteractable = rules.CanPerformAction(unit, btnUI.ActionType);
            // btnUI.SetInteractable(isInteractable);
        }
    }

    public void HidePanel()
    {
        panel.SetActive(false);
        ClearButtons();
    }
    
    private void ClearButtons()
    {
        foreach (var btn in spawnedButtons)
        {
            Destroy(btn.gameObject);
        }
        spawnedButtons.Clear();
        buttonMap.Clear();
    }
}
```

2. `ActionSlotPanelUI.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System;

public class ActionSlotPanelUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject panel;
    [SerializeField] private List<ActionSlotUI> vanguardSlots;
    [SerializeField] private List<ActionSlotUI> rangedSlots;
    [SerializeField] private List<GameObject> highlightObjects;

    private Dictionary<int, ActionSlotUI> allSlots = new Dictionary<int, ActionSlotUI>();

    public void Initialize(System.Action<UICommandType, ActionPlan> onCommand)
    {
        for (int i = 0; i < vanguardSlots.Count; i++)
        {
            int stepIndex = i * 2;
            allSlots[stepIndex] = vanguardSlots[i];
            vanguardSlots[i].Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
        for (int i = 0; i < rangedSlots.Count; i++)
        {
            int stepIndex = i * 2 + 1;
            allSlots[stepIndex] = rangedSlots[i];
            rangedSlots[i].Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
    }
    
    public void UpdatePanel(TurnActionPlanner planner)
    {
        int lastPlannedStep = planner.GetLastPlanStepIndex();
        
        for(int i = 0; i < 8; i++)
        {
            if (allSlots.TryGetValue(i, out ActionSlotUI slot))
            {
                ActionPlan plan = planner.GetPlanAtStep(i);
                
                slot.UpdateView(plan);
                
                bool isCancellable = (plan != null && i == lastPlannedStep);
                
                if (plan != null && plan.TransactionID != Guid.Empty)
                {
                    var lastPlan = planner.GetPlanAtStep(lastPlannedStep);
                    if (lastPlan != null && lastPlan.TransactionID == plan.TransactionID)
                    {
                        isCancellable = true;
                    }
                }
                slot.SetCancelButtonInteractable(isCancellable);
            }
        }
        
        panel.SetActive(true);
    }

    public void SetPlanningHighlight(int stepIndex)
    {
        for (int i = 0; i < highlightObjects.Count; i++)
        {
            if (highlightObjects[i] != null)
            {
                highlightObjects[i].SetActive(i == stepIndex);
            }
        }
    }
    
    public void HidePanel()
    {
        panel.SetActive(false);
    }
}
```

3. `BattleEndUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BattleEndUI : MonoBehaviour
{
    [SerializeField] private GameObject victoryPanel;
    [SerializeField] private GameObject defeatPanel;
    [SerializeField] private TextMeshProUGUI rewardText;
    [SerializeField] private TextMeshProUGUI defeatText;
    [SerializeField] private Button exitButton;

    private void Start()
    {
        exitButton.onClick.AddListener(OnExitButtonClicked);
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(false);
        if (exitButton != null)
        {
            exitButton.gameObject.SetActive(false);
        }
    }

    public void ShowVictory(int goldReward)
    {
        victoryPanel.SetActive(true);
        defeatPanel.SetActive(false);
        rewardText.text = $"獲得金幣: {goldReward}";
        if (exitButton != null)
        {
            exitButton.gameObject.SetActive(true);
        }
    }

    public void ShowDefeat()
    {
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(true);
        
        var encounter = GameManager.Instance.CurrentEncounter;
        if (encounter != null && encounter.defeatType != DefeatActionType.ReturnToTitle)
        {
            if (defeatText != null) defeatText.text = "體力不支，準備撤退...";
        }
        else
        {
            if (defeatText != null) defeatText.text = "戰鬥失敗";
        }

        if (exitButton != null)
        {
            exitButton.gameObject.SetActive(true);
        }
    }

    private void OnExitButtonClicked()
    {
        exitButton.interactable = false;
        GameManager.Instance.EndBattle();
    }
}
```

4. `BattleLog.cs`
```csharp
using UnityEngine;
using TMPro;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;

public class BattleLog : MonoBehaviour
{
    public static BattleLog Instance { get; private set; }
    
    [SerializeField] private TextMeshProUGUI logText;
    [SerializeField] private ScrollRect scrollRect;
    private Queue<string> logMessages = new Queue<string>();
    private int maxMessages = 20;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public void AddLog(string message)
    {
        if (Instance == null || this == null) 
        {
            // Debug.LogWarning("嘗試在非戰鬥場景寫入戰鬥日誌，已忽略。");
            return;
        }
        
        if (logMessages.Count >= maxMessages)
        {
            logMessages.Dequeue();
        }
        logMessages.Enqueue($"[{System.DateTime.Now:HH:mm:ss}] {message}");
        UpdateLogText();
    }

    private void UpdateLogText()
    {
        if (this == null || logText == null || scrollRect == null) return;

        logText.text = string.Join("\n", logMessages);

        if(gameObject.activeInHierarchy)
        {
            StopAllCoroutines(); 
            StartCoroutine(ScrollToBottomCoroutine());
        }
    }

    private IEnumerator ScrollToBottomCoroutine()
    {
        yield return new WaitForEndOfFrame();
        scrollRect.verticalNormalizedPosition = 0f;
    }
}
```

5. `BattleUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;

public class BattleUI : MonoBehaviour
{
    [SerializeField] private Button endTurnButton;
    [SerializeField] private Button resetButton;
    [SerializeField] private Button backButton;

    [Header("指揮官技能按鈕")]
    [SerializeField] private Button commanderSkillButton;
    [SerializeField] private Button cancelCommanderSkillButton;

    public void Setup(System.Action<UICommandType> onCommand)
    {
        endTurnButton.onClick.RemoveAllListeners();
        endTurnButton.onClick.AddListener(() => onCommand(UICommandType.EndTurn));
        
        resetButton.onClick.RemoveAllListeners();
        resetButton.onClick.AddListener(() => onCommand(UICommandType.ResetAll));
        
        backButton.onClick.RemoveAllListeners();
        backButton.onClick.AddListener(() => onCommand(UICommandType.Back));

        if (commanderSkillButton != null)
        {
            commanderSkillButton.onClick.RemoveAllListeners();
            commanderSkillButton.onClick.AddListener(() => onCommand(UICommandType.UseCommanderSkill));
        }
        if (cancelCommanderSkillButton != null)
        {
            cancelCommanderSkillButton.onClick.RemoveAllListeners();
            cancelCommanderSkillButton.onClick.AddListener(() => onCommand(UICommandType.CancelCommanderSkill));
        }
    }
    
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        endTurnButton.interactable = interactable;
    }
    
    public void SetBackButtonVisible(bool visible)
    {
        backButton.gameObject.SetActive(visible);
    }

    public void SetResetButtonVisible(bool visible)
    {
        resetButton.gameObject.SetActive(visible);
    }

    public void SetCommanderSkillButtons(bool showUseButton, bool showCancelButton, bool isInteractable)
    {
        if (commanderSkillButton != null)
        {
            commanderSkillButton.gameObject.SetActive(showUseButton);
            commanderSkillButton.interactable = isInteractable;
        }
        if (cancelCommanderSkillButton != null)
        {
            cancelCommanderSkillButton.gameObject.SetActive(showCancelButton);
        }
    }
}
```

6. `BattleItemUI.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.UI;

public class BattleItemUI : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private GameObject itemPanel;
    [SerializeField] private Transform slotContainer;
    [SerializeField] private GameObject slotPrefab;

    private List<InventorySlotUI> slotUIs = new List<InventorySlotUI>();
    private System.Action<Item> onItemClickedCallback;
    private Inventory targetInventory;

    void Awake()
    {
        if (itemPanel == null) itemPanel = this.gameObject;
        itemPanel.SetActive(false);
    }

    private void OnEnable()
    {
        if (InventoryManager.Instance != null)
        {
            this.targetInventory = InventoryManager.Instance.playerInventoryData;
            InventoryManager.Instance.OnInventoryChanged += RefreshPanel;
            RefreshPanel();
        }
    }

    private void OnDisable()
    {
        if (InventoryManager.Instance != null)
        {
            InventoryManager.Instance.OnInventoryChanged -= RefreshPanel;
        }
    }

    public void ShowPanel(System.Action<Item> onItemClicked)
    {
        this.onItemClickedCallback = onItemClicked;
        itemPanel.SetActive(true);
        RefreshPanel();
    }

    public void HidePanel()
    {
        itemPanel.SetActive(false);
    }

    private void RefreshPanel()
    {
        if (!itemPanel.activeSelf) return;

        if (targetInventory == null)
        {
            if (InventoryManager.Instance != null)
            {
                targetInventory = InventoryManager.Instance.playerInventoryData;
            }
            else
            {
                Debug.LogError("BattleItemUI 無法獲取 targetInventory！");
                return;
            }
        }

        foreach (Transform child in slotContainer)
        {
            Destroy(child.gameObject);
        }
        slotUIs.Clear();

        var consumableSlots = targetInventory.slots
            .Where(s => !s.IsEmpty() && s.item.itemType == ItemType.Consumable)
            .ToList();

        foreach (var slotData in consumableSlots)
        {
            GameObject slotGO = Instantiate(slotPrefab, slotContainer);
            InventorySlotUI slotUI = slotGO.GetComponent<InventorySlotUI>();

            if (slotUI != null)
            {
                slotUI.AssignSlot(slotData);

                var button = slotUI.GetComponentInChildren<Button>();
                if (button != null)
                {
                    button.onClick.RemoveAllListeners();
                    button.onClick.AddListener(() => OnSlotClicked(slotData.item));
                }
                slotUIs.Add(slotUI);
            }
        }
    }

    private void OnSlotClicked(Item clickedItem)
    {
        if (onItemClickedCallback != null)
        {
            onItemClickedCallback(clickedItem);
        }
    }
}
```

7. `LogFormatter.cs`：
```
using UnityEngine;

public static class LogFormatter
{
    // 玩家和我方單位的顏色
    private const string PlayerColor = "#00FFFF"; // 青色 (Cyan)
    // 敵方單位的顏色
    private const string EnemyColor = "#FFA500"; // 橙色 (Orange)
    // 傷害數值的顏色
    private const string DamageColor = "#FF4500"; // 橙紅色 (OrangeRed)
    // 治療數值的顏色
    private const string HealColor = "#32CD32"; // 酸橙綠 (LimeGreen)
    // 增益效果的顏色
    private const string BuffColor = "#FFFF00"; // 黃色 (Yellow)
    // 減益效果的顏色
    private const string DebuffColor = "#DA70D6"; // 蘭花紫 (Orchid)
    // 護盾的顏色
    private const string ShieldColor = "#87CEEB"; // 天藍色 (SkyBlue)
    // 系統或通用消息顏色
    private const string SystemColor = "#C0C0C0"; // 銀色 (Silver)

    public static string Unit(IBattleUnit_ReadOnly unit)
    {
        string color = unit.IsPlayerTeam ? PlayerColor : EnemyColor;
        return $"<color={color}>[{unit.UnitName}]</color>";
    }
    public static string Damage(int amount)
    {
        return $"<color={DamageColor}>{amount}點傷害</color>";
    }
    public static string Heal(int amount)
    {
        return $"<color={HealColor}>{amount}點治療</color>";
    }
    public static string Shield(float amount)
    {
        return $"<color={ShieldColor}>{Mathf.RoundToInt(amount)}點護盾</color>";
    }
    public static string Buff(string buffName)
    {
         return $"<color={BuffColor}>[{buffName}]</color>";
    }
    public static string Debuff(string debuffName)
    {
        return $"<color={DebuffColor}>[{debuffName}]</color>";
    }
    public static string System(string message)
    {
        return $"<color={SystemColor}>{message}</color>";
    }
}
```

### **Manager (管理器)**

1. `TurnManager.cs`
```csharp
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    #region 屬性與狀態變數 (Properties & State Variables)
    public BattleState CurrentState { get; private set; }
    private BattleManager battleManager;
    private BattleUIManager uiManager;
    private TurnActionPlanner actionPlanner;
    private BattleRules battleRules;
    private BattleActions battleActions;
    private EnemyBattleAI enemyAI;
    private CharacterStateRule characterStateRule;
    private BattlefieldStateSimulator stateSimulator;
    private SkillData selectedSkill;
    private AIPersonalitySO currentEnemyPersonality;

    private int currentPlanningStepIndex;
    private PlanningSubState currentSubState;
    private BattleUnit selectedUnitForAction;
    private ActionType selectedActionType;
    private Item selectedItem;
    private List<IBattleUnit_ReadOnly> currentEligibleActors;
    private Stack<PlanningSubState> planningHistory = new Stack<PlanningSubState>();
    private ActionPlan plannedCommanderSkill = null;
    private bool hasCommanderSkillBeenUsedThisBattle = false;
    private BattleUnit supportUnit = null;

    private int currentTurnNumber = 0;
    #endregion

    #region 初始化與啟動 (Initialization & Startup)
    public void Initialize(BattleManager bm, BattleUIManager uim, TurnActionPlanner ap, BattleRules br, BattleActions ba, EnemyBattleAI eai, CharacterStateRule csr, BattlefieldStateSimulator sim, AIPersonalitySO personality)
    {
        battleManager = bm;
        uiManager = uim;
        actionPlanner = ap;
        battleRules = br;
        battleActions = ba;
        enemyAI = eai;
        characterStateRule = csr;
        stateSimulator = sim;
        currentEnemyPersonality = personality;

        supportUnit = battleManager.PlayerUnits.FirstOrDefault(u => u.Role == BattleRole.Support);
        currentEligibleActors = new List<IBattleUnit_ReadOnly>();
    }

    public void StartBattle()
    {
        BattleLog.Instance.AddLog("戰鬥開始！");
        SetState(BattleState.PlayerPlanning);
    }
    #endregion

    #region 宏觀狀態機管理 (Macro State Machine Management)
    private void SetState(BattleState newState)
    {
        if (CurrentState == newState) return;     
        CurrentState = newState;
        StartCoroutine(OnEnterState(newState));
    }
    
    private IEnumerator OnEnterState(BattleState state)
    {
        switch (state)
        {
            case BattleState.PlayerPlanning:
                HandleEnterPlayerPlanning();
                break;
            case BattleState.EnemyTurn:
                yield return StartCoroutine(HandleEnterEnemyTurn());
                if (plannedCommanderSkill != null)
                {
                    yield return StartCoroutine(ExecuteCommanderSkill());
                }
                SetState(BattleState.ActionExecution);
                break;
            case BattleState.ActionExecution:
                HandleEnterActionExecution();
                break;
            case BattleState.Won:
                HandleEnterWon();
                break;
            case BattleState.Lost:
                HandleEnterLost();
                break;
        }
    }
    private void HandleEnterPlayerPlanning()
    {
        currentTurnNumber++;
        BattleLog.Instance.AddLog($"==== 第 {currentTurnNumber} 回合：玩家規劃階段 ====");
        BuffManager.Instance.TickAllBuffsOnAllUnits(battleManager.GetAllUnits());
        UpdateAuraEffects();
        if (uiManager != null)
        {
            uiManager.SetResetButtonVisible(true);
            uiManager.SetEndTurnButtonInteractable(false);
            uiManager.SetBackButtonVisible(false);
            BuffManager.Instance.TickAllBuffsOnAllUnits(battleManager.GetAllUnits());
        }
        actionPlanner.PrepareForNewTurn();
        characterStateRule.RestoreAllUnitStamina(battleManager.GetAllUnits());
        UpdateCommanderSkillUI();
        CommitResetAllPlans();
    }

    private IEnumerator HandleEnterEnemyTurn()
    {
        BattleLog.Instance.AddLog("==== 敵人回合 ====");
        uiManager.EnterEnemyTurnState();
        enemyAI.PlanActions(currentEnemyPersonality, battleManager.EnemyUnits, battleManager.PlayerUnits, actionPlanner, battleRules, currentTurnNumber);
        yield return new WaitForSeconds(1f);
        if (plannedCommanderSkill != null)
        {
            yield return StartCoroutine(ExecuteCommanderSkill());
        }
        SetState(BattleState.ActionExecution);
    }

    private void HandleEnterActionExecution()
    {
        BattleLog.Instance.AddLog("==== 行動執行階段 ====");
        uiManager.EnterActionExecutionState();
        StartCoroutine(ExecuteActions());
    }

    private void HandleEnterWon()
    {
        BattleLog.Instance.AddLog("★★ 戰鬥勝利 ★★");
        uiManager.ShowVictoryScreen(battleManager.EncounterData.totalGoldReward);
    }

    private void HandleEnterLost()
    {
        BattleLog.Instance.AddLog("戰鬥失敗...");
        uiManager.ShowDefeatScreen();
    }
    #endregion

    #region 玩家輸入處理 (Player Input Handling)
    public void OnUnitClicked(BattleUnit unit)
    {
        if (CurrentState != BattleState.PlayerPlanning) return;

        switch(currentSubState)
        {
            case PlanningSubState.SelectingRangedUnit:
                if (currentEligibleActors.Any(u => u.GetMonoBehaviour() == unit))
                {
                    selectedUnitForAction = unit;
                    GoToPlanningSubState(PlanningSubState.SelectingAction);
                }
                break;
                
            case PlanningSubState.SelectingTarget:
                var validTargets = battleRules.GetValidTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                if (validTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewPlan(selectedUnitForAction, selectedActionType, unit);
                }
                break;

            case PlanningSubState.SelectingExchangeTarget:
                var validExchangeTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                if (validExchangeTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewExchangePlan(selectedUnitForAction, unit);
                }
                break;

            case PlanningSubState.SelectingItemTarget:
                var validItemTargets = battleRules.GetValidItemTargets(selectedUnitForAction);
                if (validItemTargets.Any(u => u.GetMonoBehaviour() == unit))
                {
                    CommitNewItemPlan(selectedUnitForAction, selectedItem, unit);
                }
                break;
            case PlanningSubState.SelectingSkillTarget:
                var validSkillTargets = battleRules.GetValidSkillTargets(selectedUnitForAction, selectedSkill, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                if (validSkillTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewSkillPlan(selectedUnitForAction, unit, selectedSkill);
                }
                break;
        }
    }
    
    public void OnActionSelected(ActionType type)
    {
        if (CurrentState != BattleState.PlayerPlanning || currentSubState != PlanningSubState.SelectingAction) return;
        
        selectedActionType = type;
        
        if (type == ActionType.Skill)
        {
            GoToPlanningSubState(PlanningSubState.SelectingSkill);
        }
        else if (type == ActionType.Attack)
        {
            GoToPlanningSubState(PlanningSubState.SelectingTarget);
        }
        else if (type == ActionType.Exchange)
        {
            GoToPlanningSubState(PlanningSubState.SelectingExchangeTarget);
        }
        else if (type == ActionType.Item)
        {
            GoToPlanningSubState(PlanningSubState.SelectingItem);
        }
        else
        {
            CommitNewPlan(selectedUnitForAction, type, null);
        }
    }

    public void OnItemSelected(Item item)
    {
        if (CurrentState != BattleState.PlayerPlanning || currentSubState != PlanningSubState.SelectingItem) return;
        selectedItem = item;        
        GoToPlanningSubState(PlanningSubState.SelectingItemTarget);
    }

    public void OnSkillSelected(SkillData skill)
    {
        if (CurrentState != BattleState.PlayerPlanning || currentSubState != PlanningSubState.SelectingSkill) return;

        selectedSkill = skill;
        stateSimulator.ShowTemporaryStaminaPreview(selectedUnitForAction, skill.staminaCost);

        switch (skill.targetType)
        {
            case SkillTargetType.None:
            case SkillTargetType.Self:
            case SkillTargetType.Ally_All:
            case SkillTargetType.Enemy_All:
            case SkillTargetType.Enemy_Penetrate:
                CommitNewSkillPlan(selectedUnitForAction, null, selectedSkill);
                break;
            case SkillTargetType.Enemy_Single:
            case SkillTargetType.Ally_Single:
                GoToPlanningSubState(PlanningSubState.SelectingSkillTarget);
                break;
        }
    }

    public void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        if (CurrentState != BattleState.PlayerPlanning)
        {
            if (command == UICommandType.EndTurn) SetState(BattleState.EnemyTurn);
            return;
        }

        if (currentSubState == PlanningSubState.SelectingItem)
        {
            if (command == UICommandType.Back || command == UICommandType.ResetAll)
            {
                BattleLog.Instance.AddLog("從道具選擇返回。");
                uiManager.HideItemSelectionPanel();
                GoToPlanningSubState(PlanningSubState.SelectingAction);
                return;
            }
        }

        if (currentSubState == PlanningSubState.SelectingItemTarget)
        {
            if (command == UICommandType.Back)
            {
                CommitGoBack(); 
                return;
            }
        }

        switch (command)
        {
            case UICommandType.EndTurn: SetState(BattleState.EnemyTurn); break;
            case UICommandType.ResetAll: CommitResetAllPlans(); break;
            case UICommandType.CancelSingleAction: CommitCancelLastPlan(); break;
            case UICommandType.Back: CommitGoBack(); break;
            case UICommandType.UseCommanderSkill: HandleUseCommanderSkill(); break;
            case UICommandType.CancelCommanderSkill: HandleCancelCommanderSkill(); break;
        }
    }
    #endregion

    #region 事務性操作 (Transactional Operations)
    private void CommitNewPlan(IBattleUnit_ReadOnly actor, ActionType type, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        
        ActionPlan newPlan = ActionPlan.CreatePlayerAction(actor, target, type, phaseIndex, stepRole);

        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }

    private void CommitNewNoTargetPlan(IBattleUnit_ReadOnly actor, ActionType type)
    {
        planningHistory.Clear();
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        
        ActionPlan newPlan = ActionPlan.CreateNoTargetAction(actor, type, phaseIndex, stepRole);

        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }
    
    private void CommitNewExchangePlan(IBattleUnit_ReadOnly actor, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();
        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        var actorSnap = latestSnapshot.UnitSnapshots.First(s => s.Unit == actor);
        var targetSnap = latestSnapshot.UnitSnapshots.First(s => s.Unit == target);
        if (actorSnap.Stamina < battleActions.GetExchangeStaminaCost())
        {
            BattleLog.Instance.AddLog($"交換失敗：{actor.UnitName} 體力不足！");
            return;
        }
        int actorStepIndex = currentPlanningStepIndex;
        var excludeList = new List<int> { actorStepIndex };
        int targetStepIndex = actionPlanner.FindNextAvailableStep(targetSnap.Role, 0, excludeList);
        if (targetStepIndex == -1)
        {
            BattleLog.Instance.AddLog($"交換失敗：沒有可用的行動格給 {target.UnitName}！");
            return;
        }
        int phaseIndex = (actorStepIndex / 2) + 1; 
        Guid transactionID = Guid.NewGuid();

        BattleRole actorStepRole = GetRoleForStep(actorStepIndex);
        BattleRole targetStepRole = GetRoleForStep(targetStepIndex);

        var planA = ActionPlan.CreatePlayerAction(actor, target, ActionType.Exchange, phaseIndex, actorStepRole, transactionID);
        var planB = ActionPlan.CreatePlayerAction(target, actor, ActionType.Exchange, phaseIndex, targetStepRole, transactionID);
        
        actionPlanner.AddPlan(planA, actorStepIndex);
        actionPlanner.AddPlan(planB, targetStepIndex);
        
        characterStateRule.GenerateAndStoreNextSnapshot(planA, battleActions);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }
    
    private void CommitCancelLastPlan()
    {
        uiManager.HideSkillSelectionPanel();
        planningHistory.Clear();
        int lastPlayerPlanStep = actionPlanner.GetLastPlayerPlanStepIndex();
        if (lastPlayerPlanStep == -1)
        {
            BattleLog.Instance.AddLog("沒有任何玩家規劃的行動可以取消。");
            return;
        }
        
        ActionPlan lastPlayerPlan = actionPlanner.GetPlanAtStep(lastPlayerPlanStep);
        if (lastPlayerPlan != null && lastPlayerPlan.Source != null)
        {
            BattleLog.Instance.AddLog($"正在撤銷行動: {lastPlayerPlan.Source.UnitName} -> {lastPlayerPlan.Type.ToActionName()}");
        }
        actionPlanner.RemovePlansFromStepOnward(lastPlayerPlanStep);
        characterStateRule.PruneSnapshotsToCount(actionPlanner.GetPlayerPlanCount() + 1);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        currentPlanningStepIndex = lastPlayerPlanStep;
        AdvancePlanningStep(false);
    }

    private void CommitGoBack()
    {
        if (currentSubState == PlanningSubState.SelectingSkill)
        {
            uiManager.HideSkillSelectionPanel();
        }
        if (planningHistory.Count > 0)
        {
            PlanningSubState previousState = planningHistory.Pop();
            
            BattleLog.Instance.AddLog("返回上一步操作。");
            stateSimulator.ClearTemporaryPreviews();
            GoToPlanningSubState(previousState, false); 
        }
        else
        {
            Debug.LogWarning("沒有可返回的微觀操作歷史。");
        }
    }
    
    private void CommitResetAllPlans()
    {
        uiManager.HideSkillSelectionPanel();
        planningHistory.Clear();
        actionPlanner.ClearPlayerPlans();
        characterStateRule.InitializeSnapshots(battleManager.GetAllUnits());
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        uiManager.SetEndTurnButtonInteractable(false);
        StartCoroutine(StartGuidedPlanning());
        BattleLog.Instance.AddLog("已重置所有規劃。");
    }

    private void CommitNewItemPlan(IBattleUnit_ReadOnly actor, Item item, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();

        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        if (latestSnapshot == null || !latestSnapshot.InventorySnapshot.HasItem(item.uniqueItemID))
        {
            BattleLog.Instance.AddLog($"預演失敗：模擬背包中已無 {item.itemName}，請選擇其他道具或行動。");
            GoToPlanningSubState(PlanningSubState.SelectingItem); 
            return;
        }
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        ActionPlan newPlan = ActionPlan.CreatePlayerAction(actor, target, ActionType.Item, phaseIndex, stepRole, default, item);
        
        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }

    private void CommitNewSkillPlan(IBattleUnit_ReadOnly actor, IBattleUnit_ReadOnly target, SkillData skill)
    {
        planningHistory.Clear();
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        
        ActionPlan newPlan = ActionPlan.CreateSkillAction(actor, target, skill, phaseIndex, stepRole);

        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        
        AdvancePlanningStep();
    }

    private void HandleUseCommanderSkill()
    {
        if (supportUnit == null || hasCommanderSkillBeenUsedThisBattle) return;

        SkillData commanderSkill = supportUnit.Skills.FirstOrDefault(s => s.isCommanderSkill_OneTimeUse);
        if (commanderSkill == null)
        {
            BattleLog.Instance.AddLog(LogFormatter.System("錯誤：後勤單位沒有找到指揮官技能！"));
            return;
        }

        plannedCommanderSkill = ActionPlan.CreateSkillAction(supportUnit, null, commanderSkill, 0, BattleRole.Support);
        
        BattleLog.Instance.AddLog($"{LogFormatter.Unit(supportUnit)} 已準備施放指揮官技能 [{commanderSkill.skillName}]。");
        UpdateCommanderSkillUI();
    }
    
    private void HandleCancelCommanderSkill()
    {
        if (plannedCommanderSkill == null) return;
        
        string skillName = plannedCommanderSkill.SkillUsed.skillName;
        plannedCommanderSkill = null;
        
        BattleLog.Instance.AddLog($"取消了指揮官技能 [{skillName}] 的施放。");
        UpdateCommanderSkillUI();
    }

    #endregion
    
    #region 規劃階段核心邏輯 (Planning Phase Core Logic)
    private IEnumerator StartGuidedPlanning()
    {
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;
        
        currentPlanningStepIndex = 0;
        AdvancePlanningStep();
        yield return null;
    }

    private void AdvancePlanningStep(bool isPlayerInitiated = true)
    {
        uiManager.UpdateActionSlots(actionPlanner);
        if (isPlayerInitiated)
        {
            planningHistory.Clear();
        }
        if (actionPlanner.IsPlanningFinished())
        {
            GoToPlanningSubState(PlanningSubState.None);
            return;
        }
        while (currentPlanningStepIndex < 8)
        {
            currentPlanningStepIndex = actionPlanner.GetNextPlanningStepIndex();
            if (currentPlanningStepIndex >= 8)
            {
                GoToPlanningSubState(PlanningSubState.None);
                return;
            }
            
            var latestSnapshotUnits = characterStateRule.GetLatestSnapshot().UnitSnapshots;
            currentEligibleActors = battleRules.GetEligibleActorsForStep(currentPlanningStepIndex, latestSnapshotUnits, actionPlanner);

            if (currentEligibleActors.Count > 0)
            {
                if (currentEligibleActors.Count == 1)
                {
                    selectedUnitForAction = currentEligibleActors[0].GetMonoBehaviour();
                    planningHistory.Push(PlanningSubState.None);
                    GoToPlanningSubState(PlanningSubState.SelectingAction);
                }
                else
                {
                    GoToPlanningSubState(PlanningSubState.SelectingRangedUnit);
                }
                return;
            }
            else
            {
                BattleLog.Instance.AddLog($"在階段 {currentPlanningStepIndex + 1} 沒有可行動的單位，自動跳過。");
                
                int phaseIndex = (currentPlanningStepIndex / 2) + 1;
                BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
                ActionPlan skipPlan = ActionPlan.CreateEmptyAction(phaseIndex, stepRole);

                actionPlanner.AddPlan(skipPlan, currentPlanningStepIndex);
                characterStateRule.GenerateAndStoreNextSnapshot(skipPlan, battleActions);
                uiManager.UpdateActionSlots(actionPlanner);
            }
        }
    }
    
    private void GoToNextStep()
    {
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;
        
        AdvancePlanningStep();
    }
    #endregion

    #region 規劃階段輔助方法 (Planning Phase Helper Methods)
    private void GoToPlanningSubState(PlanningSubState nextState, bool isForwardStep = true)
    {
        if (currentSubState == PlanningSubState.SelectingItemTarget && nextState != PlanningSubState.SelectingItemTarget)
        {
            if (CursorManager.Instance != null) 
            {
                CursorManager.Instance.ResetCursor();
                CursorManager.Instance.HideTooltip();
            }
        }
        currentSubState = nextState;
        
        bool canGoBack = planningHistory.Count > 0 && nextState != PlanningSubState.SelectingRangedUnit && nextState != PlanningSubState.None;
        uiManager.SetBackButtonVisible(planningHistory.Count > 0);

        switch (nextState)
        {
            case PlanningSubState.None:
                if (!isForwardStep)
                {
                    BattleLog.Instance.AddLog("已返回至行動格規劃起點。");
                    selectedUnitForAction = null;
                    selectedActionType = default;
                    AdvancePlanningStep();
                }
                else
                {
                    uiManager.ShowPlanningFinishedState();
                }
                break;
                
            case PlanningSubState.SelectingRangedUnit:
                selectedUnitForAction = null;
                selectedActionType = default;
                uiManager.ShowRangedUnitSelection(ConvertFromReadOnlyList(currentEligibleActors), currentPlanningStepIndex);
                break;

            case PlanningSubState.SelectingAction:
                selectedActionType = default;
                var feasibility = battleRules.GetActionFeasibility(selectedUnitForAction, characterStateRule.GetLatestSnapshot(), actionPlanner);
                uiManager.ShowActionSelectionFor(selectedUnitForAction, currentPlanningStepIndex, feasibility);
                break;

            case PlanningSubState.SelectingTarget:
            {
                var validTargets = battleRules.GetValidTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validTargets));
                break;
            }

            case PlanningSubState.SelectingExchangeTarget:
                var validExchangeTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validExchangeTargets));
                break;
            
            case PlanningSubState.SelectingItem:
                selectedItem = null;
                uiManager.ShowItemSelection(OnItemSelected);
                break;

            case PlanningSubState.SelectingItemTarget:
                if (CursorManager.Instance != null && selectedItem != null)
                {
                    CursorManager.Instance.SetCursorIcon(selectedItem.icon);
                    int count = InventoryManager.Instance.GetItemCount(selectedItem);
                    CursorManager.Instance.SetQuantityText(count.ToString());
                    CursorManager.Instance.HideTooltip();
                }
                var validItemTargets = battleRules.GetValidItemTargets(selectedUnitForAction);
                uiManager.ShowItemTargetSelection(ConvertFromReadOnlyList(validItemTargets));
                break;

            case PlanningSubState.SelectingSkill:
                selectedSkill = null;
                var skillFeasibility = new Dictionary<SkillData, bool>();
                var latestSnapshot = characterStateRule.GetLatestSnapshot();
                
                foreach (var skill in selectedUnitForAction.Skills)
                {
                    bool isUsable = battleRules.IsSkillUsable(selectedUnitForAction, skill, latestSnapshot);
                    skillFeasibility.Add(skill, isUsable);
                }
                uiManager.ShowSkillSelection(skillFeasibility, OnSkillSelected);
                break;

            case PlanningSubState.SelectingSkillTarget:
            {
                var validTargets = battleRules.GetValidSkillTargets(selectedUnitForAction, selectedSkill, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validTargets));
                break;
            }
        }
    }

    private List<BattleUnit> ConvertFromReadOnlyList(List<IBattleUnit_ReadOnly> readOnlyList)
    {
        return readOnlyList.Select(u => u.GetMonoBehaviour()).ToList();
    }

    private void ShowActionPanelForUnit(BattleUnit unit)
    {
        var feasibility = battleRules.GetActionFeasibility(unit, characterStateRule.GetLatestSnapshot(), actionPlanner);
        uiManager.ShowActionSelectionFor(unit, currentPlanningStepIndex, feasibility);
    }
    
    private BattleRole GetRoleForStep(int stepIndex)
    {
        return (stepIndex % 2 == 0) ? BattleRole.Vanguard : BattleRole.Ranged1;
    }

    private void UpdateCommanderSkillUI()
    {
        if (uiManager == null) return;
        if (supportUnit == null || supportUnit.IsDead)
        {
            uiManager.SetCommanderSkillButtons(false, false, false);
            return;
        }

        if (!supportUnit.Skills.Any(s => s.isCommanderSkill_OneTimeUse))
        {
            uiManager.SetCommanderSkillButtons(false, false, false);
            return;
        }

        bool canUse = !hasCommanderSkillBeenUsedThisBattle;
        bool isPlanned = (plannedCommanderSkill != null);

        if (hasCommanderSkillBeenUsedThisBattle)
        {
            uiManager.SetCommanderSkillButtons(false, false, false);
        }
        else if (!isPlanned)
        {
            uiManager.SetCommanderSkillButtons(true, false, canUse);
        }
        else
        {
            uiManager.SetCommanderSkillButtons(false, true, true);
        }
    }
    #endregion
    
    #region 行動執行階段 (Action Execution Phase)
    private IEnumerator ExecuteActions()
    {
        foreach(var unit in battleManager.GetAllUnits())
        {
            unit.ResetVisualsToCoreState();
        }

        var processedTransactions = new HashSet<Guid>();
        for (int phase = 1; phase <= 4; phase++)
        {
            var executionOrder = new[]
            {
                new { IsPlayer = true, Role = BattleRole.Vanguard },
                new { IsPlayer = false, Role = BattleRole.Vanguard },
                new { IsPlayer = true, Role = BattleRole.Ranged1 },
                new { IsPlayer = false, Role = BattleRole.Ranged1 }
            };

            foreach(var step in executionOrder)
            {
                yield return StartCoroutine(ExecuteStep(phase, step.IsPlayer, step.Role, processedTransactions));
                if (CheckBattleEnd(phase)) yield break; 
            }
        }
        UpdateAuraEffects();

        if (CurrentState == BattleState.ActionExecution)
        {
            SetState(BattleState.PlayerPlanning);
        }
    }
    
    private IEnumerator ExecuteStep(int phase, bool isPlayer, BattleRole role, HashSet<Guid> processedTransactions)
    {
        ActionPlan plan = actionPlanner.GetActionForRole(phase, isPlayer, role);
        if (plan != null && plan.Type != ActionType.Skip)
        {
            if (plan.Source != null && !plan.Source.IsDead)
            {
                battleActions.Execute(plan, actionPlanner, processedTransactions, battleManager);
                if (plan.Type == ActionType.Exchange && plan.Target != null && !plan.Target.IsDead)
                {
                    BattleUnit sourceUnit = plan.Source.GetMonoBehaviour();
                    BattleUnit targetUnit = plan.Target.GetMonoBehaviour();

                    yield return StartCoroutine(battleManager.AnimateExchangeCoroutine(sourceUnit, targetUnit, 1.5f));
                }
                else
                {
                    yield return new WaitForSeconds(1.0f);
                }
            }
        }
    }

    private IEnumerator ExecuteCommanderSkill()
    {
        if (plannedCommanderSkill == null) yield break;

        BattleLog.Instance.AddLog(LogFormatter.System("==== 指揮官技能發動！ ===="));
        battleActions.Execute(plannedCommanderSkill, null, null, battleManager);
        
        hasCommanderSkillBeenUsedThisBattle = true;
        plannedCommanderSkill = null;

        UpdateCommanderSkillUI();

        yield return new WaitForSeconds(1.5f);
    }

    private bool CheckBattleEnd(int currentPhase)
    {
        actionPlanner.RemovePlansFromDeadUnits(battleManager.GetAllUnits());
        battleManager.HandleTeamPromotions();
        actionPlanner.ValidateAndCleanupInvalidPlans(battleRules, currentPhase);
        uiManager.UpdateActionSlots(actionPlanner);
        
        if (battleRules.IsVictory(battleManager.EnemyUnits))
        {
            SetState(BattleState.Won);
            return true;
        }
        if (battleRules.IsDefeat(battleManager.PlayerUnits))
        {
            SetState(BattleState.Lost);
            return true;
        }
        return false;
    }
    #endregion

    #region 光環效果管理 (Aura Effect Management)
    private void UpdateAuraEffects()
    {
        foreach (var unit in battleManager.GetAllUnits())
        {
            if (unit != null)
            {
                unit.GetComponent<BuffController>()?.ClearAllAuras();
            }
        }
        ApplyAurasForTeam(true);
        ApplyAurasForTeam(false);
    }

    private void ApplyAurasForTeam(bool isPlayerTeam)
    {
        GridPosition supportPos = isPlayerTeam ? GridPosition.PlayerSupport : GridPosition.EnemySupport;
        BattleUnit supportUnit = battleManager.GetUnitAtPosition(supportPos);

        if (supportUnit == null || supportUnit.IsDead) return;

        foreach (var skill in supportUnit.Skills)
        {
            if (skill.skillType == SkillType.CommanderPassive)
            {
                foreach (var effect in skill.effects)
                {
                    if (effect is SkillEffect_ApplyBuff buffEffect && buffEffect.isCommanderPassiveAura)
                    {
                        BattleLog.Instance.AddLog($"{supportUnit.UnitName} 的指揮官被動技能 [{skill.skillName}] 正在發動！");
                        
                        List<BattleUnit> targetTeam;
                        if (skill.targetType == SkillTargetType.Ally_All)
                        {
                            targetTeam = battleManager.GetSameTeam(supportUnit);
                        }
                        else if (skill.targetType == SkillTargetType.Enemy_All)
                        {
                            targetTeam = battleManager.GetOpposingTeam(supportUnit);
                        }
                        else continue;

                        foreach (var buffDef in buffEffect.BuffsToApply)
                        {
                            foreach (var targetUnit in targetTeam)
                            {
                                if (targetUnit != null && !targetUnit.IsDead)
                                {
                                    targetUnit.GetComponent<BuffController>()?.ApplyAura(buffDef, supportUnit);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #endregion
}
```

2. `BattleManager.cs`
```csharp
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class BattleManager : MonoBehaviour
{
    #region 核心數據&模組引用
    public static BattleManager Instance { get; private set; }
    public BattleEncounterSO EncounterData { get; private set; }
    public List<BattleUnit> PlayerUnits { get; private set; }
    public List<BattleUnit> EnemyUnits { get; private set; }
    
    public Transform[] GridSpawns => gridSpawns;
    [SerializeField] private Transform[] gridSpawns = new Transform[8];

    [Header("系統模組")]
    [SerializeField] private TurnManager turnManager;
    [SerializeField] private BattleUIManager uiManager;
    [SerializeField] private BattleRules battleRules;
    [SerializeField] private BattleActions battleActions;
    [SerializeField] private EnemyBattleAI enemyAI;
    [SerializeField] private CharacterStateRule characterStateRule;
    [SerializeField] private BattlefieldStateSimulator stateSimulator;
    
    private TurnActionPlanner actionPlanner;
    #endregion

    #region Unity生命週期
    private void Awake() 
    { 
        Instance = this; 
        if (stateSimulator == null)
        {
            stateSimulator = FindObjectOfType<BattlefieldStateSimulator>();
        }
    }
    
    void Start()
    {
        EncounterData = GameManager.Instance.CurrentEncounter;
        if (EncounterData == null) { Debug.LogError("沒有傳入戰鬥遭遇數據！"); return; }

        SpawnUnits();
        InitializeSystems();
        
        turnManager.StartBattle();
    }
    #endregion

    #region 初始化與單位生成
    private void InitializeSystems()
    {
        actionPlanner = new TurnActionPlanner();
        turnManager.Initialize(this, uiManager, actionPlanner, battleRules, battleActions, enemyAI, characterStateRule, stateSimulator, EncounterData.enemyPersonality);
        uiManager.Initialize(turnManager);
        stateSimulator.Initialize(GetAllUnits(), characterStateRule);
    }
    
    private void SpawnUnits()
    {
        PlayerUnits = new List<BattleUnit>();
        EnemyUnits = new List<BattleUnit>();
    
        var battleParty = PartyManager.Instance.BattleParty;
        for (int i = 0; i < battleParty.Count; i++)
        {
            var role = (BattleRole)i;
            var position = GetInitialPositionForRole(role, true);
            var spawnTransform = gridSpawns[(int)position];
            
            GameObject unitGO = Instantiate(battleParty[i].BaseData.unitPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(battleParty[i], role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            PlayerUnits.Add(unit);
        }
        foreach (var enemyPos in EncounterData.enemyTeam)
        {
            var role = enemyPos.role;
            var position = GetInitialPositionForRole(role, false);
            var spawnTransform = gridSpawns[(int)position];
            GameObject unitGO = Instantiate(enemyPos.enemyData.enemyPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(enemyPos.enemyData, role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            EnemyUnits.Add(unit);
        }
    }
    #endregion

    #region 戰鬥邏輯輔助
    public void HandleTeamPromotions()
    {
        CheckAndPromoteForTeam(PlayerUnits);
        CheckAndPromoteForTeam(EnemyUnits);
    }

    private void CheckAndPromoteForTeam(List<BattleUnit> team)
    {
        var promotionOrder = new List<GridPosition> { GridPosition.PlayerVanguard, GridPosition.PlayerRanged1, GridPosition.PlayerRanged2, GridPosition.PlayerSupport };
        if (team.Any() && !team.First().IsPlayerTeam)
        {
            promotionOrder = new List<GridPosition> { GridPosition.EnemyVanguard, GridPosition.EnemyRanged1, GridPosition.EnemyRanged2, GridPosition.EnemySupport };
        }
        
        for (int i = 0; i < promotionOrder.Count - 1; i++)
        {
            GridPosition currentPos = promotionOrder[i];
            BattleUnit unitAtCurrentPos = GetUnitAtPosition(currentPos, team);
            if (unitAtCurrentPos == null || unitAtCurrentPos.IsDead)
            {
                for (int j = i + 1; j < promotionOrder.Count; j++)
                {
                    GridPosition substitutePos = promotionOrder[j];
                    BattleUnit substituteUnit = GetUnitAtPosition(substitutePos, team);
                    if (substituteUnit != null && !substituteUnit.IsDead)
                    {
                        BattleRole oldRole = substituteUnit.Role;
                        BattleRole newRole = GetRoleForPosition(currentPos);
                        BattleLog.Instance.AddLog($"{substituteUnit.UnitName} (原 {oldRole}) 自動替補到 {currentPos}，新身份為 {newRole}！");
                        
                        substituteUnit.SetNewPosition(currentPos);
                        substituteUnit.SetRole(newRole);
                        substituteUnit.transform.position = gridSpawns[(int)currentPos].position;
                        break;
                    }
                }
            }
        }
    }

    private GridPosition GetInitialPositionForRole(BattleRole role, bool isPlayer)
    {
        if (isPlayer)
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.PlayerVanguard;
                case BattleRole.Ranged1:  return GridPosition.PlayerRanged1;
                case BattleRole.Ranged2:  return GridPosition.PlayerRanged2;
                case BattleRole.Support:  return GridPosition.PlayerSupport;
            }
        }
        else
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.EnemyVanguard;
                case BattleRole.Ranged1:  return GridPosition.EnemyRanged1;
                case BattleRole.Ranged2:  return GridPosition.EnemyRanged2;
                case BattleRole.Support:  return GridPosition.EnemySupport;
            }
        }
        throw new System.Exception("無效的角色或隊伍");
    }

    private BattleRole GetRoleForPosition(GridPosition position)
    {
        switch (position)
        {
            case GridPosition.PlayerVanguard:
            case GridPosition.EnemyVanguard:
                return BattleRole.Vanguard;
            
            case GridPosition.PlayerRanged1:
            case GridPosition.EnemyRanged1:
                return BattleRole.Ranged1;

            case GridPosition.PlayerRanged2:
            case GridPosition.EnemyRanged2:
                return BattleRole.Ranged2;

            case GridPosition.PlayerSupport:
            case GridPosition.EnemySupport:
                return BattleRole.Support;
            
            default:
                Debug.LogError($"無法為位置 {position} 找到對應的身份！");
                return BattleRole.Vanguard;
        }
    }
    #endregion

    #region 動畫協程
    public IEnumerator AnimateExchangeCoroutine(BattleUnit unitA, BattleUnit unitB, float duration)
    {
        Vector3 startPosA = unitA.transform.position;
        Vector3 startPosB = unitB.transform.position;
        
        Transform endTransformA = GridSpawns[(int)unitA.CurrentPosition];
        Transform endTransformB = GridSpawns[(int)unitB.CurrentPosition];

        Vector3 endPosA = endTransformA.position;
        Vector3 endPosB = endTransformB.position;

        float elapsedTime = 0f;
        float swayFrequency = 10f;
        float swayAmplitude = 20f;

        while (elapsedTime < duration)
        {
            elapsedTime += Time.deltaTime;
            float progress = Mathf.Clamp01(elapsedTime / duration);

            unitA.transform.position = Vector3.Lerp(startPosA, endPosA, progress);
            unitB.transform.position = Vector3.Lerp(startPosB, endPosB, progress);

            float sway = Mathf.Sin(progress * Mathf.PI * 2 * (duration / 0.5f)) * swayAmplitude * (1 - progress);
            unitA.transform.rotation = Quaternion.Euler(0, 0, sway);
            unitB.transform.rotation = Quaternion.Euler(0, 0, -sway);

            yield return null;
        }
        unitA.transform.position = endPosA;
        unitB.transform.position = endPosB;
        unitA.transform.rotation = Quaternion.identity;
        unitB.transform.rotation = Quaternion.identity;
    }
    #endregion

    #region 公共查詢方法
    public BattleUnit GetUnitAtPosition(GridPosition pos, List<BattleUnit> team) => team.FirstOrDefault(u => u.CurrentPosition == pos && !u.IsDead);
    public List<BattleUnit> GetAllUnits() => PlayerUnits.Concat(EnemyUnits).ToList();
    public List<BattleUnit> GetOpposingTeam(BattleUnit unit) => unit.IsPlayerTeam ? EnemyUnits : PlayerUnits;
    public List<BattleUnit> GetSameTeam(BattleUnit unit) => unit.IsPlayerTeam ? PlayerUnits : EnemyUnits;
    public BattleUnit GetUnitAtPosition(GridPosition pos)
    {
        if (pos == GridPosition.None) return null;
        return GetAllUnits().FirstOrDefault(u => !u.IsDead && u.CurrentPosition == pos);
    }
    public bool IsBattleWon()
    {
        return turnManager != null && turnManager.CurrentState == BattleState.Won;
    }
    #endregion
}
```

3. `BattleUIManager.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

public class BattleUIManager : MonoBehaviour
{
    #region 引用與初始化
    private TurnManager turnManager;

    [Header("UI 面板")]
    [SerializeField] private ActionPanelUI actionPanel;
    [SerializeField] private ActionSlotPanelUI actionSlotPanel;
    [SerializeField] private BattleUI battleUI;
    [SerializeField] private BattleEndUI battleEndUI;
    [SerializeField] private BattleItemUI battleItemPanel;
    [SerializeField] private SkillSelectionPanelUI skillSelectionPanel;
    
    public void Initialize(TurnManager tm)
    {
        turnManager = tm;
        battleUI.Setup(cmd => OnUICommand(cmd, null));
        actionSlotPanel.Initialize((cmd, plan) => OnUICommand(cmd, plan));
        UISoundAutoHook.HookEntireScene();
    }
    #endregion
    
    #region 主狀態UI控制
    public void EnterPlayerPlanningState(TurnActionPlanner planner)
    {
        HideAllActionPanels();
        actionSlotPanel.UpdatePanel(planner);
        actionSlotPanel.gameObject.SetActive(true);
        battleUI.SetEndTurnButtonInteractable(false);
        battleUI.SetResetButtonVisible(true);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterEnemyTurnState()
    {
        HideAllActionPanels();
        battleUI.SetEndTurnButtonInteractable(false);
        battleUI.SetResetButtonVisible(false);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterActionExecutionState()
    {
        HideAllActionPanels();
    }
    #endregion
    
    #region 引導式規劃UI
    public void ShowRangedUnitSelection(List<BattleUnit> units, int stepIndex)
    {
        HideAllActionPanels();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        units.ForEach(u => u.SetHighlight(true));
        battleUI.SetBackButtonVisible(false);
        BattleLog.Instance.AddLog("請選擇一位遠程單位來規劃行動。");
    }

    public void ShowActionSelectionFor(BattleUnit unit, int stepIndex, Dictionary<ActionType, bool> feasibility)
    {
        DeselectAllHighlights();
        unit.SetHighlight(true);
        
        actionPanel.ShowPanel(unit, turnManager.OnActionSelected);
        actionPanel.UpdateButtonStates(feasibility);
        
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        battleUI.SetBackButtonVisible(true);
    }
    
    public void ShowTargetSelection(List<BattleUnit> validTargets)
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        validTargets.ForEach(t => t.SetHighlight(true));
        BattleLog.Instance.AddLog("請選擇一個目標。");
    }

    public void ShowItemSelection(System.Action<Item> onItemSelected)
    {
        HideAllActionPanels();
        DeselectAllHighlights();
        battleItemPanel.ShowPanel(onItemSelected);
        BattleLog.Instance.AddLog("請選擇要使用的道具。");
    }

    public void ShowItemTargetSelection(List<BattleUnit> validTargets)
    {
        if (battleItemPanel != null) battleItemPanel.HidePanel();
        DeselectAllHighlights();
        validTargets.ForEach(t => t.SetHighlight(true));
        BattleLog.Instance.AddLog("請選擇使用對象。");
    }

    public void ShowPlanningFinishedState()
    {
        HideAllActionPanels();
        actionSlotPanel.SetPlanningHighlight(-1);
        battleUI.SetEndTurnButtonInteractable(true);
        battleUI.SetBackButtonVisible(false);
    }

    public void ShowSkillSelection(Dictionary<SkillData, bool> skillFeasibility, System.Action<SkillData> onSkillSelectedCallback)
    {
        HideAllActionPanels();
        DeselectAllHighlights();

        if (skillSelectionPanel != null)
        {
            skillSelectionPanel.ShowPanel(skillFeasibility, onSkillSelectedCallback);
        }
        else
        {
            Debug.LogError("BattleUIManager 未指定 SkillSelectionPanelUI！");
        }
    }
    
    public void UpdateActionSlots(TurnActionPlanner planner)
    {
        actionSlotPanel.UpdatePanel(planner);
    }
    #endregion

    #region 通用UI控制
    public void ShowVictoryScreen(int gold) { battleEndUI.ShowVictory(gold); }
    public void ShowDefeatScreen() { battleEndUI.ShowDefeat(); }
    public void SetResetButtonVisible(bool visible)
    {
        if (battleUI != null)
        {
            battleUI.SetResetButtonVisible(visible);
        }
    }
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        if (battleUI != null)
        {
            battleUI.SetEndTurnButtonInteractable(interactable);
        }
    }
    public void SetBackButtonVisible(bool visible)
    {
        if (battleUI != null)
        {
            battleUI.SetBackButtonVisible(visible);
        }
    }

    public void SetCommanderSkillButtons(bool showUseButton, bool showCancelButton, bool isInteractable)
    {
        if (battleUI != null)
        {
            battleUI.SetCommanderSkillButtons(showUseButton, showCancelButton, isInteractable);
        }
        else
        {
            Debug.LogWarning("BattleUIManager 無法控制指揮官技能按鈕，因為 BattleUI 未指定！");
        }
    }
    
    private void HideAllActionPanels()
    {
        actionPanel.HidePanel();
        if (battleItemPanel != null) battleItemPanel.HidePanel();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(-1);
    }

    public void HideItemSelectionPanel()
    {
        if (battleItemPanel != null)
        {
            battleItemPanel.HidePanel();
        }
    }
    
    public void HideSkillSelectionPanel()
    {
        if (skillSelectionPanel != null)
        {
            skillSelectionPanel.HidePanel();
        }
    }

    private void DeselectAllHighlights()
    {
        if (BattleManager.Instance == null) return;
        foreach(var unit in BattleManager.Instance.PlayerUnits) unit.SetHighlight(false);
        foreach(var unit in BattleManager.Instance.EnemyUnits) unit.SetHighlight(false);
    }
    #endregion
    
    #region 事件傳遞
    private void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        turnManager.OnUICommand(command, planData);
    }
    #endregion
}
```

4. `BattleVFXManager.cs`
```
using UnityEngine;
using System.Collections.Generic;
using TMPro;

public enum VFXType
{
    GenericAttack,
    GenericHeal,
    IncreaseAttackBuff,
    IncreaseDefenseBuff,
    AddShieldBuff,
    
    Text_Damage,
    Text_Heal,
    Text_Shield,
    Text_Info,
    Text_Miss
}

public class BattleVFXManager : MonoBehaviour
{
    public static BattleVFXManager Instance { get; private set; }

    [System.Serializable]
    public class VFXPrefab
    {
        public VFXType type;
        public GameObject prefab;
    }

    [Header("特效設定")]
    [SerializeField] private List<VFXPrefab> vfxList;
    private Dictionary<VFXType, GameObject> vfxDictionary;

    [Header("飄字設定")]
    [SerializeField] private GameObject floatingTextPrefab;
    [SerializeField] private int textPoolSize = 20;
    
    private Queue<FloatingText> textPool = new Queue<FloatingText>();

    void Awake()
    {
        Instance = this;
        vfxDictionary = new Dictionary<VFXType, GameObject>();
        foreach (var vfx in vfxList)
        {
            vfxDictionary[vfx.type] = vfx.prefab;
        }
        
        InitializeTextPool();
    }

    private void InitializeTextPool()
    {
        if (floatingTextPrefab == null) return;
        
        GameObject poolRoot = new GameObject("VFX_TextPool");
        poolRoot.transform.SetParent(this.transform);

        for (int i = 0; i < textPoolSize; i++)
        {
            CreateTextObject(poolRoot.transform);
        }
    }

    private FloatingText CreateTextObject(Transform parent)
    {
        GameObject obj = Instantiate(floatingTextPrefab, parent);
        FloatingText textComp = obj.GetComponent<FloatingText>();
        obj.SetActive(false);
        textPool.Enqueue(textComp);
        return textComp;
    }

    public void PlayVFX(VFXType type, Vector3 position)
    {
        if (vfxDictionary.TryGetValue(type, out GameObject prefab))
        {
            Instantiate(prefab, position, Quaternion.identity);
        }
    }

    public void ShowText(Vector3 position, string content, VFXType type)
    {
        if (textPool.Count == 0) CreateTextObject(transform);
        FloatingText txt = textPool.Dequeue();
        Color color = Color.white;
        float fontSize = 4f;

        switch (type)
        {
            case VFXType.Text_Damage: color = new Color(1f, 0.3f, 0.3f); fontSize = 5f; break; // 紅
            case VFXType.Text_Heal:   color = new Color(0.3f, 1f, 0.3f); fontSize = 5f; break; // 綠
            case VFXType.Text_Shield: color = new Color(0.3f, 0.8f, 1f); break; // 藍
            case VFXType.Text_Miss:   color = Color.gray; break;
            default:                  color = Color.white; break;
        }
        txt.transform.position = position;
        txt.Setup(content, color, fontSize);
        txt.gameObject.SetActive(true);
        textPool.Enqueue(txt); 
    }
}
```

5. `GameManager.cs`


### **戰鬥邏輯**

1. `BattleRules.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "BattleRules", menuName = "Battle System/Battle Rules")]
public class BattleRules : ScriptableObject
{
    public List<IBattleUnit_ReadOnly> GetEligibleActorsForStep(int stepIndex, List<CharacterStateRule.UnitStateSnapshot> currentState, TurnActionPlanner planner)
    {
        var eligibleActors = new List<IBattleUnit_ReadOnly>();
        bool isVanguardStep = (stepIndex % 2 == 0);
        var potentialActorSnaps = currentState.Where(s => s.Unit.IsPlayerTeam && !s.Unit.IsDead && s.Role != BattleRole.Support).ToList();

        foreach (var snap in potentialActorSnaps)
        {
            bool isUnitVanguardInSnapshot = (snap.Role == BattleRole.Vanguard);
            if ((isVanguardStep && !isUnitVanguardInSnapshot) || (!isVanguardStep && isUnitVanguardInSnapshot)) continue;

            int maxActions = (snap.Role == BattleRole.Vanguard) ? 4 : 2;

            if (planner.GetActionCountForUnit(snap.Unit) < maxActions)
            {
                eligibleActors.Add(snap.Unit);
            }
        }
        return eligibleActors;
    }

    private bool CanUnitAct(IBattleUnit_ReadOnly unit, TurnActionPlanner planner, int maxActions)
    {
        if (unit == null || unit.IsDead) return false;
        return planner.GetActionCountForUnit(unit) < maxActions;
    }
    
    public Dictionary<ActionType, bool> GetActionFeasibility(IBattleUnit_ReadOnly actor, CharacterStateRule.BattleStateSnapshot currentState, TurnActionPlanner planner)
    {
        var feasibility = new Dictionary<ActionType, bool>();
        var unitSnaps = currentState.UnitSnapshots;
        var actorSnap = unitSnaps.FirstOrDefault(s => s.Unit == actor);
        if (actorSnap == null) 
        {
            foreach (ActionType type in System.Enum.GetValues(typeof(ActionType)))
            {
                feasibility[type] = false;
            }
            return feasibility;
        }

        feasibility[ActionType.Attack] = GetValidTargets(actor, unitSnaps).Any() && actorSnap.Stamina >= 3;
        feasibility[ActionType.Exchange] = GetValidExchangeTargets(actor,unitSnaps).Any() && actorSnap.Stamina >= 2; 
        feasibility[ActionType.Item] = currentState.InventorySnapshot.HasAnyConsumables();
        
        bool hasAnyUsableSkill = false;
        if (actor.Skills != null && actor.Skills.Count > 0)
        {
            foreach (var skill in actor.Skills)
            {
                if (IsSkillUsable(actor, skill, currentState))
                {
                    hasAnyUsableSkill = true;
                    break;
                }
            }
        }
        feasibility[ActionType.Skill] = hasAnyUsableSkill;
        feasibility[ActionType.Defend] = true;
        feasibility[ActionType.Rest] = true;
        feasibility[ActionType.Skip] = true;
        
        return feasibility;
    }

    public List<IBattleUnit_ReadOnly> GetValidTargets(IBattleUnit_ReadOnly attacker, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (attacker == null || attacker.IsDead) return validTargets;

        var attackerSnap = currentState.First(s => s.Unit == attacker);
        var opponentSnaps = currentState.Where(s => s.Unit.IsPlayerTeam != attacker.IsPlayerTeam && !s.Unit.IsDead && s.Role != BattleRole.Support);

        var enemyVanguardSnap = opponentSnaps.FirstOrDefault(s => s.Role == BattleRole.Vanguard);

        IEnumerable<CharacterStateRule.UnitStateSnapshot> potentialTargets = (enemyVanguardSnap != null) 
            ? new List<CharacterStateRule.UnitStateSnapshot> { enemyVanguardSnap } 
            : opponentSnaps;

        foreach (var targetSnap in potentialTargets)
        {
            int distance = Mathf.Abs((int)attackerSnap.Position - (int)targetSnap.Position);
            if (distance <= attacker.AttackRange)
            {
                validTargets.Add(targetSnap.Unit);
            }
        }
        return validTargets;
    }
    
    public bool IsExchangeValidNow(IBattleUnit_ReadOnly unitA, IBattleUnit_ReadOnly unitB)
    {
        if (unitA == null || unitB == null || unitA.IsDead || unitB.IsDead) return false;
        if (unitA.Role == BattleRole.Support || unitB.Role == BattleRole.Support) return false;
        var roleA = unitA.Role;
        var roleB = unitB.Role;
        switch (roleA)
        {
            case BattleRole.Vanguard:
                return roleB == BattleRole.Ranged1;
            case BattleRole.Ranged1:
                return roleB == BattleRole.Vanguard || roleB == BattleRole.Ranged2;
            case BattleRole.Ranged2:
                return roleB == BattleRole.Ranged1;
            default:
                return false;
        }
    }

    public List<IBattleUnit_ReadOnly> GetValidExchangeTargets(IBattleUnit_ReadOnly actor, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (actor == null || actor.IsDead || actor.Role == BattleRole.Support) return validTargets;
        
        var actorSnap = currentState.First(s => s.Unit == actor);
        var teammateSnaps = currentState.Where(s => s.Unit.IsPlayerTeam == actor.IsPlayerTeam && s.Unit != actor && !s.Unit.IsDead && s.Role != BattleRole.Support);

        foreach (var mateSnap in teammateSnaps)
        {
            bool canSwap = false;
            switch (actorSnap.Role)
            {
                case BattleRole.Vanguard: canSwap = (mateSnap.Role == BattleRole.Ranged1); break;
                case BattleRole.Ranged1: canSwap = (mateSnap.Role == BattleRole.Vanguard || mateSnap.Role == BattleRole.Ranged2); break;
                case BattleRole.Ranged2: canSwap = (mateSnap.Role == BattleRole.Ranged1); break;
            }
            if(canSwap) validTargets.Add(mateSnap.Unit);
        }
        return validTargets;
    }

    public List<IBattleUnit_ReadOnly> GetValidItemTargets(IBattleUnit_ReadOnly user)
    {
        if (user == null || user.IsDead) return new List<IBattleUnit_ReadOnly>();

        var teammates = user.IsPlayerTeam ? BattleManager.Instance.PlayerUnits : BattleManager.Instance.EnemyUnits;
        return teammates.Where(u => !u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
    }

    public List<IBattleUnit_ReadOnly> GetValidSkillTargets(IBattleUnit_ReadOnly source, SkillData skill, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (source == null || skill == null) return validTargets;

        var sourceSnap = currentState.First(s => s.Unit == source);

        switch (skill.targetType)
        {
            case SkillTargetType.Enemy_Single:
                var opponentSnaps = currentState.Where(s => s.Unit.IsPlayerTeam != source.IsPlayerTeam && !s.Unit.IsDead);
                foreach (var targetSnap in opponentSnaps)
                {
                    int distance = Mathf.Abs((int)sourceSnap.Position - (int)targetSnap.Position);
                    if (skill.range == 0 || distance <= skill.range)
                    {
                        validTargets.Add(targetSnap.Unit);
                    }
                }
                break;

            case SkillTargetType.Ally_Single:
                var allySnaps = currentState.Where(s => s.Unit.IsPlayerTeam == source.IsPlayerTeam && !s.Unit.IsDead && s.Unit != source);
                foreach (var targetSnap in allySnaps)
                {
                    int distance = Mathf.Abs((int)sourceSnap.Position - (int)targetSnap.Position);
                    if (skill.range == 0 || distance <= skill.range)
                    {
                        validTargets.Add(targetSnap.Unit);
                    }
                }
                break;
            case SkillTargetType.None:
            case SkillTargetType.Self:
            case SkillTargetType.Ally_All:
            case SkillTargetType.Enemy_All:
            case SkillTargetType.Enemy_Penetrate:
            default:
                break;
        }
        return validTargets;
    }
    
    private bool HasConsumableItems()
    {
        if (InventoryManager.Instance == null || InventoryManager.Instance.playerInventoryData == null)
        {
            return false;
        }
        return InventoryManager.Instance.playerInventoryData.slots.Any(s => !s.IsEmpty() && s.item.itemType == ItemType.Consumable);
    }

    public bool IsVictory(List<BattleUnit> enemyUnits) => enemyUnits.All(u => u.IsDead);
    public bool IsDefeat(List<BattleUnit> playerUnits) => playerUnits.All(u => u.IsDead);
    public bool IsSkillUsable(IBattleUnit_ReadOnly source, SkillData skill, CharacterStateRule.BattleStateSnapshot currentState)
    {
        if (source == null || skill == null || currentState == null) return false;

        // 1. 檢查體力是否足夠
        var sourceSnap = currentState.UnitSnapshots.FirstOrDefault(s => s.Unit == source);
        if (sourceSnap == null || sourceSnap.Stamina < skill.staminaCost)
        {
            return false;
        }
        
        // 2. 檢查指揮官技能的使用次數 (未來擴充點)
        // if (skill.isCommanderSkill_OneTimeUse && battleManager.HasCommanderSkillBeenUsed())
        // {
        //     return false;
        // }

        // (未來可擴充) 3. 檢查是否有沉默等特殊狀態
        // if (source.IsSilenced) return false;

        // 所有檢查都通過，技能可用
        return true;
    }
}
```

2. `BattleActions.cs`
```csharp
using UnityEngine;
using System;
using System.Linq;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "BattleActions", menuName = "Battle System/Battle Actions")]
public class BattleActions : ScriptableObject
{
    [Header("行動數值")]
    [SerializeField] private int attackStaminaCost = 3;
    [SerializeField] private int exchangeStaminaCost = 2;
    [SerializeField] private int restStaminaRecovery = 5;

    public int GetAttackStaminaCost() => attackStaminaCost;
    public int GetExchangeStaminaCost() => exchangeStaminaCost;
    public int GetRestStaminaRecovery() => restStaminaRecovery;

    public void Execute(ActionPlan plan, TurnActionPlanner planner, HashSet<Guid> processedTransactions, BattleManager battleManager)
    {
        BattleUnit sourceUnit = plan.Source?.GetMonoBehaviour();
        if (sourceUnit == null || sourceUnit.IsDead) return;
        // 處理關聯行動的唯一性 (交換位置)
        if (plan.Type == ActionType.Exchange && plan.TransactionID != Guid.Empty)
        {
            if (processedTransactions.Contains(plan.TransactionID)) return;
            processedTransactions.Add(plan.TransactionID);
        }
        ActionType finalActionType = plan.Type;
        BattleUnit finalTargetUnit = null;

        switch (plan.Type)
        {
            // 地域契約
            case ActionType.Attack:
                finalTargetUnit = battleManager.GetUnitAtPosition(plan.TargetPosition);
                
                // 指令失效判斷：如果目標位置上沒人，或者站著自己人
                if (finalTargetUnit == null || finalTargetUnit.IsPlayerTeam == sourceUnit.IsPlayerTeam)
                {
                    finalActionType = (sourceUnit.Role == BattleRole.Vanguard) ? ActionType.Defend : ActionType.Rest;
                    BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 的攻擊位置 [{plan.TargetPosition}] 已無有效目標，行動變更為 [{finalActionType.ToActionName()}]！");
                    finalTargetUnit = null;
                }
                break;

            // 人事契約
            case ActionType.Exchange:
                // 直接從契約獲取乙方本人
                finalTargetUnit = plan.Target?.GetMonoBehaviour();
                // 指令失效判斷：如果契約乙方不存在或已陣亡
                if (finalTargetUnit == null || finalTargetUnit.IsDead)
                {
                    finalActionType = ActionType.Rest;
                    BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 的交換目標 [{plan.Target.UnitName}] 已消失，行動變更為 [{finalActionType.ToActionName()}]！");
                    finalTargetUnit = null;
                }
                break;
            
            // 人事契約
            case ActionType.Item:
                finalTargetUnit = plan.Target?.GetMonoBehaviour();
                // 指令失效判斷：如果目標已陣亡或道具沒了
                if (finalTargetUnit == null || finalTargetUnit.IsDead || plan.ItemUsed == null)
                {
                    finalActionType = ActionType.Rest;
                    finalTargetUnit = null;
                    BattleLog.Instance.AddLog($"{plan.Source.UnitName} 的道具目標已消失，行動變更為休息！");
                }
                break;

            // 無目標行動
            case ActionType.Defend:
            case ActionType.Rest:
            case ActionType.Skip:
                finalTargetUnit = null;
                break;
        }
        
        switch (finalActionType)
        {
            case ActionType.Attack:
                ExecuteAttack(sourceUnit, finalTargetUnit);
                break;
            case ActionType.Defend:
                ExecuteDefend(sourceUnit);
                break;
            case ActionType.Rest:
                ExecuteRest(sourceUnit);
                break;
            case ActionType.Exchange:
                ExecuteExchange(sourceUnit, finalTargetUnit, battleManager);
                break;
            case ActionType.Item:
                ExecuteItem(plan.Source.GetMonoBehaviour(), finalTargetUnit, plan.ItemUsed);
                break;
            case ActionType.Skip:
                BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 選擇跳過行動。");
                break;
            case ActionType.Skill:
                ExecuteSkill(plan, battleManager);
                break;
        }
    }

    private void ExecuteAttack(BattleUnit source, BattleUnit target)
    {
        source.ConsumeStamina(attackStaminaCost);
        BattleLog.Instance.AddLog($"{source.UnitName} 對 {target.UnitName} 發動攻擊！");
        target.TakeDamage(source.CurrentAttack);
    }
    
    private void ExecuteDefend(BattleUnit source)
    {
        source.SetDefenseState(true);
        BattleLog.Instance.AddLog($"{source.UnitName} 進入防禦姿態。");
    }

    private void ExecuteRest(BattleUnit source)
    {
        source.RestoreStamina(restStaminaRecovery);
        BattleLog.Instance.AddLog($"{source.UnitName} 休息，恢復 {restStaminaRecovery} 體力。");
    }

    private void ExecuteExchange(BattleUnit source, BattleUnit target, BattleManager battleManager)
    {
        source.ConsumeStamina(exchangeStaminaCost);
        BattleLog.Instance.AddLog($"{source.UnitName} 與 {target.UnitName} 進行位置交換！");

        // 獲取雙方【當前】的核心數據
        GridPosition posA = source.CurrentPosition;
        GridPosition posB = target.CurrentPosition;
        BattleRole roleA = source.Role;
        BattleRole roleB = target.Role;

        // --- 執行核心數據交換 ---
        source.SetNewPosition(posB);
        target.SetNewPosition(posA);
        source.SetRole(roleB);
        target.SetRole(roleA);

        // 移除視覺交換邏輯，這部分將交由 TurnManager 的協程處理
        // if (battleManager.GridSpawns[(int)posB] != null)
        // {
        //     source.transform.position = battleManager.GridSpawns[(int)posB].position;
        // }
        // if (battleManager.GridSpawns[(int)posA] != null)
        // {
        //     target.transform.position = battleManager.GridSpawns[(int)posA].position;
        // }
    }

    private void ExecuteItem(BattleUnit source, BattleUnit target, Item item)
    {
        if (item.itemType != ItemType.Consumable) return;
        bool removed = InventoryManager.Instance.RemoveItem(item, 1);
        if (!removed)
        {
            BattleLog.Instance.AddLog($"行動失敗：背包中找不到 {item.itemName}！行動變更為休息。");
            ExecuteRest(source);
            return;
        }
        BattleLog.Instance.AddLog($"{source.UnitName} 對 {target.UnitName} 使用了 {item.itemName}！");

        // 根據道具效果修改目標狀態
        if (item.healAmount > 0)
        {
            target.Heal(item.healAmount);
        }
        // 未來可以在這裡擴充其他道具效果，如解除負面狀態、增加攻擊力等
    }

    private void ExecuteSkill(ActionPlan plan, BattleManager battleManager)
    {
        IBattleUnit_ReadOnly source = plan.Source;
        SkillData skill = plan.SkillUsed;

        if (source == null || source.IsDead || skill == null) return;

        BattleLog.Instance.AddLog($"{source.UnitName} 施放技能 [{skill.skillName}]！");

        // 1. 使用優化後的 GetTargetsForSkill 方法獲取所有受影響的目標
        List<IBattleUnit_ReadOnly> allTargets = GetTargetsForSkill(source, plan.Target, skill.targetType, battleManager);
        
        // 2. 消耗施法者的體力
        source.GetMonoBehaviour().ConsumeStamina(skill.staminaCost);

        // 3. 遍歷技能的所有效果並執行
        foreach(var effect in skill.effects)
        {
            if(effect != null)
            {
                effect.Execute(source, allTargets, battleManager);
            }
        }
    }

    private List<IBattleUnit_ReadOnly> GetTargetsForSkill(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly manualTarget, SkillTargetType targetType, BattleManager bm)
    {
        var targets = new List<IBattleUnit_ReadOnly>();
        
        var playerUnits = bm.PlayerUnits.Where(u => u != null && !u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
        var enemyUnits = bm.EnemyUnits.Where(u => u != null && !u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
        
        switch (targetType)
        {
            case SkillTargetType.Self:
                targets.Add(source);
                break;

            case SkillTargetType.Ally_Single:
            case SkillTargetType.Enemy_Single:
                if (manualTarget != null && !manualTarget.IsDead)
                {
                    targets.Add(manualTarget);
                }
                break;

            case SkillTargetType.Ally_All:
                targets.AddRange(source.IsPlayerTeam ? playerUnits : enemyUnits);
                break;

            case SkillTargetType.Enemy_All:
                targets.AddRange(source.IsPlayerTeam ? enemyUnits : playerUnits);
                break;

            case SkillTargetType.Enemy_Penetrate:
                var opponents = source.IsPlayerTeam ? enemyUnits : playerUnits;
                var vanguard = opponents.FirstOrDefault(u => u.Role == BattleRole.Vanguard);
                var ranged1 = opponents.FirstOrDefault(u => u.Role == BattleRole.Ranged1);
                if (vanguard != null) targets.Add(vanguard);
                if (ranged1 != null) targets.Add(ranged1);
                break;
                
            case SkillTargetType.None:
            default:
                break;
        }
        return targets;
    }
}
```

3. `TurnActionPlanner.cs`
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class TurnActionPlanner
{
    private const int TOTAL_PLAYER_STEPS = 8;
    private int turnNumber = 0;
    private Dictionary<int, ActionPlan> playerPlansByStep = new Dictionary<int, ActionPlan>();
    private List<ActionPlan> enemyPlans = new List<ActionPlan>();

    public int GetPlayerPlanCount() => playerPlansByStep.Count;
    public bool IsPlanningFinished() => playerPlansByStep.Count >= TOTAL_PLAYER_STEPS;
    public bool IsStepPlanned(int stepIndex) => playerPlansByStep.ContainsKey(stepIndex);

    public int GetNextPlanningStepIndex()
    {
        for (int i = 0; i < TOTAL_PLAYER_STEPS; i++)
        {
            if (!playerPlansByStep.ContainsKey(i))
            {
                return i;
            }
        }
        return TOTAL_PLAYER_STEPS;
    }
    
    public int FindNextAvailableStep(BattleRole role, int startIndex = 0, List<int> excludeIndices = null)
    {
        bool isLookingForVanguard = (role == BattleRole.Vanguard);
        excludeIndices = excludeIndices ?? new List<int>();

        for (int i = startIndex; i < TOTAL_PLAYER_STEPS; i++)
        {
            if (playerPlansByStep.ContainsKey(i) || excludeIndices.Contains(i)) continue;

            bool isVanguardStep = (i % 2 == 0);

            if ((isLookingForVanguard && isVanguardStep) || (!isLookingForVanguard && !isVanguardStep)) return i;
        }
        return -1;
    }

    public void AddPlan(ActionPlan plan, int stepIndex)
    {
        if (plan.Type == ActionType.Skip && plan.Source == null)
        {
            if (stepIndex >= 0 && stepIndex < TOTAL_PLAYER_STEPS)
            {
                playerPlansByStep[stepIndex] = plan;
            }
            return;
        }

        if (plan.Source.IsPlayerTeam)
        {
            if (stepIndex >= 0 && stepIndex < TOTAL_PLAYER_STEPS)
            {
                playerPlansByStep[stepIndex] = plan;
            }
            else
            {
                Debug.LogError($"嘗試為玩家計畫添加無效的步驟索引: {stepIndex}");
            }
        }
        else
        {
            enemyPlans.Add(plan);
        }
    }

    public ActionPlan GetPlanAtStep(int stepIndex)
    {
        playerPlansByStep.TryGetValue(stepIndex, out ActionPlan plan);
        return plan;
    }
    
    public int GetLastPlayerPlanStepIndex()
    {
        if (playerPlansByStep.Count == 0) return -1;
        
        for (int i = TOTAL_PLAYER_STEPS - 1; i >= 0; i--)
        {
            if (playerPlansByStep.TryGetValue(i, out ActionPlan plan))
            {
                if (plan.Source != null)
                {
                    return i;
                }
            }
        }
        return -1;
    }
    
    public void RemovePlansFromStepOnward(int startStepIndex)
    {
        if (startStepIndex < 0) return;

        var keysToRemove = playerPlansByStep.Keys.Where(k => k >= startStepIndex).ToList();
        foreach (var key in keysToRemove)
        {
            playerPlansByStep.Remove(key);
        }
    }

    public int GetStepIndexOfPlan(ActionPlan plan)
    {
        if (plan == null) return -1;
        foreach (var pair in playerPlansByStep)
        {
            if (pair.Value == plan)
            {
                return pair.Key;
            }
        }
        return -1;
    }
    
    public int GetLastPlanStepIndex()
    {
        if (playerPlansByStep.Count == 0) return -1;
        return playerPlansByStep.Keys.Max();
    }

    public void RemovePlansFromStep(int stepIndex)
    {
        if (playerPlansByStep.TryGetValue(stepIndex, out ActionPlan planToRemove))
        {
            if (planToRemove.TransactionID != Guid.Empty)
            {
                var keysToRemove = playerPlansByStep
                    .Where(pair => pair.Value.TransactionID == planToRemove.TransactionID)
                    .Select(pair => pair.Key)
                    .ToList();
                
                foreach (var key in keysToRemove)
                {
                    playerPlansByStep.Remove(key);
                }
            }
            else
            {
                playerPlansByStep.Remove(stepIndex);
            }
        }
    }
    
    public void ClearPlayerPlans()
    {
        playerPlansByStep.Clear();
    }
    
    public void PrepareForNewTurn()
    {
        var allUnitsWithDefense = new HashSet<IBattleUnit_ReadOnly>();
        foreach(var plan in playerPlansByStep.Values)
        {
            if (plan.Type == ActionType.Defend) allUnitsWithDefense.Add(plan.Source);
        }
        foreach(var plan in enemyPlans)
        {
            if (plan.Type == ActionType.Defend) allUnitsWithDefense.Add(plan.Source);
        }
        foreach(var unit in allUnitsWithDefense)
        {
            unit.GetMonoBehaviour().SetDefenseState(false);
        }
        turnNumber++;
        playerPlansByStep.Clear();
        enemyPlans.Clear();
    }

    public int GetCurrentTurnNumber()
    {
        return turnNumber;
    }

    public ActionPlan GetActionForRole(int phase, bool isPlayer, BattleRole role)
    {
        if (isPlayer)
        {
            for (int i = 0; i < 8; i++)
            {
                if (playerPlansByStep.TryGetValue(i, out ActionPlan plan))
                {
                    bool isVanguardStep = (plan.PlannedForRole == BattleRole.Vanguard);
                    bool roleMatch = (role == BattleRole.Vanguard) ? isVanguardStep : !isVanguardStep;

                    if (plan.PhaseIndex == phase && roleMatch) return plan;
                }
            }
            return null;
        }
        else
        {
            return enemyPlans.FirstOrDefault(p =>
                p.PhaseIndex == phase &&
                (p.Source == null || !p.Source.IsPlayerTeam) && 
                (
                    (role == BattleRole.Vanguard && p.PlannedForRole == BattleRole.Vanguard) ||
                    (role != BattleRole.Vanguard && (p.PlannedForRole == BattleRole.Ranged1 || p.PlannedForRole == BattleRole.Ranged2))
                )
            );
        }
    }
    
    public int GetActionCountForUnit(IBattleUnit_ReadOnly unit)
    {
        return playerPlansByStep.Values.Count(p => p.Source == unit) + enemyPlans.Count(p => p.Source == unit);
    }
    
    public void RemovePlansFromDeadUnits(List<BattleUnit> allUnits)
    {
        var deadUnits = allUnits.Where(u => u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
        if (deadUnits.Any())
        {
            var playerKeysToRemove = playerPlansByStep
                .Where(pair => deadUnits.Contains(pair.Value.Source) || (pair.Value.Target != null && deadUnits.Contains(pair.Value.Target)))
                .Select(pair => pair.Key)
                .ToList();
                
            foreach (var key in playerKeysToRemove)
            {
                playerPlansByStep.Remove(key);
            }
            
            int removedEnemyCount = enemyPlans.RemoveAll(p => deadUnits.Contains(p.Source) || (p.Target != null && deadUnits.Contains(p.Target)));

            if (playerKeysToRemove.Count > 0 || removedEnemyCount > 0)
            {
                BattleLog.Instance.AddLog($"因單位陣亡，移除了 {playerKeysToRemove.Count + removedEnemyCount} 個無效的行動計畫。");
            }
        }
    }
    
    public void ValidateAndCleanupInvalidPlans(BattleRules rules, int currentPhase)
    {
        var keysToRemove = new List<int>();
        var exchangeTransactions = playerPlansByStep
            .Where(pair => pair.Value.PhaseIndex > currentPhase && 
                        pair.Value.Type == ActionType.Exchange && 
                        pair.Value.TransactionID != Guid.Empty)
            .GroupBy(pair => pair.Value.TransactionID);

        foreach (var transactionGroup in exchangeTransactions)
        {
            var plansInTransaction = transactionGroup.Select(pair => pair.Value).ToList();
            if (plansInTransaction.Count < 2) continue;

            var unitA = plansInTransaction[0].Source;
            var unitB = plansInTransaction[0].Target;
            
            if (unitA == null || unitB == null || unitA.IsDead || unitB.IsDead) continue;
            
            bool isStillValid = rules.IsExchangeValidNow(unitA, unitB);

            if (!isStillValid)
            {
                BattleLog.Instance.AddLog($"因戰局變化，{unitA.UnitName} 與 {unitB.UnitName} 的【未來】交換計畫已失效並被取消。");
                foreach (var pair in transactionGroup)
                {
                    keysToRemove.Add(pair.Key);
                }
            }
        }

        if (keysToRemove.Any())
        {
            foreach (var key in keysToRemove)
            {
                playerPlansByStep.Remove(key);
            }
        }
    }
}
```

4. `CharacterStateRule.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "CharacterStateRule", menuName = "Battle System/Character State Rule")]
public class CharacterStateRule : ScriptableObject
{
    #region 背包模擬
    public class SimulatedInventory
    {
        private Dictionary<string, int> consumableCounts;

        public SimulatedInventory()
        {
            consumableCounts = new Dictionary<string, int>();
            if (InventoryManager.Instance != null && InventoryManager.Instance.playerInventoryData != null)
            {
                foreach (var slot in InventoryManager.Instance.playerInventoryData.slots)
                {
                    if (!slot.IsEmpty() && slot.item.itemType == ItemType.Consumable)
                    {
                        if (consumableCounts.ContainsKey(slot.item.uniqueItemID))
                        {
                            consumableCounts[slot.item.uniqueItemID] += slot.quantity;
                        }
                        else
                        {
                            consumableCounts[slot.item.uniqueItemID] = slot.quantity;
                        }
                    }
                }
            }
        }

        public SimulatedInventory(SimulatedInventory source)
        {
            this.consumableCounts = new Dictionary<string, int>(source.consumableCounts);
        }

        public void ConsumeItem(string itemID)
        {
            if (consumableCounts.ContainsKey(itemID) && consumableCounts[itemID] > 0)
            {
                consumableCounts[itemID]--;
            }
        }

        public bool HasAnyConsumables()
        {
            return consumableCounts.Any(pair => pair.Value > 0);
        }

        public bool HasItem(string itemID)
        {
            return consumableCounts.ContainsKey(itemID) && consumableCounts[itemID] > 0;
        }
    }

    public class BattleStateSnapshot
    {
        public List<UnitStateSnapshot> UnitSnapshots { get; }
        public SimulatedInventory InventorySnapshot { get; }

        public BattleStateSnapshot(List<UnitStateSnapshot> unitSnaps, SimulatedInventory inventorySnap)
        {
            UnitSnapshots = unitSnaps;
            InventorySnapshot = inventorySnap;
        }
    }
    #endregion

    #region 快照資料 & 運行
    public class UnitStateSnapshot
    {
        public IBattleUnit_ReadOnly Unit { get; }
        public int Stamina { get; }
        public GridPosition Position { get; }
        public BattleRole Role { get; }
        public UnitStateSnapshot(IBattleUnit_ReadOnly unit) { Unit = unit; Stamina = unit.CurrentStamina; Position = unit.CurrentPosition; Role = unit.Role; }
        public UnitStateSnapshot(UnitStateSnapshot source) { Unit = source.Unit; Stamina = source.Stamina; Position = source.Position; Role = source.Role; }
        public UnitStateSnapshot(UnitStateSnapshot source, int newStamina, GridPosition newPosition, BattleRole newRole) { Unit = source.Unit; Stamina = newStamina; Position = newPosition; Role = newRole; }
    }
    private List<BattleStateSnapshot> planningStepSnapshots = new List<BattleStateSnapshot>();

    public void InitializeSnapshots(List<BattleUnit> allUnits)
    {
        planningStepSnapshots.Clear();
        
        List<UnitStateSnapshot> initialUnitSnapshot = new List<UnitStateSnapshot>();
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                initialUnitSnapshot.Add(new UnitStateSnapshot(unit));
            }
        }
        SimulatedInventory initialInventory = new SimulatedInventory();
        BattleStateSnapshot initialBattleState = new BattleStateSnapshot(initialUnitSnapshot, initialInventory);

        planningStepSnapshots.Add(initialBattleState);
        Debug.Assert(planningStepSnapshots.Count == 1, "初始化後，快照列表長度不為1！");
    }

    public BattleStateSnapshot GetLatestSnapshot()
    {
        if (planningStepSnapshots.Count == 0)
        {
            Debug.LogError("嚴重錯誤：快照列表為空！無法獲取最新快照。");
            return null;
        }
        return planningStepSnapshots.Last();
    }
    
    public void PruneSnapshotsToCount(int targetCount)
    {
        if (targetCount < 1) targetCount = 1;

        if (planningStepSnapshots.Count > targetCount)
        {
            int removeCount = planningStepSnapshots.Count - targetCount;
            planningStepSnapshots.RemoveRange(targetCount, removeCount);
        }
    }

    public void GenerateAndStoreNextSnapshot(ActionPlan plan, BattleActions actionCosts)
    {
        BattleStateSnapshot previousBattleState = GetLatestSnapshot();
        if (previousBattleState == null) return;

        List<UnitStateSnapshot> nextUnitState = previousBattleState.UnitSnapshots.Select(s => new UnitStateSnapshot(s)).ToList();
        
        SimulatedInventory nextInventoryState = new SimulatedInventory(previousBattleState.InventorySnapshot);

        if (plan.Type != ActionType.Skip && plan.Source != null)
        {
            var sourceSnap = nextUnitState.FirstOrDefault(s => s.Unit == plan.Source);
            if (sourceSnap != null)
            {
                int sourceIndex = nextUnitState.IndexOf(sourceSnap);
                int newStamina = sourceSnap.Stamina;
                GridPosition newSourcePos = sourceSnap.Position;
                BattleRole newSourceRole = sourceSnap.Role;

                switch (plan.Type)
                {
                    case ActionType.Attack:
                        newStamina -= actionCosts.GetAttackStaminaCost();
                        break;

                    case ActionType.Rest:
                        newStamina += actionCosts.GetRestStaminaRecovery();
                        newStamina = Mathf.Min(newStamina, plan.Source.MaxStamina);
                        break;

                    case ActionType.Item:
                        if (plan.ItemUsed != null)
                        {
                            nextInventoryState.ConsumeItem(plan.ItemUsed.uniqueItemID);
                        }
                        break;
                    
                    case ActionType.Exchange:
                        newStamina -= actionCosts.GetExchangeStaminaCost();
                        var targetSnap = nextUnitState.FirstOrDefault(s => s.Unit == plan.Target);
                        if (targetSnap != null)
                        {
                            int targetIndex = nextUnitState.IndexOf(targetSnap);
                            newSourcePos = targetSnap.Position;
                            newSourcePos = targetSnap.Position;
                            GridPosition newTargetPos = sourceSnap.Position;
                            newSourceRole = targetSnap.Role;
                            BattleRole newTargetRole = sourceSnap.Role;
                            nextUnitState[targetIndex] = new UnitStateSnapshot(targetSnap, targetSnap.Stamina, newTargetPos, newTargetRole);
                        }
                        break;
                    case ActionType.Skill:
                        if (plan.SkillUsed != null)
                        {
                            newStamina -= plan.SkillUsed.staminaCost;
                        }
                        break;
                }
                nextUnitState[sourceIndex] = new UnitStateSnapshot(sourceSnap, newStamina, newSourcePos, newSourceRole);
            }
        }
        BattleStateSnapshot nextBattleState = new BattleStateSnapshot(nextUnitState, nextInventoryState);
        planningStepSnapshots.Add(nextBattleState);
    }
    
    public void RestoreAllUnitStamina(List<BattleUnit> allUnits)
    {
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                unit.SetStamina(unit.MaxStamina);
            }
        }
    }
    #endregion
}
```

5. `BattlefieldStateSimulator.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattlefieldStateSimulator : MonoBehaviour
{
    private List<BattleUnit> allUnits;
    private CharacterStateRule characterStateRule;

    public void Initialize(List<BattleUnit> units, CharacterStateRule rule)
    {
        allUnits = units;
        characterStateRule = rule;
    }

    public void ShowStateFromSnapshot(List<CharacterStateRule.UnitStateSnapshot> snapshot)
    {
        if (snapshot == null)
        {
            Debug.LogError("傳入的快照為空，無法更新視覺！");
            return;
        }

        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                unit.ResetVisualsToCoreState();
            }
        }

        foreach (var unitSnapshot in snapshot)
        {
            BattleUnit unitToUpdate = allUnits.FirstOrDefault(u => u == unitSnapshot.Unit.GetMonoBehaviour());
            
            if (unitToUpdate != null && !unitToUpdate.IsDead)
            {
                GridPosition previewPos = unitSnapshot.Position;
                int previewStamina = unitSnapshot.Stamina;
                BattleRole previewRole = unitSnapshot.Role;

                unitToUpdate.UpdatePreviewVisuals(previewPos, previewStamina, previewRole);
            }
        }
    }

    public void ShowTemporaryStaminaPreview(IBattleUnit_ReadOnly unitToModify, int staminaCost)
    {
        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        if (latestSnapshot == null) return;

        ShowStateFromSnapshot(latestSnapshot.UnitSnapshots);

        BattleUnit unitMono = unitToModify.GetMonoBehaviour();
        if (unitMono == null) return;

        var unitSnap = latestSnapshot.UnitSnapshots.FirstOrDefault(s => s.Unit == unitToModify);

        if (unitSnap != null)
        {
            int finalPreviewStamina = unitSnap.Stamina - staminaCost;
            unitMono.UpdatePreviewVisuals(unitSnap.Position, finalPreviewStamina, unitSnap.Role);
        }
    }
    
    public void ClearTemporaryPreviews()
    {
        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        if (latestSnapshot != null)
        {
            ShowStateFromSnapshot(latestSnapshot.UnitSnapshots);
        }
    }
}
```