#### **教學系統模組 (Tutorial System Module)**

1. `TutorialSO.cs`(ScriptableObject)：
    (1) 數據容器：包含唯一的 tutorialID 和一個 TutorialStep 列表。

2. `TutorialStep.cs`(資料)：
    (1) 定義單一步驟的所有細節。
    (2) 顯示內容、佈局的流程控制模式。

3. `TutorialDatabase.cs`：
    (1) 從 Resources 文件夾加載所有 TutorialSO 並存儲在字典中，供 TutorialManager 查詢。

4. `TutorialUI.cs`：
    (1) 教學流程的主要控制器，負責處理翻頁和關閉邏輯。
    (2) 數據渲染：根據傳入的 tutorialID 透過 `TutorialStep` 數據來更新文本和圖片。
    (3) 進程控制：按鈕
        * 上一頁：第一頁時「上一頁」變灰。
        * 下一頁：點擊可翻動至下一頁。
        * 完成：最後一頁時「下一頁」文字變為「完成」。
    (4) 自我註冊：在 Awake 時向 TutorialManager 註冊自己，建立通信。

5. `TutorialManager.cs`：
    (1) 完成狀態追蹤：系統需要記錄哪些教學已經顯示過，避免重複觸發。這個狀態需要被存檔。
    (2) 觸發邏輯：當被調用時，它首先會檢查該 tutorialID 是否已存在於 completedTutorials 中。

6. `TutorialTrigger.cs`：
    (1) 可以是一個放置在場景中的 Collider（玩家進入時觸發），也可以是一個可以被其他系統（如對話系統的 DialogueAction）調用的方法。

7. `TutorialLayoutView.cs`(Prefab)：
    (1) 接收 TutorialStep 數據並將其填充到對應的UI元件中。

#### **系統教學模組 (System Tutorial Module)**

8. `TutorialLogUI.cs`：
    (1) 一個「教學」按鈕，可開啟回顧 UI 面板。
    (2) UI 面板，查看已發生的教學。
    (3) 連接 GameSystemUI.cs，功能連結。

9. `TutorialReviewPanel.cs`：
    (1) 類似於 TutorialUI.cs，用於 GameSystemUI 上。

---

### 完整代碼

#### 1. `TutorialSO.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "New Tutorial", menuName = "Tutorial/Tutorial Data")]
public class TutorialSO : ScriptableObject
{
    [Header("教學識別")]
    [Tooltip("此教學的唯一ID，用於觸發和完成狀態追蹤。")]
    public string tutorialID;

    [Tooltip("此教學在『教學回顧』列表中顯示的標題。")]
    public string tutorialTitle;

    [Header("教學步驟序列")]
    [Tooltip("整個教學將按照這個列表的順序進行。")]
    public List<TutorialStep> steps = new List<TutorialStep>();
}
```

#### 2. `TutorialStep.cs`
```csharp
using UnityEngine;

[System.Serializable]
public class TutorialStep
{
    [Header("內容 (Content)")]
    public string title;
    [TextArea(4, 8)]
    public string description;
    public Sprite image;

    [Header("佈局 (Layout)")]
    [Tooltip("用於顯示此步驟內容的 UI 佈局 Prefab。")]
    public GameObject layoutPrefab;
}
```

#### 3. `TutorialDatabase.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public static class TutorialDatabase
{
    private static Dictionary<string, TutorialSO> tutorials;
    private static bool isLoaded = false;

    private static void LoadDatabase()
    {
        if (isLoaded) return;

        tutorials = new Dictionary<string, TutorialSO>();
        TutorialSO[] loadedTutorials = Resources.LoadAll<TutorialSO>("GameData/Tutorials");

        foreach (var tutorial in loadedTutorials)
        {
            if (!tutorials.ContainsKey(tutorial.tutorialID))
            {
                tutorials.Add(tutorial.tutorialID, tutorial);
            }
            else
            {
                Debug.LogWarning($"[TutorialDatabase] 發現重複的教學 ID: {tutorial.tutorialID}");
            }
        }
        Debug.Log($"[TutorialDatabase] 成功載入 {tutorials.Count} 個教學。");
        isLoaded = true;
    }

    public static TutorialSO GetTutorialByID(string id)
    {
        if (!isLoaded)
        {
            LoadDatabase();
        }

        if (tutorials.TryGetValue(id, out TutorialSO tutorial))
        {
            return tutorial;
        }
        Debug.LogWarning($"[TutorialDatabase] 找不到 ID 為 '{id}' 的教學。");
        return null;
    }
}
```

#### 4. `TutorialUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class TutorialUI : MonoBehaviour
{
    [Header("主面板與容器")]
    [SerializeField] private GameObject tutorialPanel;
    [SerializeField] private Transform layoutContainer;

    [Header("導航按鈕")]
    [SerializeField] private Button previousButton;
    [SerializeField] private Button nextButton;
    [SerializeField] private Button skipButton;
    [SerializeField] private TextMeshProUGUI nextButtonText;

    private GameObject currentLayoutInstance;
    private TutorialLayoutView currentLayoutView;

    private TutorialSO currentTutorial;
    private int currentStepIndex;
    private bool isReviewMode;

    void Awake()
    {
        if (TutorialManager.Instance != null)
        {
            TutorialManager.Instance.RegisterUI(this);
        }
        
        previousButton.onClick.AddListener(OnPreviousClicked);
        nextButton.onClick.AddListener(OnNextClicked);
        skipButton.onClick.AddListener(OnSkipClicked);
        Hide();
    }

    public void Show(TutorialSO tutorial, bool reviewMode)
    {
        currentTutorial = tutorial;
        isReviewMode = reviewMode;
        currentStepIndex = 0;
        
        tutorialPanel.SetActive(true);
        DisplayStep(currentStepIndex);
    }

    public void Hide()
    {
        if (tutorialPanel != null) tutorialPanel.SetActive(false);
        if (currentLayoutInstance != null) Destroy(currentLayoutInstance);
    }

    private void DisplayStep(int index)
    {
        if (currentTutorial == null || index < 0 || index >= currentTutorial.steps.Count) return;

        currentStepIndex = index;
        TutorialStep step = currentTutorial.steps[currentStepIndex];

        if (currentLayoutInstance != null) Destroy(currentLayoutInstance);
        if (step.layoutPrefab != null)
        {
            currentLayoutInstance = Instantiate(step.layoutPrefab, layoutContainer);
            currentLayoutView = currentLayoutInstance.GetComponent<TutorialLayoutView>();
            if (currentLayoutView != null)
            {
                currentLayoutView.Populate(step);
            }
        }
        UpdateNavigationButtons();
    }

    private void UpdateNavigationButtons()
    {
        previousButton.interactable = currentStepIndex > 0;

        if (currentStepIndex == currentTutorial.steps.Count - 1)
        {
            nextButtonText.text = isReviewMode ? "關閉" : "完成";
        }
        else
        {
            nextButtonText.text = "下一頁";
        }

        skipButton.gameObject.SetActive(!isReviewMode);
    }

    private void OnNextClicked()
    {
        if (currentStepIndex >= currentTutorial.steps.Count - 1)
        {
            FinishTutorial();
        }
        else
        {
            DisplayStep(currentStepIndex + 1);
        }
    }

    private void OnPreviousClicked()
    {
        if (currentStepIndex > 0)
        {
            DisplayStep(currentStepIndex - 1);
        }
    }

    private void OnSkipClicked()
    {
        FinishTutorial();
    }
    
    private void FinishTutorial()
    {
        TutorialManager.Instance.EndTutorial();
    }
}
```

#### 5. `TutorialManager.cs`
```csharp
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TutorialManager : MonoBehaviour, IGameSaveable
{
    public static TutorialManager Instance { get; private set; }
    private HashSet<string> completedTutorials = new HashSet<string>();
    private TutorialUI tutorialUI;
    private TutorialSO currentTutorial;
    private bool isReviewMode;

    void Awake()
    {
        if (Instance != null && Instance != this) { Destroy(gameObject); return; }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        SaveManager.Instance.Register(this);
    }
    
    void OnDestroy()
    {
        if (SaveManager.Instance != null)
        {
            SaveManager.Instance.Unregister(this);
        }
    }

    private void OnEnable()
    {
        if (InputManager.Instance != null)
        {
            InputManager.Instance.OnEscape += HandleEscape;
        }
    }

    private void OnDisable()
    {
        if (InputManager.Instance != null)
        {
            InputManager.Instance.OnEscape -= HandleEscape;
        }
    }

    public void RegisterUI(TutorialUI ui) => tutorialUI = ui;

    public void ShowTutorial(string tutorialID, bool isReview = false)
    {
        if (completedTutorials.Contains(tutorialID) && !isReview)
        {
            Debug.Log($"教學 '{tutorialID}' 已完成，不再顯示。");
            return;
        }
        if (tutorialUI == null)
        {
            Debug.LogError("[TutorialManager] TutorialUI 未註冊，無法顯示教學！");
            return;
        }
        TutorialSO tutorial = TutorialDatabase.GetTutorialByID(tutorialID);
        if (tutorial == null || tutorial.steps.Count == 0) return;
        
        this.currentTutorial = tutorial;
        this.isReviewMode = isReview;
        
        if (!isReview)
        {
            if (GameManager.Instance != null)
            {
                GameManager.Instance.SetGameState(GameState.InTutorial);
            }
        }
        tutorialUI.Show(tutorial, isReview); 
    }

    public void EndTutorial()
    {
        if (tutorialUI != null) tutorialUI.Hide();
        if (!isReviewMode && currentTutorial != null)
        {
            MarkAsCompleted(currentTutorial.tutorialID);
            
            if (GameManager.Instance != null && GameManager.Instance.CurrentGameState == GameState.InTutorial)
            {
                StartCoroutine(RestoreExplorationStateNextFrame());
            }
        }
        currentTutorial = null;
    }
    
    private IEnumerator RestoreExplorationStateNextFrame()
    {
        yield return null;
        if (GameManager.Instance != null)
        {
            GameManager.Instance.SetGameState(GameState.Exploration);
        }
    }
    
    public void EndTutorial(TutorialSO tutorial, bool isReviewMode)
    {
        this.currentTutorial = tutorial;
        this.isReviewMode = isReviewMode;
        EndTutorial();
    }

    private void MarkAsCompleted(string tutorialID)
    {
        if (completedTutorials.Add(tutorialID))
        {
            Debug.Log($"[TutorialManager] 已將教學 '{tutorialID}' 標記為完成。");
        }
    }

    private void HandleEscape()
    {
        if (GameManager.Instance != null && GameManager.Instance.CurrentGameState == GameState.InTutorial)
        {
            Debug.Log("[TutorialManager] 透過 ESC 鍵關閉教學。");
            EndTutorial();
        }
    }

    public HashSet<string> GetCompletedTutorials() => completedTutorials;
    
    #region 存檔資料
    public void PopulateSaveData(GameSaveData data)
    {
        data.tutorialData.completedTutorials = this.completedTutorials.ToList();
    }

    public void LoadFromSaveData(GameSaveData data)
    {
        if (data.tutorialData != null && data.tutorialData.completedTutorials != null)
        {
            this.completedTutorials = new HashSet<string>(data.tutorialData.completedTutorials);
        }
        else
        {
            this.completedTutorials = new HashSet<string>();
        }
    }
    #endregion
}
```

#### 6. `TutorialTrigger.cs`
```csharp
using UnityEngine;

public class TutorialTrigger : MonoBehaviour
{
    [Header("觸發設定")]
    [Tooltip("要觸發的教學的唯一ID。")]
    [SerializeField] private string tutorialID;
    [Tooltip("勾選此項，當玩家進入觸發器範圍時自動觸發。")]
    [SerializeField] private bool triggerOnEnter = true;
    [Tooltip("勾選此項，觸發器觸發一次後即失效。")]
    [SerializeField] private bool triggerOnce = true;

    private bool hasTriggered = false;

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (triggerOnEnter && other.CompareTag("Player"))
        {
            Trigger();
        }
    }

    public void Trigger()
    {
        if (triggerOnce && hasTriggered) return;
        
        TutorialManager.Instance.ShowTutorial(tutorialID);
        hasTriggered = true;
        
        if (triggerOnce)
        {
            gameObject.SetActive(false);
        }
    }
}
```

#### 7. `TutorialLayoutViewl.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class TutorialLayoutView : MonoBehaviour
{
    [Header("佈局插槽 (可選)")]
    [SerializeField] private TextMeshProUGUI titleText;
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image tutorialImage;

    public void Populate(TutorialStep step)
    {
        if (titleText != null)
        {
            titleText.gameObject.SetActive(!string.IsNullOrEmpty(step.title));
            titleText.text = step.title;
        }
        if (descriptionText != null)
        {
            descriptionText.gameObject.SetActive(!string.IsNullOrEmpty(step.description));
            descriptionText.text = step.description;
        }
        if (tutorialImage != null)
        {
            tutorialImage.gameObject.SetActive(step.image != null);
            tutorialImage.sprite = step.image;
        }
    }
}
```

#### 8. `TutorialLogUI.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;

public class TutorialLogUI : MonoBehaviour
{
    [Header("主面板與視圖")]
    [SerializeField] private GameObject buttonListView; 
    [SerializeField] private TutorialReviewPanel reviewPanel; 

    [Header("按鈕列表元件")]
    [SerializeField] private Transform contentContainer;
    [SerializeField] private GameObject logEntryPrefab;
    [SerializeField] private Button closeButton;
    
    void Awake()
    {
        if (closeButton != null) closeButton.onClick.AddListener(() => gameObject.SetActive(false));
        if (reviewPanel != null)
        {
            reviewPanel.OnReviewClosed += OnReviewPanelClosed;
        }
    }

    private void OnEnable()
    {
        ShowButtonList();
        RefreshLogList();
    }
    
    public bool TryCloseInternalPanels()
    {
        if (reviewPanel != null && reviewPanel.gameObject.activeSelf)
        {
            reviewPanel.gameObject.SetActive(false);
            reviewPanel.ClearAndNotify();
            return true;
        }
        return false;
    }

    private void RefreshLogList()
    {
        foreach (Transform child in contentContainer)
        {
            Destroy(child.gameObject);
        }

        HashSet<string> completedIDs = TutorialManager.Instance.GetCompletedTutorials();

        foreach (string tutorialID in completedIDs)
        {
            TutorialSO tutorial = TutorialDatabase.GetTutorialByID(tutorialID);
            if (tutorial == null || string.IsNullOrEmpty(tutorial.tutorialTitle)) continue;

            GameObject entryGO = Instantiate(logEntryPrefab, contentContainer);
            entryGO.GetComponentInChildren<TextMeshProUGUI>().text = tutorial.tutorialTitle;
            
            Button entryButton = entryGO.GetComponent<Button>();
            entryButton.onClick.AddListener(() => {
                ShowReviewFor(tutorial);
            });
        }
    }
    
    private void ShowReviewFor(TutorialSO tutorial)
    {
        if (buttonListView != null) buttonListView.SetActive(false); 
        if (closeButton != null) closeButton.gameObject.SetActive(false);
        if (reviewPanel != null)
        {
            reviewPanel.PopulateWithData(tutorial);
            reviewPanel.gameObject.SetActive(true);
        }
    }
    
    private void ShowButtonList()
    {
        if (buttonListView != null) buttonListView.SetActive(true);
        if (closeButton != null) closeButton.gameObject.SetActive(true);
        if (reviewPanel != null)
        {
            reviewPanel.gameObject.SetActive(false);
        }
    }

    private void OnReviewPanelClosed()
    {
        ShowButtonList();
    }

    private void OnDestroy()
    {
        if (reviewPanel != null) reviewPanel.OnReviewClosed -= OnReviewPanelClosed;
    }
}
```

#### 9. `TutorialReviewPanel.cs`
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;

public class TutorialReviewPanel : MonoBehaviour
{
    [Header("UI 元件")]
    [SerializeField] private GameObject reviewPanel;
    [SerializeField] private Transform layoutContainer;
    [SerializeField] private Button previousButton;
    [SerializeField] private Button nextButton;
    [SerializeField] private TextMeshProUGUI nextButtonText;
    [SerializeField] private Button closeButton;

    private TutorialSO currentTutorial;
    private int currentStepIndex;
    private GameObject currentLayoutInstance;

    public System.Action OnReviewClosed;

    void Awake()
    {
        previousButton.onClick.AddListener(OnPreviousClicked);
        nextButton.onClick.AddListener(OnNextClicked);
        closeButton.onClick.AddListener(OnCloseButtonClicked);
    }
    
    public void PopulateWithData(TutorialSO tutorial)
    {
        if (tutorial == null || tutorial.steps.Count == 0) return;

        currentTutorial = tutorial;
        currentStepIndex = 0;
        
        DisplayStep(currentStepIndex);
    }

    public void ClearAndNotify()
    {
        if (currentLayoutInstance != null)
        {
            Destroy(currentLayoutInstance);
            currentLayoutInstance = null;
        }
        OnReviewClosed?.Invoke();
    }

    private void OnCloseButtonClicked()
    {
        gameObject.SetActive(false);
        ClearAndNotify();
    }
    
    private void DisplayStep(int index)
    {
        if (currentTutorial == null || index < 0 || index >= currentTutorial.steps.Count) return;
        currentStepIndex = index;
        TutorialStep step = currentTutorial.steps[currentStepIndex];
        if (currentLayoutInstance != null)
        {
            Destroy(currentLayoutInstance);
        }
        if (step.layoutPrefab != null)
        {
            currentLayoutInstance = Instantiate(step.layoutPrefab, layoutContainer);
            var layoutView = currentLayoutInstance.GetComponent<TutorialLayoutView>();
            if (layoutView != null) layoutView.Populate(step);
        }
        UpdateNavigationButtons();
    }

    private void UpdateNavigationButtons()
    {
        previousButton.interactable = currentStepIndex > 0;
        nextButtonText.text = (currentStepIndex == currentTutorial.steps.Count - 1) ? "完成" : "下一頁";
    }

    private void OnNextClicked()
    {
        if (currentStepIndex >= currentTutorial.steps.Count - 1)
        {
            OnCloseButtonClicked(); 
        }
        else
        {
            DisplayStep(currentStepIndex + 1);
        }
    }

    private void OnPreviousClicked()
    {
        if (currentStepIndex > 0)
        {
            DisplayStep(currentStepIndex - 1);
        }
    }
}
```