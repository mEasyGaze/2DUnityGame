### **輸入模組 (Input System Module)**

1. InputManager.cs：
(1) 使用 Unity 內建的 Input System 方法。
(2) 讀取 `PlayerControls` 的輸入，並透過事件將輸入分發出去。

2. KeybindingManager.cs：
(1) 處理按鍵的數據（儲存和讀取）。
(2) 監聽輸入事件並觸發UI行為。
(3) 負責處理所有 UI 面板的開關邏輯，並監聽 `InputManager` 的事件。

3. GameSystemUI.cs：
(1) 內含 KeybindingUI 面板，可透過按鈕點擊開啟。
(2) 內含 AudioSettingsUI 面板，可透過按鈕點擊開啟。

4. KeybindingUI.cs：
(1) 顯示 KeybindingEntryUI Prefab。
(2) 按鈕功能：套用、重置、返回。
    *   套用：點擊後儲存。
    *   重置：點擊後回到最初狀態。
    *   返回：返回到前一頁。

5. KeybindingEntryUI.cs(Prefab)：
(1) 讓玩家可以實際看到並修改按鍵。

**邏輯流程圖**

```mermaid
graph TD
    A[打開按鍵綁定UI] --> B{載入 PlayerPrefs 到 '待辦字典'};
    B --> C{根據 '待辦字典' 更新所有按鈕文字};
    
    subgraph "玩家操作"
        D[點擊 'Rebind'] --> E{開始重新綁定};
        E --> F[玩家按下新按鍵];
        F --> G{新按鍵路徑寫入 '待辦字典'};
        G --> H{只更新該按鈕的文字};
        
        I[點擊 'Reset'] --> J{清空 '待辦字典'};
        J --> K{遍歷所有按鈕, 用預設綁定更新文字};
    end
    
    C --> D;
    C --> I;
    H --> C;
    K --> C;
    
    subgraph "最終決定"
        L[點擊 'Apply'] --> M{將 '待辦字典' 轉為 JSON};
        M --> N{應用 JSON 到 Input System};
        N --> O{儲存 JSON 到 PlayerPrefs};
        O --> P[關閉面板];
        
        Q[點擊 'Back' 或 'Escape'] --> R{不做任何事};
        R --> P;
    end
    
    C --> L;
    C --> Q;
```
---

#### **1. `InputManager.cs`**

```csharp
using UnityEngine;
using UnityEngine.InputSystem;
using System;

public class InputManager : MonoBehaviour
{
    public static InputManager Instance { get; private set; }
    
    private PlayerControls playerControls;

    public bool IsInitialized { get; private set; } = false;

    public event Action<Vector2> OnMove;
    public event Action OnInteract;
    public event Action OnPickup;
    public event Action OnToggleInventory;
    public event Action OnToggleQuestLog;
    public event Action OnTogglePartyHolder;
    public event Action OnToggleBattleParty;
    public event Action OnToggleMap;
    public event Action OnEscape;

    void Awake()
    {
        if (Instance != null)
        {
            Debug.LogWarning("發現重複的 InputManager 實例，已將新的銷毀。");
            Destroy(this.gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(this.gameObject);
        Initialize();
    }

    private void Initialize()
    {
        if (IsInitialized) return;
        playerControls = new PlayerControls();
        RegisterActions();
        IsInitialized = true;
        Debug.Log("InputManager Initialized and is now persistent.");
    }

    private void OnEnable()
    {
        playerControls?.UI.Enable();
        playerControls?.Gameplay.Enable();
    }

    private void OnDisable()
    {
        playerControls?.UI.Disable();
        playerControls?.Gameplay.Disable();
    }

    void OnDestroy()
    {
        if (Instance == this)
        {
            if (playerControls != null)
            {
                UnregisterGameplayActions();
                playerControls.Dispose();
                playerControls = null;
            }
        }
    }

    private void RegisterActions()
    {
        playerControls.Gameplay.Move.performed += HandleMove;
        playerControls.Gameplay.Move.canceled += HandleMove;
        playerControls.Gameplay.Interact.performed += HandleInteract;
        playerControls.Gameplay.Pickup.performed += HandlePickup;
        playerControls.Gameplay.ToggleInventory.performed += HandleToggleInventory;
        playerControls.Gameplay.ToggleQuestLog.performed += HandleToggleQuestLog;
        playerControls.Gameplay.TogglePartyHolder.performed += HandleTogglePartyHolder;
        playerControls.Gameplay.ToggleBattleParty.performed += HandleToggleBattleParty;
        playerControls.Gameplay.ToggleMap.performed += HandleToggleMap;
        playerControls.UI.Escape.performed += HandleEscape;
    }

    private void UnregisterGameplayActions()
    {
        if (playerControls == null) return;
        playerControls.Gameplay.Move.performed -= HandleMove;
        playerControls.Gameplay.Move.canceled -= HandleMove;
        playerControls.Gameplay.Interact.performed -= HandleInteract;
        playerControls.Gameplay.Pickup.performed -= HandlePickup;
        playerControls.Gameplay.ToggleInventory.performed -= HandleToggleInventory;
        playerControls.Gameplay.ToggleQuestLog.performed -= HandleToggleQuestLog;
        playerControls.Gameplay.TogglePartyHolder.performed -= HandleTogglePartyHolder;
        playerControls.Gameplay.ToggleBattleParty.performed -= HandleToggleBattleParty;
        playerControls.Gameplay.ToggleMap.performed -= HandleToggleMap;
        playerControls.UI.Escape.performed -= HandleEscape;
    }

    #region 輸入操作處理
    private void HandleMove(InputAction.CallbackContext context) => OnMove?.Invoke(context.ReadValue<Vector2>());
    private void HandleInteract(InputAction.CallbackContext context) => OnInteract?.Invoke();
    private void HandlePickup(InputAction.CallbackContext context) => OnPickup?.Invoke();
    private void HandleToggleInventory(InputAction.CallbackContext context) => OnToggleInventory?.Invoke();
    private void HandleToggleQuestLog(InputAction.CallbackContext context) => OnToggleQuestLog?.Invoke();
    private void HandleTogglePartyHolder(InputAction.CallbackContext context) => OnTogglePartyHolder?.Invoke();
    private void HandleToggleBattleParty(InputAction.CallbackContext context) => OnToggleBattleParty?.Invoke();
    private void HandleToggleMap(InputAction.CallbackContext context) => OnToggleMap?.Invoke();
    private void HandleEscape(InputAction.CallbackContext context) => OnEscape?.Invoke();
    #endregion

    public PlayerControls GetPlayerControls()
    {
        return playerControls;
    }

    public void EnableGameplayInput(bool enable)
    {
        if (playerControls == null) return;
        if (enable)
        {
            playerControls.Gameplay.Enable();
            Debug.Log("[InputManager] 遊戲玩法輸入已啟用。");
        }
        else
        {
            playerControls.Gameplay.Disable();
            Debug.Log("[InputManager] 遊戲玩法輸入已禁用。");
        }
    }
}
```

#### **2. `KeybindingManager.cs`**

```csharp
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.SceneManagement;

public class KeybindingManager : MonoBehaviour
{
    private InventoryUI inventoryUI; 
    private QuestUI questUI;
    private PartyHolderUI partyHolderUI;
    private PartyBattleUI partyBattleUI;
    private GameSystemUI gameSystemUI;

    public static KeybindingManager Instance { get; private set; }
    private bool areEventsSubscribed = false;

    void Awake()
    {
        if (Instance != null)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
        SubscribeToInputEvents();
    }
    
    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
        if (InputManager.Instance != null)
        {
            UnsubscribeFromInputEvents();
        }
    }
    
    void Start()
    {
        FindUIReferences();
    }
    
    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        FindUIReferences();
    }
    
    private void SubscribeToInputEvents()
    {
        if (InputManager.Instance == null || areEventsSubscribed) return;

        InputManager.Instance.OnToggleInventory += HandleToggleInventory;
        InputManager.Instance.OnToggleQuestLog += HandleToggleQuestLog;
        InputManager.Instance.OnTogglePartyHolder += HandleTogglePartyHolder;
        InputManager.Instance.OnToggleBattleParty += HandleToggleBattleParty;
        InputManager.Instance.OnEscape += HandleEscapeKey;
        
        areEventsSubscribed = true;
        Debug.Log("KeybindingManager: Events subscribed.");
    }
    
    private void UnsubscribeFromInputEvents()
    {
        if (InputManager.Instance == null || !areEventsSubscribed) return;

        InputManager.Instance.OnToggleInventory -= HandleToggleInventory;
        InputManager.Instance.OnToggleQuestLog -= HandleToggleQuestLog;
        InputManager.Instance.OnTogglePartyHolder -= HandleTogglePartyHolder;
        InputManager.Instance.OnToggleBattleParty -= HandleToggleBattleParty;
        InputManager.Instance.OnEscape -= HandleEscapeKey;
        
        areEventsSubscribed = false;
        Debug.Log("KeybindingManager: Events unsubscribed.");
    }

    private void FindUIReferences()
    {
        inventoryUI = FindObjectOfType<InventoryUI>(true);
        questUI = FindObjectOfType<QuestUI>(true);
        partyHolderUI = FindObjectOfType<PartyHolderUI>(true);
        partyBattleUI = FindObjectOfType<PartyBattleUI>(true);
        gameSystemUI = FindObjectOfType<GameSystemUI>(true);
    }
    
    #region 按鍵處理邏輯
    private void HandleToggleInventory() => inventoryUI?.TogglePanel();
    private void HandleToggleQuestLog() => questUI?.TogglePanel();
    private void HandleTogglePartyHolder() => partyHolderUI?.TogglePanel();
    private void HandleToggleBattleParty() => partyBattleUI?.TogglePanel();
    
    private void HandleEscapeKey()
    {
        if (GameManager.Instance != null)
        {
            GameState state = GameManager.Instance.CurrentGameState;
            if (state != GameState.Exploration && state != GameState.Paused)
            {
                return;
            }
        }
        
        if (gameSystemUI != null && gameSystemUI.IsAnyPanelActive())
        {
            gameSystemUI.TryCloseSubPanels();
            return;
        }
        
        if (inventoryUI != null && inventoryUI.IsPanelActive()) 
        {
            inventoryUI.HidePanel();
        }
        else if (questUI != null && questUI.gameObject.activeInHierarchy)
        {
            questUI.TogglePanel();
        }
        else if (partyHolderUI != null && partyHolderUI.gameObject.activeInHierarchy)
        {
            partyHolderUI.TogglePanel();
        }
        else if (partyBattleUI != null && partyBattleUI.gameObject.activeInHierarchy)
        {
            partyBattleUI.TogglePanel();
        }
        else
        {
            if (gameSystemUI != null)
            {
                gameSystemUI.ToggleMainPanel();
            }
        }
        if (InventoryManager.Instance != null && InventoryManager.Instance.IsSelectingTarget)
        {
            return; 
        }
    }
    #endregion
    
    #region 按鍵綁定
    public void SaveKeybindings()
    {
        if (InputManager.Instance == null) return;
        var playerControls = InputManager.Instance.GetPlayerControls();
        if (playerControls == null) return;
        string rebinds = playerControls.SaveBindingOverridesAsJson();
        PlayerPrefs.SetString("KeyRebinds", rebinds);
        PlayerPrefs.Save();
        Debug.Log("按鍵綁定已儲存。");
    }

    public void LoadKeybindings()
    {
        if (InputManager.Instance == null) return;
        var playerControls = InputManager.Instance.GetPlayerControls();
        if (playerControls == null) return;
        if (PlayerPrefs.HasKey("KeyRebinds"))
        {
            string rebinds = PlayerPrefs.GetString("KeyRebinds");
            playerControls.LoadBindingOverridesFromJson(rebinds);
            Debug.Log("按鍵綁定已載入。");
        }
    }
    #endregion
}
```

#### **3. `GameSystemUI.cs`**

```csharp
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

public class GameSystemUI : MonoBehaviour
{
    [Header("主面板")]
    [SerializeField] private GameObject systemMainPanel;

    [Header("子面板")]
    [SerializeField] private KeybindingUI keybindingPanel;
    [SerializeField] private TutorialLogUI tutorialLogPanel;
    [SerializeField] private SaveLoadUI saveLoadPanel;
    [SerializeField] private AudioSettingsUI audioSettingsPanel; 

    [Header("控制按鈕")]
    [SerializeField] private Button openKeybindingButton;
    [SerializeField] private Button openTutorialLogButton;
    [SerializeField] private Button openSaveButton;
    [SerializeField] private Button openLoadButton;
    [SerializeField] private Button openAudioSettingsButton;
    [SerializeField] private Button closeMainPanelButton;
    
    private List<GameObject> allSubPanels;

    void Start()
    {
        UISoundAutoHook.HookEntireScene();
    }

    void Awake()
    {
        allSubPanels = new List<GameObject>();
        if (keybindingPanel != null) allSubPanels.Add(keybindingPanel.gameObject);
        if (openAudioSettingsButton != null) 
        {
            openAudioSettingsButton.onClick.AddListener(ShowAudioSettingsPanel);
        }
        if (audioSettingsPanel != null) 
        {
            allSubPanels.Add(audioSettingsPanel.gameObject);
            audioSettingsPanel.Hide();
        }
        if (tutorialLogPanel != null) allSubPanels.Add(tutorialLogPanel.gameObject);
        if (saveLoadPanel != null)
        {
            allSubPanels.Add(saveLoadPanel.gameObject);
            saveLoadPanel.SetTitleScreenMode(false);
        }
        if (openKeybindingButton != null) openKeybindingButton.onClick.AddListener(ShowKeybindingPanel);
        if (openTutorialLogButton != null) openTutorialLogButton.onClick.AddListener(ShowTutorialLogPanel);
        if (openSaveButton != null) openSaveButton.onClick.AddListener(ShowSavePanel);
        if (openLoadButton != null) openLoadButton.onClick.AddListener(ShowLoadPanel);
        if (closeMainPanelButton != null) closeMainPanelButton.onClick.AddListener(CloseAllPanels);
        
        CloseAllPanels();
    }

    public void ToggleMainPanel()
    {
        bool isActive = systemMainPanel != null && systemMainPanel.activeSelf;
        if (isActive)
        {
            CloseAllPanels();
        }
        else
        {
            ShowMainPanel();
        }
    }

    private void ShowMainPanel()
    {
        if (systemMainPanel != null) systemMainPanel.SetActive(true);
        if (GameManager.Instance != null && GameManager.Instance.CurrentGameState != GameState.Paused)
        {
            GameManager.Instance.SetGameState(GameState.Paused);
        }
    }
    
    private void HideAllSubPanels()
    {
        foreach (var panel in allSubPanels)
        {
            if (panel != null && panel.activeSelf)
            {
                panel.SetActive(false);
            }
        }
    }

    public void ShowKeybindingPanel()
    {
        HideAllSubPanels();
        if (keybindingPanel != null)
        {
            keybindingPanel.gameObject.SetActive(true);
        }
    }

    public void ShowAudioSettingsPanel()
    {
        HideAllSubPanels();
        if (audioSettingsPanel != null)
        {
            audioSettingsPanel.Show();
        }
    }

    public void ShowTutorialLogPanel()
    {
        HideAllSubPanels();
        if (tutorialLogPanel != null)
        {
            tutorialLogPanel.gameObject.SetActive(true);
        }
    }
    
    public void ShowSavePanel()
    {
        HideAllSubPanels();
        if (saveLoadPanel != null)
        {
            saveLoadPanel.ShowPanel(true); 
        }
    }

    public void ShowLoadPanel()
    {
        HideAllSubPanels();
        if (saveLoadPanel != null)
        {
            saveLoadPanel.ShowPanel(false);
        }
    }
    
    public void CloseAllPanels()
    {
        if (systemMainPanel != null) systemMainPanel.SetActive(false);
        HideAllSubPanels();
        
        if (GameManager.Instance != null && GameManager.Instance.CurrentGameState == GameState.Paused)
        {
            GameManager.Instance.SetGameState(GameState.Exploration);
        }
    }

    public void TryCloseSubPanels()
    {
        bool anySubPanelActive = false;
        if (keybindingPanel != null && keybindingPanel.gameObject.activeSelf) anySubPanelActive = true;
        if (tutorialLogPanel != null && tutorialLogPanel.gameObject.activeSelf) anySubPanelActive = true;
        if (saveLoadPanel != null && saveLoadPanel.gameObject.activeSelf) anySubPanelActive = true;
        if (anySubPanelActive)
        {
            HideAllSubPanels();
            if (keybindingPanel != null) keybindingPanel.ClosePanelWithoutSaving();
            if (tutorialLogPanel != null) tutorialLogPanel.TryCloseInternalPanels();
        }
        else
        {
            CloseAllPanels();
        }
    }
    
    public bool IsAnyPanelActive()
    {
        return systemMainPanel != null && systemMainPanel.activeSelf;
    }
}
```

#### **4. `KeybindingUI.cs`**

```csharp
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;
using TMPro;

public class KeybindingUI : MonoBehaviour
{
    [Header("要綁定的動作列表")]
    [Tooltip("將所有想讓玩家自訂的動作 (InputActionReference) 拖到這裡。")]
    [SerializeField] private List<InputActionReference> actionsToBind;

    [Header("UI 預製件與容器")]
    [SerializeField] private GameObject entryPrefab;
    [SerializeField] private Transform container;
    
    [Header("控制按鈕")]
    [SerializeField] private Button applyButton;
    [SerializeField] private Button resetButton;
    [SerializeField] private Button backButton;

    [Header("重新綁定提示")]
    [SerializeField] private GameObject rebindingOverlay;
    [SerializeField] private TextMeshProUGUI rebindingText;
    
    private List<KeybindingEntryUI> spawnedEntries = new List<KeybindingEntryUI>();
    private InputActionRebindingExtensions.RebindingOperation rebindingOperation;
    
    private Dictionary<string, string> bindingOverrides = new Dictionary<string, string>();
    
    private bool isPopulated = false;

    void Start()
    {
        if (applyButton != null) applyButton.onClick.AddListener(ApplyAndSaveChanges);
        if (resetButton != null) resetButton.onClick.AddListener(ResetBindingsToDefault);
        if (backButton != null) backButton.onClick.AddListener(ClosePanelWithoutSaving);
        if (rebindingOverlay != null) rebindingOverlay.SetActive(false);
    }
    
    private void OnEnable()
    {
        if (InputManager.Instance != null && InputManager.Instance.IsInitialized)
        {
            if (!isPopulated)
            {
                PopulateUI();
            }
            
            LoadSavedOverridesToDictionary();
            RefreshAllEntryTexts();
        }
        else
        {
            Debug.LogWarning("KeybindingUI enabled, but InputManager is not ready yet. UI will not populate.");
        }
    }
    
    private void OnDisable()
    {
        rebindingOperation?.Cancel();
        rebindingOperation = null;
    }
    
    private void PopulateUI()
    {
        if (isPopulated || container == null || entryPrefab == null) return;
        foreach (Transform child in container) { Destroy(child.gameObject); }
        spawnedEntries.Clear();

        if (actionsToBind == null || actionsToBind.Count == 0) return;
        foreach (var actionRef in actionsToBind)
        {
            if (actionRef == null || actionRef.action == null) continue;
            if (actionRef.action.bindings.Count > 0 && actionRef.action.bindings[0].isComposite) continue;
            
            int bindingIndex = 0;

            GameObject entryGO = Instantiate(entryPrefab, container);
            KeybindingEntryUI entryUI = entryGO.GetComponent<KeybindingEntryUI>();
            
            if (entryUI != null)
            {
                entryUI.Setup(actionRef, bindingIndex, HandleRebindRequest);
                spawnedEntries.Add(entryUI);
            }
        }
        isPopulated = true;
        Debug.Log("KeybindingUI Populated with " + spawnedEntries.Count + " entries.");
    }
    
    private void HandleRebindRequest(KeybindingEntryUI entryToRebind)
    {
        rebindingOperation?.Cancel();
        
        if (rebindingOverlay != null)
        {
            rebindingOverlay.SetActive(true);
            if (rebindingText != null)
            {
                rebindingText.text = $"正在綁定: {entryToRebind.GetActionName()}...\n請按下任意鍵 (ESC 取消)";
            }
        }
        
        entryToRebind.StartRebinding(
            (op) => {
                rebindingOperation = op;
            },
            (operation) => {
                if (!operation.canceled)
                {
                    string newPath = operation.action.bindings[entryToRebind.BindingIndex].overridePath;
                    bindingOverrides[entryToRebind.GetActionId()] = newPath;
                    entryToRebind.UpdateKeyTextWithOverride(newPath);
                }
                
                if (rebindingOverlay != null) rebindingOverlay.SetActive(false);
                
                rebindingOperation?.Dispose();
                rebindingOperation = null;
            }
        );
    }
    
    private void RefreshAllEntryTexts()
    {
        if (!isPopulated) return;
        
        foreach(var entry in spawnedEntries)
        {
            if (entry == null) continue;
            
            string actionId = entry.GetActionId();
            if (bindingOverrides.TryGetValue(actionId, out string overridePath))
            {
                entry.UpdateKeyTextWithOverride(overridePath);
            }
            else
            {
                entry.UpdateKeyTextToDefault();
            }
        }
    }
    
    public void ApplyAndSaveChanges()
    {
        if (!isPopulated) return;
        
        string overridesJson = DictionaryToJson(bindingOverrides);
        
        if (InputManager.Instance != null && InputManager.Instance.GetPlayerControls() != null)
        {
            var playerControls = InputManager.Instance.GetPlayerControls();
            playerControls.LoadBindingOverridesFromJson(overridesJson, true);
        }
        
        PlayerPrefs.SetString("KeyRebinds", overridesJson);
        PlayerPrefs.Save();
        
        Debug.Log("按鍵綁定已套用並儲存。");
        ClosePanelWithoutSaving();
    }
    
    public void ResetBindingsToDefault()
    {
        if (!isPopulated) return;
        bindingOverrides.Clear();
        RefreshAllEntryTexts();
        Debug.Log("所有按鍵已在 UI 上恢復預設。按下 '套用' 以確認。");
    }

    public void ClosePanelWithoutSaving()
    {
        if (isPopulated)
        {
            LoadSavedBindingsAndApplyToRuntime();
        }
        gameObject.SetActive(false);
    }

    private void LoadSavedBindingsAndApplyToRuntime()
    {
        if (InputManager.Instance == null) return;
        var playerControls = InputManager.Instance.GetPlayerControls();
        if (playerControls == null) return;
        if (PlayerPrefs.HasKey("KeyRebinds"))
        {
            string rebinds = PlayerPrefs.GetString("KeyRebinds");
            playerControls.LoadBindingOverridesFromJson(rebinds);
        }
        else
        {
            playerControls.RemoveAllBindingOverrides();
        }
    }

    private void LoadSavedOverridesToDictionary()
    {
        bindingOverrides.Clear();
        if (PlayerPrefs.HasKey("KeyRebinds"))
        {
            string rebindsJson = PlayerPrefs.GetString("KeyRebinds");
            if (string.IsNullOrEmpty(rebindsJson)) return;

            var rebindsWrapper = JsonUtility.FromJson<RebindsWrapper>(rebindsJson);
            if (rebindsWrapper != null && rebindsWrapper.bindings != null)
            {
                foreach(var binding in rebindsWrapper.bindings)
                {
                    bindingOverrides[binding.id] = binding.path;
                }
            }
        }
    }
    
    private string DictionaryToJson(Dictionary<string, string> dict)
    {
        var bindingsList = dict.Select(kvp => 
            new RebindData { id = kvp.Key, path = kvp.Value }
        ).ToList();
        var wrapper = new RebindsWrapper { bindings = bindingsList };
        return JsonUtility.ToJson(wrapper);
    }
    
    [System.Serializable]
    private class RebindsWrapper { public List<RebindData> bindings; }

    [System.Serializable]
    private class RebindData { public string id; public string path; }
}
```

#### **5. `KeybindingEntryUI.cs(Prefab)`**

```csharp
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.InputSystem;
using TMPro;
using System;

public class KeybindingEntryUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private TextMeshProUGUI actionNameText;
    [SerializeField] private Button rebindButton;
    [SerializeField] private TextMeshProUGUI keyText;

    private InputActionReference actionReference;
    
    public int BindingIndex { get; private set; }

    public void Setup(InputActionReference actionRef, int index, Action<KeybindingEntryUI> onRebindClicked)
    {
        this.actionReference = actionRef;
        this.BindingIndex = index;
        
        if (actionNameText != null)
        {
            actionNameText.text = actionRef.action.name;
        }
        rebindButton.onClick.RemoveAllListeners();
        rebindButton.onClick.AddListener(() => onRebindClicked(this));
        
        UpdateKeyTextToDefault();
    }
    
    public string GetActionName()
    {
        return actionReference != null ? actionReference.action.name : "未知動作";
    }

    public string GetActionId()
    {
        if (actionReference == null || actionReference.action == null) return null;
        return actionReference.action.bindings[BindingIndex].id.ToString();
    }

    public void UpdateKeyTextToDefault()
    {
        if (keyText != null && actionReference != null && actionReference.action != null)
        {
            keyText.text = InputControlPath.ToHumanReadableString(
                actionReference.action.bindings[BindingIndex].path,
                InputControlPath.HumanReadableStringOptions.OmitDevice
            );
        }
    }

    public void UpdateKeyTextWithOverride(string overridePath)
    {
        if (keyText != null)
        {
             keyText.text = InputControlPath.ToHumanReadableString(
                overridePath,
                InputControlPath.HumanReadableStringOptions.OmitDevice
            );
        }
    }

    public void StartRebinding(Action<InputActionRebindingExtensions.RebindingOperation> onStarted, Action<InputActionRebindingExtensions.RebindingOperation> onComplete)
    {
        if (actionReference == null || actionReference.action == null) return;
        keyText.text = "...";
        rebindButton.interactable = false;
        
        var action = actionReference.action;
        action.Disable();

        var rebindOp = action.PerformInteractiveRebinding(BindingIndex)
            .WithControlsExcluding("Mouse")
            .WithCancelingThrough("<Keyboard>/escape")
            .OnMatchWaitForAnother(0.1f)
            .OnComplete(operation => {
                FinishRebinding(operation, onComplete);
            })
            .OnCancel(operation => {
                FinishRebinding(operation, onComplete);
            });
        onStarted?.Invoke(rebindOp);
        rebindOp.Start();
    }
    
    private void FinishRebinding(InputActionRebindingExtensions.RebindingOperation operation, Action<InputActionRebindingExtensions.RebindingOperation> onComplete)
    {
        rebindButton.interactable = true;
        actionReference.action.Enable();
        if (keyText != null)
        {
            keyText.text = InputControlPath.ToHumanReadableString(
                actionReference.action.bindings[BindingIndex].effectivePath,
                InputControlPath.HumanReadableStringOptions.OmitDevice
            );
        }
        onComplete?.Invoke(operation);
    }
}
```