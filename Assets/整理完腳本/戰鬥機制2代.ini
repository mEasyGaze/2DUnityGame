**戰鬥標準流程**
Player 觸碰了 Enemy(BattleTrigger) -> 將 [Player 隊伍、Enemy] 打包轉移至 BattleScene。
BattleUnit Member, Enemy 的圖像生成至正確的位置，並顯示他們的 HealthUI。
BattleLog 顯示 [戰鬥開始]，進入[玩家規劃階段]。
[玩家規劃階段]：
如果[後勤]存在，則隨時可以使用[指揮官技能]，不佔用行動格。
[前衛] `Phase 1` 選擇 -> [進攻] -> [進攻]誰？；{ActionSlotUI 格子1 會顯示 [前衛]攻擊}
[遠程] `Phase 1` -> 選擇誰(遠1 or 遠2) -> [進攻] -> [進攻]誰？；{ActionSlotUI 格子1 會顯示 [遠1 or 遠2]攻擊}
[前衛] `Phase 2` 選擇 -> [進攻] -> [進攻]誰？；{ActionSlotUI 格子2 會顯示 [前衛]攻擊}
......直至 [遠程] `Phase 4`
[玩家規劃階段] -> 點擊 「回合結束」 按鈕，輪到 [敵人回合]。
BattleLog 顯示 輪到 [敵人回合] -> EnemyBattleAI 開始運作，運作完畢 -> 進入 [行動執行階段]
BattleLog 顯示 [行動執行階段]，並且開始顯示 成員 [誰] 做 [什麼] 行動、敵人做 [誰] 做 [什麼] 行動。
[行動執行階段]：
玩家[前衛] 行動格1 執行 -> 敵人[前衛] 行動格1 執行 ->  玩家[遠程] 行動格1 執行 -> 敵人[遠程] 行動格1 執行 -> 玩家[前衛] 行動格2 執行 -> 敵人[前衛] 行動格2 執行 ->  玩家[遠程] 行動格2 執行 -> 敵人[遠程] 行動格2 執行 -> ......。
若是敵人全部陣亡 -> BattleLog 顯示 [戰鬥勝利]，BattleEndUI 運作，勝利Panel。
若是我方全部陣亡 -> BattleLog 顯示 [戰鬥失敗]，BattleEndUI 運作，失敗Panel。
若是雙方皆未全部陣亡 -> BattleLog 顯示 [玩家規劃階段]。
並繼續戰鬥，直至其中一方全部陣亡。

**戰鬥標準邏輯**：
攻擊邏輯：
不論敵我只能攻擊 [前衛]。(技能除外)
[玩家規劃階段]由系統自動播放：[前衛] `Phase 1` -> [遠程] `Phase 1` -> [前衛] `Phase 2` ...... -> [遠程] `Phase 4`
[玩家規劃階段]可以跳過該行動格不做任何行動。(補充：[跳過]按鈕)
行動邏輯：
[前衛]每個回合有 4個 行動格，每個行動格可以進行 1次 行動。
[遠1]每個回合可以進行 2次 行動。
[遠2]每個回合可以進行 2次 行動。
如果[後勤]存在，則隨時可以使用[指揮官技能]，不佔用行動格。
如果[遠程]兩人都存在，當其中一名行動 2次後，系統自動跳過已經行動 2次 的遠程。
如果[遠程]不存在，系統直接跳過，不顯示 [遠程] `Phase 1`。
如果[遠程]只存在一人，行動 2次後，系統自動跳過。

### 戰鬥系統：

**戰鬥系統核心資料結構**
1. BattleEnums.cs(遊戲字典)：
(1) 戰鬥角色職責：[前衛][遠1][遠2][後勤]
(2) 玩家可執行的行動類型：[攻擊][防禦][休息][技能][道具][交換位置][跳過]
(3) UI 指令類型：[指揮官技能][返回][回合結束][清空規劃][取消單一行動]
(4) 回合管理器的狀態：[戰鬥開始][玩家規劃階段][玩家選擇目標階段][敵人回合][行動執行階段][戰鬥勝利][戰鬥失敗]
(5) 戰場位置：[玩家後勤][玩家遠2][玩家遠1][玩家前衛][敵人前衛][敵人遠1][敵人遠2][敵人後勤]

2. EnemyDataSO.cs (ScriptableObject)：
(1) 敵人基礎模板 (由開發者在Unity編輯器中設定)
*   **基礎資訊**: 敵人ID (獨一無二的編號)、敵人名稱、敵人圖像 (`Sprite` 引用)。
*   **基礎屬性**: 基礎血量、基礎攻擊力、體力(攻擊、施放技能消耗)、攻擊距離。
*   **技能槽位**: 從技能腳本中挑選技能ID輸入。
*   **物品掉落**: 會掉落的物品，如金錢、物品。

3. BattleEncounterSO.cs (戰鬥遭遇和配置)
介紹：它可以讓您把一場「戰鬥」打包成一個檔案。
(1) 隊伍配置：引用 `EnemyDataSO` 來定義敵方隊伍的組成、數量與初始位置，並將此配置提供給 `BattleManager`。
(2) 獎勵計算：根據配置的敵人，預先計算戰鬥勝利後的總獎勵，並將結果傳輸給 `BattleEndUI`。

4. ActionPlan.cs(資料容器)：
介紹：用於儲存單一、已規劃行動的數據結構。
(1) 行動數據：儲存一個行動的完整資訊，包含行動發起者、行動類型、行動目標。
(2) 階段索引：包含一個 `phaseIndex` 屬性 (值為 1-4)，標示此行動歸屬於回合中的哪一個行動階段。
(3) 傳遞資料：
    * 設立一個 `關聯行動ID`:public Guid TransactionID { get; set; }
    * 一個獨立的標識符，用於將多個 ActionPlan 標記為同一個「關聯行動」。
    * 對於獨立行動（如攻擊、防禦），這個行動ID為 0 (或 null)。
    * 對於需要多個行動格配合的特殊行動（如「交換位置」），所有的「關聯行動」都會被賦予同一個非 0 的行動ID（例如，1）。
    * 將自身作為數據包傳遞給 `TurnActionPlanner` 進行排程。

---

**Prefab (預製件盒 - 遊戲世界的實體零件)**
1. BattleUnit.cs(戰鬥單位)：
介紹：附加於角色 Prefab 上的核心組件，代表一個可參與戰鬥的獨立單位，處理所有即時戰鬥狀態。它是整個戰鬥單位的數據與邏輯中心。
(1) 核心狀態與數據：
*   位置數據：儲存該單位在戰場上的當前格子位置。此數值在單位初始化和位置交換時會被更新。
*   範圍數據：儲存該單位的攻擊距離。此數值在初始化時從其對應的數據源（如玩家角色數據或 EnemyDataSO）讀取。
*   狀態管理：初始化單位屬性、處理傷害計算、判定單位陣亡、執行位置變更。提供公開的方法供 TurnManager 調用，用於直接修改自身的當前狀態。
    * (int amount): 扣除指定數量的體力。
    * (UnitStateSnapshot snapshot): 根據傳入的快照，將自身的體力等狀態恢復到快照中的數值。
(2) 狀態反饋：提供接口以改變自身視覺外觀，用於顯示「可被選為目標」或「不可選」等狀態。
(3) 點擊事件：處理自身的點擊事件，並將事件通知 `BattleUIManager`。
(4) 數據傳遞：在初始化時，將自身的基礎數據（如最大血量）傳遞給被引用的 `HealthUI` 組件。在受到傷害時，調用 `HealthUI` 的方法來更新血條顯示。

2. ActionButtonUI.cs (行動按鈕)：
介紹：一個標準化的行動UI按鈕模板。
(1) 事件傳遞: 被點擊時，通知 `BattleUIManager` 玩家選擇了何種行動。
(2) 內容顯示: 包含可配置的圖像與文字，用於顯示具體行動的資訊。

3. ActionSlotUI.cs(單一行動格內容)：
介紹：在戰術規劃板上，負責視覺化顯示一個已規劃行動的UI元件。
(1) 視覺化呈現：接收一個 `ActionPlan` 物件，並根據其數據更新自身的圖示與文字。
(2) 取消按鈕：當此取消按鈕被點擊時，它會將自身的階段索引（1-4）以及陣營信息（玩家方）回報給 BattleUIManager。

4. HealthUI.cs(血條)：
介紹：掛載於 `BattleUnit` 上的UI組件，用於顯示其生命值。
(1) 狀態追蹤：持續追蹤目標 `BattleUnit` 的當前血量。
(2) 更新顯示：在目標血量發生變化時，即時更新UI上的血條顯示。

5. BattleTrigger.cs (戰鬥觸發器)：
介紹：在非戰鬥場景中用於啟動戰鬥的觸發器。
(1) 數據引用：持有一個 `BattleEncounterSO` 的引用。
(2) 觸發戰鬥：當玩家角色與其發生交互時，通知 `GameManager` 啟動戰鬥，並將持有的 BattleEncounterSO 數據傳遞出去。

---

**UI (使用者介面盒 - 玩家的操作面板)**
(所有UI面板的職責均為：**接收來自 `BattleUIManager` 的指令來顯示或隱藏，並將玩家的輸入回報給 `BattleUIManager`**。)
1. ActionPanelUI.cs(行動按鈕面板)：
介紹：容納並管理當前所選角色所有可用行動按鈕的面板。
(1) 動態顯示：根據當前選擇的角色職責（[前衛]、[遠1]、[遠2]、[後勤]），顯示對應的專屬行動按鈕。
* [前衛]：攻擊、防禦、休息、技能、道具、位置交換、跳過。
* [遠1]：攻擊、技能、休息、道具、位置交換、跳過。
* [遠2]：攻擊、技能、休息、道具、位置交換、跳過。
* [後勤]：指揮官技能。(這個按鈕的操作獨立於行動格規劃。)
(2) 狀態同步：根據 `BattleRules` 的判斷結果，將不滿足使用條件(如行動次數耗盡、體力不足、距離不對、指揮官技能已使用)的按鈕設置為不可點擊的灰色狀態。

2. ActionSlotPanelUI.cs(戰術規劃板)：
介紹：視覺化呈現本回合所有行動規劃的面板，並在特定階段提供輸入功能。
(1) 行動格概念：一個回合由 4 個對稱的「行動階段」(Phase) 組成。玩家與敵人雙方都擁有這 4 個行動格的規劃權。此面板專門用於顯示玩家方的規劃。
(2) 結構生成：在畫面中生成代表4個行動階段的槽位。每個槽位應能**動態地**容納和顯示來自 [前衛] 或 [遠程] 的行動 (`ActionSlotUI`)。如果某個職位（如所有[遠程]單位）在隊伍中不存在，則對應的行動格區域不應顯示或應保持為空。
(3) 規劃更新：根據 `TurnActionPlanner` 中儲存的玩家方 `ActionPlan` 列表，更新所有 `ActionSlotUI` 的顯示內容。如果某個行動不存在，對應的UI應為空白（包含行動圖示和取消按鈕的可見性）。
(4) 規劃進度高亮：當 `TurnManager` 指示開始規劃某個行動格時，此面板上對應的 `ActionSlotUI` 應變為高亮狀態，以引導玩家的注意力。

3. BattleEndUI.cs(戰鬥結算畫面)：
介紹：顯示戰鬥結束後結果的UI介面。
(1) 顯示勝利：獲勝後顯示結算UI和退出按鈕。
(2) 顯示失敗：我方全滅時，顯示失敗面板和退出按鈕。

4. BattleLog.cs(戰鬥日誌)：
介紹：時間順序記錄並顯示戰鬥過程中所有關鍵事件的文本日誌。
(1) 事件記錄：接收戰鬥中各個階段轉換、行動執行、傷害造成等事件，並將其格式化為文字記錄。
(2) 日誌顯示：提供一個可滾動的文本區域，讓玩家可以回顧戰鬥過程。

5. BattleUI.cs(戰鬥場景UI總集)：
介紹：集合了戰鬥場景中所有全局性UI按鈕的管理器。
(1) 取消按鈕：在[玩家選擇目標階段]提供取消操作的功能。
(2) 回合結束按鈕：提供一個讓玩家可以隨時結束[玩家規劃階段]並進入下一流程的按鈕。
(3) 清空規劃按鈕：提供一個「重置規劃」的按鈕。點擊後，會通知 BattleUIManager 觸發「清空所有玩家規劃」的事件。
(4) 返回按鈕：回到上一個行動。(如：[前衛]選擇行動「攻擊」-> 選擇目標時「返回」-> 選擇行動「防禦」；選擇遠程 [遠1] -> [遠1]選擇行動時「返回」 -> 選擇遠程 [遠2])
(5) 指揮官技能按鈕：[指揮官技能]可以由[後勤]發動，一場戰鬥只能使用一次。(未實作)
(6) 系統按鈕：戰鬥系統專用UI，可以開啟系統功能。(未實作)
(7) 人物按鈕：顯示人物訊息UI。(未實作)

---

**Manager (管理器)**
1. TurnManager.cs(回合、邏輯管理器)：
介紹：戰鬥流程的核心控制器，使用狀態機來驅動整個戰鬥的節奏與階段轉換。
(1) 管理戰鬥的宏觀流程：依序切換並管理 `[玩家規劃階段]`, `[敵人回合]`, `[行動執行階段]` 等戰鬥狀態。
(2) 階段驅動與協調：
*   進入 [玩家規劃階段] 的引導式流程：
    1. 回合初始化：
    * 命令 BattleLog 顯示「玩家規劃階段」開始。
    * 命令 CharacterStateRule 執行所有單位體力回滿的邏輯。
    * 命令 BattleUIManager 顯示戰術規劃相關的UI（如 ActionPanelUI, ActionSlotPanelUI），並重置UI狀態。
    2. 啟動引導式規劃：TurnManager 內部維護一個「規劃進度」（[前衛]Phase 1 -> [遠程]Phase 1 -> ......[遠程]Phase 4）。
    * 判定規劃單位：根據當前的「規劃進度」（例如輪到[遠程]Phase 2），TurnManager 向 BattleRules 查詢：「此步驟應由哪個單位規劃？」
    * 處理自動跳過：如果 BattleRules 回應沒有符合資格的單位（例如所有[遠程]單位已行動2次），TurnManager 將自動跳過此步驟，並立即推進到下一個「規劃進度」。
    * 引導玩家操作：如果有合法的規劃單位，TurnManager 會命令 BattleUIManager 顯示當前規劃行動格和對應行動單位，並顯示該單位的專屬行動按鈕。
    * TurnManager 等待玩家做出選擇（選擇行動、跳過、或取消其他行動格），並根據收到的指令執行相應的邏輯（如進入目標選擇、記錄行動方案、推進規劃進度等）。
*   進入 [敵人回合]： 
    * 命令 BattleLog 顯示「敵人回合」開始。
    * 調用 EnemyBattleAI 的接口，命令其為所有敵方單位規劃本回合的行動。
    * 等待 EnemyBattleAI 完成規劃後，自動轉換至下一階段。
*   進入 [行動執行階段]：
    *   **介紹**：此階段的核心是按照一個固定的、交錯的順序，來執行雙方已經規劃好的行動。
    *   命令 BattleLog 顯示「行動執行階段」開始。
    *   執行迴圈：TurnManager 將嚴格遵循「玩家前衛 -> 敵人前衛 -> 玩家遠程 -> 敵人遠程」的順序，從階段1到階段4依序執行所有已規劃的行動。
    *   在**每一個單一行動**執行完畢後，都會立即向 `BattleRules` 查詢戰鬥是否已滿足勝利或失敗條件。若滿足，則立刻中斷執行迴圈，進入戰鬥結算。
    *   如果某個順位的行動不存在（例如該方沒有遠程單位，或沒有在該階段規劃行動），則直接跳過，執行下一個順位的行動。
    *   當 4 個行動階段全部執行完畢後，轉換至下一個[玩家規劃階段]。
(3) 引導式規劃下的玩家輸入處理：
*   通用流程(顯示 行動者A 專屬行動按鈕前)：
    1.  `BattleUIManager` 會為每一個按鈕（如「攻擊」、「交換位置」）向 `TurnManager` 發起一次「可行性查詢」。
    2.  `TurnManager` 接收到查詢後，會吩咐 `BattleRules` 判斷全部按鈕的可行性。
    3.  `BattleRules` 返饋 true 或 false。`TurnManager` 將結果告知 `BattleUIManager`，由後者決定按鈕是可點擊還是灰色。
A.  輪到[前衛]規劃時 (由TurnManager根據「規劃進度」觸發)：
    1.  `TurnManager` 命令 `BattleUIManager` 顯示[前衛]的專屬行動按鈕。
    2.  `BattleUIManager` 回報「玩家為[前衛]選擇了『攻擊』行動」。
    3.  `TurnManager` 進入[玩家選擇目標階段]，向 `BattleRules` 查詢合法目標並命令UI高亮。
    4.  `BattleUIManager` 回報「玩家選擇了目標B」。
    5.  `TurnManager` 已集齊所有資訊（發起者、行動、目標、以及當前的階段索引），創建 `ActionPlan`，預扣資源，並存入 `TurnActionPlanner`。
    6.  `TurnManager` 推進「規劃進度」到下一步。
B.  輪到[遠程]規劃時 (由TurnManager根據「規劃進度」觸發)：
    1.  `TurnManager` 向 `BattleRules` 查詢「此階段有哪些[遠程]單位符合資格行動？」。
    2.  情況一：只有一個單位符合資格 (`BattleRules` 返回 [遠1])。
        *   `TurnManager` 直接將[遠1]定為行動發起者，並跳至第 4 步。
    3.  情況二：有多個單位符合資格 (`BattleRules` 返回 [遠1], [遠2])。
        *   `TurnManager` 命令 `BattleUIManager` 高亮顯示[遠1]和[遠2]，提示玩家必須從中選擇一個。
        *   `BattleUIManager` 回報「玩家選擇了[遠1]作為行動發起者」。
    4.  後續流程 (與[前衛]類似)：
        *   TurnManager 命令 BattleUIManager 顯示所選遠程單位([遠1])的專屬行動按鈕。
        *   後續流程與上方 A 的 2-6 步完全相同，直至推進到下一個「規劃進度」。
C.  玩家的通用操作：
*   取消單個行動 (點擊「取消」按鈕)：
    1.  `BattleUIManager` 回報「請求取消行動格3的行動」。
    2.  `TurnManager` 從 `TurnActionPlanner` 移除對應的 `ActionPlan`，並命令 `BattleUnit` 返還資源。
    3.  `TurnManager` 命令 `BattleUIManager` 更新UI。
*   清空所有規劃 (點擊「清空規劃」按鈕)：
    1.  `BattleUIManager` 回報「請求清空所有玩家規劃」。
    2.  `TurnManager` 命令 `TurnActionPlanner` 移除所有玩家方的 `ActionPlan`。
    3.  命令 `CharacterStateRule` 執行「從快照恢復所有單位狀態」的邏輯。
    4.  `TurnManager` 將「規劃進度」重置回起點，並命令 `BattleUIManager` 更新整個UI。
*   返回上一個流程 (點擊「返回」按鈕)：
    1.  `BattleUIManager` 回報「請求返回到上一個行動」。
    2.  情況一：如果當前處於 (正在選擇目標)
        *   含義：玩家不想選目標了，想重新選擇「行動」。
        *   TurnManager 將「操作步驟」的狀態從[正在選擇目標]切換回[正在選擇行動]。
    3.  情況二：如果當前處於 (已經選擇完遠程單位，且正在選擇行動)
        *   含義：玩家想重新選擇遠程單位了。
        *   TurnManager 將「操作步驟」的狀態從[正在選擇行動]切換回[正在選擇遠程單位]。
D.  處理「交換位置」的特殊流程 (玩家點擊了可用的「交換位置」按鈕)：
    1. `BattleUIManager` 回報「角色想要交換位置」。
    2. `TurnManager` 進入「選擇目標」狀態，向 `BattleRules` 查詢合法的交換目標及其類型。
    3. `BattleRules` 返回一個合法的交換目標列表。
    4. `TurnManager` 命令 `BattleUIManager` 高亮顯示所有合法的目標。
    5. `BattleUIManager` 回報玩家選擇了目標單位B，並將其關聯的交換類型 (例如 'PositionSwap') 一併回報。
    6. `TurnManager` 根據A和B的職位，執行對應的 ActionPlan 創建邏輯，並通知 `ActionPlan` 生成 TransactionID：
        *   如果交換類型是(前衛&遠程)：
        a.  創建兩個 ActionPlan（一個給A，一個給B），都標記為「交換位置」，並賦予相同的 TransactionID。
        b.  預扣資源：僅對主動發起者預扣體力。
        c.  將這兩個 ActionPlan 存入 TurnActionPlanner，它們會佔據不同職位的行動格（一個前衛格，一個遠程格）。
        d.  推進規劃進度：TurnManager 推進到下一個「規劃進度」。
        *   如果交換類型是(遠程&遠程)：
        a.  創建一個 ActionPlan，發起者是A，行動類型是「交換位置」，目標是B，並賦予 TransactionID。
        b.  預扣資源：僅對主動發起者預扣體力。
        c.  將這個單一的 ActionPlan 存入 TurnActionPlanner，它只會佔據一個遠程行動格。
        d.  推進規劃進度：TurnManager 推進到下一個「規劃進度」。
(4) 勝負流程終結：
*   當從 `BattleRules` 得知勝利或失敗條件已達成時，立即中斷當前流程。
*   進入 `[戰鬥勝利]` 或 `[戰鬥失敗]` 狀態。
*   命令 `BattleLog` 顯示對應的結果。
*   命令 `BattleUIManager` 顯示 `BattleEndUI` 的勝利或失敗面板，結束戰鬥循環。

2. BattleManager.cs(戰鬥場景總控制器。)：
介紹：負責整個戰鬥場景的初始化設置與資源管理。
(1) 數據載入：戰鬥開始時，讀取玩家隊伍數據與傳入的 `BattleEncounterSO` 敵人數據。
(2) 忠實的單位實例化與定位：
*   根據讀取的隊伍數據，**僅實例化當前隊伍中實際存在的成員**。
*   在實例化每個 BattleUnit 後，必須根據其職責為其 CurrentPosition 屬性賦予初始值。
(3) 數據分發：將生成的、**可能不完整的**單位列表 (`playerUnits`, `enemyUnits`) 提供給 `TurnManager` 和 `BattleRules` 等模組。
(4) 戰鬥結束處理：處理戰鬥結束後的獎勵發放與場景切換信號。

3. BattleUIManager.cs(系統協調)：
介紹：專職處理所有戰鬥UI顯示邏輯與玩家輸入傳遞的中介者。
(1) UI狀態同步：監聽 `TurnManager` 的狀態變更，並據此顯示、隱藏或更新對應的UI面板。
(2) 輸入中繼：接收來自各UI元件的點擊事件(如 `HealthUI`, `ActionPanelUI`, `ActionSlotPanelUI`, `BattleEndUI`, `BattleLog`)，將其打包成意圖明確的事件後，通知 `TurnManager`。
(3) 視覺反饋協調：根據 `TurnManager` 的指令，調用 `BattleUnit` 的接口來顯示目標選擇等視覺提示。

4. GameManager.cs(遊戲狀態管理器)：
介紹：遊戲最高層級的管理者，負責控制場景切換與跨場景的數據傳遞。
(1) 場景管理：執行戰鬥場景與非戰鬥場景之間的切換。
(2) 數據傳遞：接收 `BattleTrigger` 的戰鬥請求，並將 `BattleEncounterSO` 安全地傳遞給新場景的 `BattleManager`。

---

**戰鬥邏輯**
1. BattleRules.cs (戰鬥法典)：
介紹：作為戰鬥的「規則資料庫」與「仲裁者」，`BattleRules` 是一個被動的邏輯集合。它不主動發起任何行為，只負責儲存所有硬性規定，並精確地回答 `TurnManager` 提出的關於「是否可以做某事」的查詢。
(1) 行動資格與順位判定：
*   提供一個核心查詢方法，供 TurnManager 在「引導式規劃」的每一步調用。
*   接收一個「規劃步驟」（例如[遠程]Phase 2）作為參數，根據內部規則（如角色是否存在、剩餘行動次數、遠程衝突規則），準確地返回當前步驟應該由哪一個具體單位 (BattleUnit) 來規劃。如果沒有任何單位符合資格，則返回「無」。
*   遠程衝突規則：此規則僅在**玩家隊伍中同時存在 [遠1] 和 [遠2] 單位時**才觸發。規則為：「在遠程階段時，玩家選擇一名[遠程]單位規劃行動」。
(2) 目標合法性與指令失效規則：
*   提供一個核心方法，接收「行動發起者」與「行動類型」，返回一個「合法的目標列表」。
*   唯一目標規則：定義「不論敵我，所有『攻擊』行動的目標只能是敵方隊伍的[前衛]單位」。
*   攻擊距離規則：在判定目標合法性時，此方法會執行以下檢查：
    * 獲取攻擊者 (attacker) 和選擇目標 (target) 的位置，並計算 distance。
    * 判定：只有當 distance <= attacker.AttackRange 時，該目標才滿足距離要求。
    * 綜合判定：目標必須同時滿足「唯一目標規則」和「攻擊距離規則」，才會被加入最終的「合法目標列表」。如果列表為空，TurnManager 會據此將對應的「攻擊」按鈕設為灰色。
(3) 資源與狀態查詢：
*   提供一系列查詢方法，供 `TurnManager` 獲取行動相關的數據。
*   行動消耗查詢：提供方法，告知特定行動需要消耗多少體力或其他資源。
*   行動次數查詢：提供方法，查詢特定角色是否因「行動次數耗盡」而無法再行動。此查詢結果主要用於 `BattleUIManager` 將對應的行動按鈕變為灰色。
(4) 勝利與失敗條件判定：
*   定義單位陣亡後應觸發的連鎖反應規則。
    *   勝利條件：檢查 `BattleManager` 提供的敵方單位列表 (`enemyUnits`) 是否所有成員都已陣亡。
    *   失敗條件：檢查 `BattleManager` 提供的我方單位列表 (`playerUnits`) 是否所有成員都已陣亡。
(5) 單位陣亡後續處理規則：
*   定義單位陣亡後應觸發的連鎖反應規則。
*   位置替補規則：定義單位陣亡後，後排單位自動向前替補的詳細順序
    * 「[前衛]陣亡，[遠1]替補」
    * 「[遠1]無人，[遠2]替補」
    * 「[前衛]、[遠1]、[遠2]陣亡，[後勤]替補[前衛]位置」
*   行動刪除規則：定義當一個單位陣亡時，應通知 `TurnActionPlanner` 將其所有尚未執行的後續行動從規劃中移除。
(6) 特殊技能使用規則：
*   指揮官技能：記錄[指揮官技能]在本場戰鬥中是否已被使用。提供一個方法供 `TurnManager` 查詢，以決定是否顯示[指揮官技能]按鈕。

2. BattleActions.cs(行動邏輯)：
介紹：包含所有具體行動（如攻擊、防禦）實現邏輯的執行者。
(1) 執行行動：接收 `TurnManager` 的命令和一個 `ActionPlan`，並根據 `ActionPlan` 的內容執行具體的遊戲邏輯，如對目標造成傷害、為自身附加狀態等。
(2) 定義行動效果：
* 攻擊：消耗 3點 體力對敵人造成傷害。
* 防禦：該行動格受到傷害減半。
* 技能：(尚未設計)
* 道具：(尚未設計)
* 交換位置：接收到一個帶有 `TransactionID` 的「交換位置」`ActionPlan`。
    1. 交易驗證：
        * 查詢 `TurnActionPlanner`，獲取擁有相同 `TransactionID` 的所有 `ActionPlan` 及其參與者。
        * 檢查所有參與者是否依然存活。
    2. 執行邏輯(只在第一個關聯行動被調用時執行一次)：
        * 如果所有參與者都存活 (交易成功)：
        a.  據 `ActionPlan` 中的數據，執行實際的位置交換 (`unitA.CurrentPosition <=> unitB.CurrentPosition`)。
        b.  播放交換動畫。(未設計)
        * 如果任何參與者已陣亡 (交易失敗)：
        a.  執行「指令失效規則」，將本次行動的效果動態地替換為「休息」。
    3. [後勤]無法進行交換。
* 跳過：此方法為空，不執行任何操作。
(3) 指令失效規則：定義一個規則：「如果在[行動執行階段]，一個「攻擊」行動的預定目標已不存在，該行動應如何自動轉化。」
    1.  一般攻擊失效：
        * 若「攻擊」行動發起者是 [前衛]，其「攻擊」行動將被轉換為 「防禦」(其他行動不變)。
        * 若「攻擊」行動發起者是 [遠程]，其「攻擊」行動將被轉換為 「休息」(其他行動不變)。
    2.  關聯行動失效：
        * 如果一個關聯行動（由 TransactionID 標記）中的任何一個參與者在執行前已經陣亡，則整個「關聯行動」失敗。
        * 若是「交換位置」失效，失效方的行動改為「休息」。
    *   **備註**：此規則的最終執行由 `BattleActions` 模組在執行具體行動前進行判斷和處理。

3. TurnActionPlanner.cs(回合行動規劃器)：
介紹：負責記錄與管理**玩家與敵人雙方**在[玩家規劃階段]與[敵人回合]所安排的所有行動。
功能：
(1) 統一儲存：提供一個 `List<ActionPlan>` ，用於儲存本回合**雙方**所有已規劃的行動。
(2) 精確提供行動：提供一個查詢方法，能根據 `TurnManager` 傳入的「階段索引」、「陣營(玩家/敵人)」、「角色職責(前衛/遠程)」等參數，精準地返回對應的 `ActionPlan`。
(3) 計數查詢：提供方法以計算某個 `BattleUnit` 已規劃的行動數量，供 `BattleRules` 判斷行動次數是否耗盡。

4. CharacterStateRule.cs：
介紹：管理戰鬥中角色在特定時間點的狀態變化規則。
(1) 狀態儲存：創建一個 UnitStateSnapshot 方法，儲存目標單位的唯一標識符 (UnitID) 和該時間點的體力值 (Stamina)。
(2) 體力恢復：提供一個方法，用於在[玩家規劃階段]開始時，將所有存活單位的體力恢復至全滿。此方法由 `TurnManager` 調用。
(**未來會再增加**)

5. EnemyBattleAI.cs(敵人進攻邏輯)：
介紹：負責在[敵人回合]為敵方單位規劃行動。
(1) 規劃行動：在[敵人回合]被 `TurnManager` 調用時，為所有敵方單位生成 `ActionPlan`，並將其添加到 `TurnActionPlanner` 中。AI需要遵循與玩家類似的規則（如前衛每階段行動、遠程行動分配等）。
(2) 每個行動格都使用攻擊行動，若體力耗盡，使用防禦。
(**未來再修改**)