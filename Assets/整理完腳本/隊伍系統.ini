### 隊伍系統：

**隊伍成員核心資料**
1. MemberDataSO.cs (ScriptableObject)：
(1) 成員基礎模板 (由開發者在Unity編輯器中設定)
*   **基礎資訊**: 成員ID (獨一無二的編號)、成員名稱、成員圖像 (`Sprite` 引用)。
*   **基礎屬性**: 基礎血量、基礎攻擊力、體力(攻擊、施放技能消耗)、攻擊距離。
*   **技能槽位**: 從技能腳本中挑選技能ID輸入。
*   **成長規則**: 每級提升的血量、每級提升的攻擊力。(目前不需要，可註解)

2. PartyDatabase.cs (ScriptableObject)：
(1) 隊伍成員核心資料庫: 一個中央 ScriptableObject。
(2) 成員名冊: 包含遊戲中所有 `MemberDataSO` 的列表引用。
(3) 全局訪問: 在遊戲啟動時載入，提供全局靜態方法，讓其他系統可以方便地透過ID獲取任何成員的模板數據。

3. MemberInstance.cs (可序列化 Class)：
(1) 玩家擁有的成員個體 (用於存檔)
*   **關聯ID**: `memberDataSO_ID`，用來關聯到對應的 `MemberDataSO` 模板。
*   **唯一ID**: `instanceID`，每個實例都有獨一無二的識別碼。
*   **動態數據**: 等級、經驗值。(目前不需要，可註解)
*   **狀態屬性**: 當前HP、當前攻擊力 (根據等級計算後的值)。
(2) 可序列化為 JSON: 這個類別的物件會被寫入玩家的存檔中。

4. SkillData.cs (ScriptableObject)：
(1) Enums: 被動技能、主動技能、指揮官技能。
(2) 技能資料: ID、名稱、描述、是否為攻擊(若是-攻擊距離)、是否為回血(若是-使用距離)、是否為被動技能

5. SkillDatabase.cs (ScriptableObject)：
(1) 存放所有的技能，供調查使用。
---

### **隊伍UI**

**1. MemberCardUI (Prefab)**
*   **(1) 可重用UI元件**: 一個包含成員圖像、成員名稱和按鈕的獨立 Prefab。
*   **(2) 數據填充**: 有一個腳本，接收 `MemberInstance` 資料並更新卡片上的圖像和名稱。
*   **(3) 狀態反饋**: 包含被選中、在戰鬥隊伍中等不同的視覺狀態（例如發光邊框）。

**2. MemberStatCardUI (Prefab)**
*   **(1) 可重用UI元件**: 一個包含成員圖像、成員名稱、攻擊力、體力、攻擊距離和按鈕的獨立 Prefab。
*   **(2) 數據填充**: 有一個腳本，接收 `MemberInstance` 資料並更新卡片上的圖像和名稱。
*   **(3) 狀態反饋**: 包含被選中、在戰鬥隊伍中等不同的視覺狀態（例如發光邊框）。

**3. PartyHolderUI.cs (全部成員倉庫)**
*   **(1) 顯示模式**: 使用 `Scroll View` 搭配 `Grid Layout Group` 來顯示目前擁有的所有成員卡片。
*   **(2) 點擊互動**: 點擊任一成員卡片，會通知 `PartyDetailUI` 顯示其詳細資料。

**4. PartyBattleUI.cs (戰鬥隊伍)**
*   **(1) 顯示模式**: 使用固定的容器（例如 `Horizontal Layout Group`）顯示當前出戰的成員卡片和基礎屬性(名稱、圖像、血量、攻擊力)。
*   **(2) 互動操作**: 支援點擊卡片查看詳細資料，以及拖曳卡片來交換戰鬥成員的順序。

**5. PartyDetailUI.cs (成員詳細資料面板)**
*   **(1) 顯示時機**: 預設隱藏，點擊任一成員卡片時顯示。
*   **(2) 數據展示**: 顯示該成員的詳細數據（名稱、圖像、當前/最大HP、攻擊力、體力、攻擊距離）。
*   **(3) 動態按鈕**: 提供「上陣」或「卸下」按鈕，按鈕的功能和文字會根據該成員是否已在戰鬥隊伍中動態改變。
*   **(4) 隱藏邏輯**: 面板上有關閉按鈕；當整個隊伍介面關閉時，此詳細面板也應同步隱藏。

---

### **隊伍管理器**

**1. PartyManager.cs**
*   **(1) 核心邏輯**: 管理玩家擁有的 `AllMembers` (所有成員實例列表) 和 `BattleParty` (戰鬥隊伍成員實例列表)，並限制戰鬥隊伍人數。
*   **(2) 功能**:
    *   **加入/移除成員**: 處理 `MemberInstance` 的增減。
    *   **戰鬥隊伍管理**: 指派成員上陣、從戰鬥隊伍中移除。
    *   **排序**: 交換戰鬥成員的順序。
    *   **狀態判斷**: 提供方法判斷是否有可戰鬥的成員 (HP > 0)。
*   **(3) 事件系統**:
    *   提供一個全局的 `OnPartyUpdated` 事件，當隊伍資料（成員增減、順序變更）發生變化時觸發，通知所有相關UI進行刷新。
*   **(4) 存檔與載入**: 觸發 `JSONSaveManager` 來儲存或載入隊伍資料。

---

### **JSON 儲存、讀取系統**

**1. JSONSaveManager.cs**
*   **(1) 序列化/反序列化**: 專門負責將 `PartyManager` 中的 `MemberInstance` 列表轉換為 JSON 字串，或從 JSON 字串還原。
*   **(2) 檔案管理**:
    *   將隊伍資料存為 JSON 檔。
    *   從指定的路徑載入 JSON 檔。
    *   管理存檔路徑，並檢查檔案是否存在。
*   **(3) 資料驗證**: (可選，但建議) 載入存檔時，檢查存檔中的 `memberDataSO_ID` 在當前的 `PartyDatabase` 中是否依然存在，避免因遊戲版本更新造成錯誤。

---

### **重點回顧**

1.  **資料分層**: **ScriptableObject** 作為「設計藍圖」，**JSON** 作為玩家「進度存檔」。
2.  **UI模組化**: 核心是可重用的 **`MemberCardUI` Prefab**。
3.  **單一職責**: 系統完全專注於**成員的持有、升級和隊伍的編組**，移除了所有額外系統的耦合。
4.  **互動核心**: 玩家透過點擊查看詳情，並透過拖曳或按鈕進行隊伍管理。
5.  **穩健性**: 確保**腳本執行順序**正確，並做好**Unity編輯器內的UI連結**是成功運行的關鍵。