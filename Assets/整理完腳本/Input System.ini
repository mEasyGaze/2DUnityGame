### **各腳本功能簡介**

### **輸入模組 ** (Input System Module)**

1. InputManager.cs：
(1) 使用 Unity 內建的 Input System 方法。

2. KeybindingManager.cs：
(1) 處理按鍵的數據（儲存和讀取）。
(2) 監聽輸入事件並觸發UI行為。

3. GameSystemUI.cs：
(1) 內含 KeybindingUI 面板，可透過按鈕點擊開啟。
(2) 內含 SoundSettingsUI 面板，可透過按鈕點擊開啟。(未設計)(未來的聲音、音效系統)

4. KeybindingUI.cs：
(1) 顯示 KeybindingEntryUI Prefab。
(2) 按鈕功能：套用、重置、返回。
*   套用：點擊後儲存。
*   重置：點擊後回到最初狀態。
*   返回：返回到前一頁。

5. KeybindingEntryUI.cs(Prefab)：
(1) 讓玩家可以實際看到並修改按鍵。

**邏輯流程圖**

```mermaid
graph TD
    A[打開按鍵綁定UI] --> B{載入 PlayerPrefs 到 '待辦字典'};
    B --> C{根據 '待辦字典' 更新所有按鈕文字};
    
    subgraph "玩家操作"
        D[點擊 'Rebind'] --> E{開始重新綁定};
        E --> F[玩家按下新按鍵];
        F --> G{新按鍵路徑寫入 '待辦字典'};
        G --> H{只更新該按鈕的文字};
        
        I[點擊 'Reset'] --> J{清空 '待辦字典'};
        J --> K{遍歷所有按鈕, 用預設綁定更新文字};
    end
    
    C --> D;
    C --> I;
    H --> C;
    K --> C;
    
    subgraph "最終決定"
        L[點擊 'Apply'] --> M{將 '待辦字典' 轉為 JSON};
        M --> N{應用 JSON 到 Input System};
        N --> O{儲存 JSON 到 PlayerPrefs};
        O --> P[關閉面板];
        
        Q[點擊 'Back' 或 'Escape'] --> R{不做任何事};
        R --> P;
    end
    
    C --> L;
    C --> Q;
```

#### **1. `InputManager.cs`**

這個腳本現在是輸入系統的核心，它會讀取 `PlayerControls` 的輸入，並透過事件將這些輸入分發出去。

```csharp
using UnityEngine;
using UnityEngine.InputSystem;
using System;

public class InputManager : MonoBehaviour
{
    public static InputManager Instance { get; private set; }
    
    private PlayerControls playerControls;

    public bool IsInitialized { get; private set; } = false;

    public event Action<Vector2> OnMove;
    public event Action OnInteract;
    public event Action OnPickup;
    public event Action OnToggleInventory;
    public event Action OnToggleQuestLog;
    public event Action OnTogglePartyHolder;
    public event Action OnToggleBattleParty;
    public event Action OnToggleMap;
    public event Action OnEscape;

    void Awake()
    {
        if (Instance != null)
        {
            Debug.LogWarning("發現重複的 InputManager 實例，已將新的銷毀。");
            Destroy(this.gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(this.gameObject);

        Initialize();
    }

    private void Initialize()
    {
        if (IsInitialized) return;

        playerControls = new PlayerControls();
        RegisterGameplayActions();
        
        IsInitialized = true;
        Debug.Log("InputManager Initialized and is now persistent.");
    }

    private void OnEnable()
    {
        playerControls?.Gameplay.Enable();
    }

    private void OnDisable()
    {
        playerControls?.Gameplay.Disable();
    }

    void OnDestroy()
    {
        if (Instance == this)
        {
            if (playerControls != null)
            {
                UnregisterGameplayActions();
                playerControls.Dispose();
                playerControls = null;
            }
        }
    }

    private void RegisterGameplayActions()
    {
        playerControls.Gameplay.Move.performed += HandleMove;
        playerControls.Gameplay.Move.canceled += HandleMove;

        playerControls.Gameplay.Interact.performed += HandleInteract;
        playerControls.Gameplay.Pickup.performed += HandlePickup;
        playerControls.Gameplay.ToggleInventory.performed += HandleToggleInventory;
        playerControls.Gameplay.ToggleQuestLog.performed += HandleToggleQuestLog;
        playerControls.Gameplay.TogglePartyHolder.performed += HandleTogglePartyHolder;
        playerControls.Gameplay.ToggleBattleParty.performed += HandleToggleBattleParty;
        playerControls.Gameplay.ToggleMap.performed += HandleToggleMap;
        playerControls.Gameplay.Escape.performed += HandleEscape;
    }

    private void UnregisterGameplayActions()
    {
        if (playerControls == null) return;

        playerControls.Gameplay.Move.performed -= HandleMove;
        playerControls.Gameplay.Move.canceled -= HandleMove;

        playerControls.Gameplay.Interact.performed -= HandleInteract;
        playerControls.Gameplay.Pickup.performed -= HandlePickup;
        playerControls.Gameplay.ToggleInventory.performed -= HandleToggleInventory;
        playerControls.Gameplay.ToggleQuestLog.performed -= HandleToggleQuestLog;
        playerControls.Gameplay.TogglePartyHolder.performed -= HandleTogglePartyHolder;
        playerControls.Gameplay.ToggleBattleParty.performed -= HandleToggleBattleParty;
        playerControls.Gameplay.ToggleMap.performed -= HandleToggleMap;
        playerControls.Gameplay.Escape.performed -= HandleEscape;
    }

    #region Input Action Handlers
    private void HandleMove(InputAction.CallbackContext context) => OnMove?.Invoke(context.ReadValue<Vector2>());
    private void HandleInteract(InputAction.CallbackContext context) => OnInteract?.Invoke();
    private void HandlePickup(InputAction.CallbackContext context) => OnPickup?.Invoke();
    private void HandleToggleInventory(InputAction.CallbackContext context) => OnToggleInventory?.Invoke();
    private void HandleToggleQuestLog(InputAction.CallbackContext context) => OnToggleQuestLog?.Invoke();
    private void HandleTogglePartyHolder(InputAction.CallbackContext context) => OnTogglePartyHolder?.Invoke();
    private void HandleToggleBattleParty(InputAction.CallbackContext context) => OnToggleBattleParty?.Invoke();
    private void HandleToggleMap(InputAction.CallbackContext context) => OnToggleMap?.Invoke();
    private void HandleEscape(InputAction.CallbackContext context) => OnEscape?.Invoke();
    #endregion

    public PlayerControls GetPlayerControls()
    {
        return playerControls;
    }
}
```

---

#### **2. `KeybindingManager.cs`**

這個管理器負責處理所有 UI 面板的開關邏輯，並監聽 `InputManager` 的事件。它也將處理未來按鍵綁定的存儲和加載。

```csharp
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.SceneManagement;

public class KeybindingManager : MonoBehaviour
{
    private InventoryUI inventoryUI; 
    private QuestUI questUI;
    private PartyHolderUI partyHolderUI;
    private PartyBattleUI partyBattleUI;
    private GameSystemUI gameSystemUI;

    public static KeybindingManager Instance { get; private set; }

    private bool areEventsSubscribed = false;

    void Awake()
    {
        if (Instance != null)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
        SubscribeToInputEvents();
    }
    
    void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
        if (InputManager.Instance != null)
        {
            UnsubscribeFromInputEvents();
        }
    }
    
    void Start()
    {
        FindUIReferences();
    }
    
    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        FindUIReferences();
    }
    
    private void SubscribeToInputEvents()
    {
        if (InputManager.Instance == null || areEventsSubscribed) return;

        InputManager.Instance.OnToggleInventory += HandleToggleInventory;
        InputManager.Instance.OnToggleQuestLog += HandleToggleQuestLog;
        InputManager.Instance.OnTogglePartyHolder += HandleTogglePartyHolder;
        InputManager.Instance.OnToggleBattleParty += HandleToggleBattleParty;
        InputManager.Instance.OnEscape += HandleEscapeKey;
        
        areEventsSubscribed = true;
        Debug.Log("KeybindingManager: Events subscribed.");
    }
    
    private void UnsubscribeFromInputEvents()
    {
        if (InputManager.Instance == null || !areEventsSubscribed) return;

        InputManager.Instance.OnToggleInventory -= HandleToggleInventory;
        InputManager.Instance.OnToggleQuestLog -= HandleToggleQuestLog;
        InputManager.Instance.OnTogglePartyHolder -= HandleTogglePartyHolder;
        InputManager.Instance.OnToggleBattleParty -= HandleToggleBattleParty;
        InputManager.Instance.OnEscape -= HandleEscapeKey;
        
        areEventsSubscribed = false;
        Debug.Log("KeybindingManager: Events unsubscribed.");
    }

    private void FindUIReferences()
    {
        inventoryUI = FindObjectOfType<InventoryUI>(true);
        questUI = FindObjectOfType<QuestUI>(true);
        partyHolderUI = FindObjectOfType<PartyHolderUI>(true);
        partyBattleUI = FindObjectOfType<PartyBattleUI>(true);
        gameSystemUI = FindObjectOfType<GameSystemUI>(true);
    }
    
    #region 按鍵處理邏輯
    private void HandleToggleInventory() => inventoryUI?.TogglePanel();
    private void HandleToggleQuestLog() => questUI?.TogglePanel();
    private void HandleTogglePartyHolder() => partyHolderUI?.TogglePanel();
    private void HandleToggleBattleParty() => partyBattleUI?.TogglePanel();
    
    private void HandleEscapeKey()
    {
        if (gameSystemUI != null && gameSystemUI.IsAnyPanelActive())
        {
            gameSystemUI.TryCloseSubPanels();
            return;
        }
        
        if (inventoryUI != null && inventoryUI.IsPanelActive()) 
        {
            inventoryUI.HidePanel();
        }
        else if (questUI != null && questUI.gameObject.activeInHierarchy)
        {
            questUI.TogglePanel();
        }
        else if (partyHolderUI != null && partyHolderUI.gameObject.activeInHierarchy)
        {
            partyHolderUI.TogglePanel();
        }
        else if (partyBattleUI != null && partyBattleUI.gameObject.activeInHierarchy)
        {
            partyBattleUI.TogglePanel();
        }
        else
        {
            gameSystemUI?.ToggleMainPanel();
        }
    }
    #endregion
    
    #region 按鍵綁定
    public void SaveKeybindings()
    {
        if (InputManager.Instance == null) return;
        var playerControls = InputManager.Instance.GetPlayerControls();
        if (playerControls == null) return;

        string rebinds = playerControls.SaveBindingOverridesAsJson();
        PlayerPrefs.SetString("KeyRebinds", rebinds);
        PlayerPrefs.Save();
        Debug.Log("按鍵綁定已儲存。");
    }

    public void LoadKeybindings()
    {
        if (InputManager.Instance == null) return;
        var playerControls = InputManager.Instance.GetPlayerControls();
        if (playerControls == null) return;

        if (PlayerPrefs.HasKey("KeyRebinds"))
        {
            string rebinds = PlayerPrefs.GetString("KeyRebinds");
            playerControls.LoadBindingOverridesFromJson(rebinds);
            Debug.Log("按鍵綁定已載入。");
        }
    }
    #endregion
}
```

---

#### **3. `GameSystemUI.cs` **

```csharp
using UnityEngine;
using UnityEngine.UI;

public class GameSystemUI : MonoBehaviour
{
    [Header("主面板")]
    [SerializeField] private GameObject systemMainPanel;

    [Header("子面板")]
    [SerializeField] private KeybindingUI keybindingPanel;
    // [SerializeField] private SoundSettingsUI soundSettingsPanel;

    [Header("控制按鈕")]
    [SerializeField] private Button openKeybindingButton;
    // [SerializeField] private Button openSoundSettingsButton;
    [SerializeField] private Button closeMainPanelButton;

    void Awake()
    {
        if (systemMainPanel != null) systemMainPanel.SetActive(false);
        if (keybindingPanel != null) keybindingPanel.gameObject.SetActive(false);
        // if (soundSettingsPanel != null) soundSettingsPanel.gameObject.SetActive(false);

        if (openKeybindingButton != null) openKeybindingButton.onClick.AddListener(ShowKeybindingPanel);
        // if (openSoundSettingsButton != null) openSoundSettingsButton.onClick.AddListener(ShowSoundSettingsPanel);
        if (closeMainPanelButton != null) closeMainPanelButton.onClick.AddListener(CloseAllPanels);
    }

    public void ToggleMainPanel()
    {
        bool isActive = systemMainPanel.activeSelf;
        if (isActive)
        {
            CloseAllPanels();
        }
        else
        {
            ShowMainPanel();
        }
    }

    private void ShowMainPanel()
    {
        if (systemMainPanel != null) systemMainPanel.SetActive(true);
        if (keybindingPanel != null) keybindingPanel.gameObject.SetActive(false);
        // if (soundSettingsPanel != null) soundSettingsPanel.gameObject.SetActive(false);
    }
    
    public void ShowKeybindingPanel()
    {
        if (systemMainPanel != null && !systemMainPanel.activeSelf)
        {
            systemMainPanel.SetActive(true);
        }
        if (keybindingPanel != null) keybindingPanel.gameObject.SetActive(true);
    }
    
    // public void ShowSoundSettingsPanel()
    // {
    //     if (systemMainPanel != null) systemMainPanel.SetActive(true);
    //     if (soundSettingsPanel != null) soundSettingsPanel.gameObject.SetActive(true);
    // }
    
    public void CloseAllPanels()
    {
        if (systemMainPanel != null) systemMainPanel.SetActive(false);
        if (keybindingPanel != null) keybindingPanel.gameObject.SetActive(false);
        // if (soundSettingsPanel != null) soundSettingsPanel.gameObject.SetActive(false);
    }

    public void TryCloseSubPanels()
    {
        if (keybindingPanel != null && keybindingPanel.gameObject.activeSelf)
        {
            keybindingPanel.ClosePanelWithoutSaving();
        }
        else
        {
            CloseAllPanels();
        }
    }
    
    public bool IsAnyPanelActive()
    {
        bool mainActive = systemMainPanel != null && systemMainPanel.activeSelf;
        bool keybindActive = keybindingPanel != null && keybindingPanel.gameObject.activeSelf;
        // bool soundActive = soundSettingsPanel != null && soundSettingsPanel.gameObject.activeSelf;
        return mainActive || keybindActive; // || soundActive;
    }
}
```

---

#### **4. `KeybindingUI.cs` **

這是顯示和修改按鍵綁定的 UI 腳本，核心是將 `KeybindingUI` 變成一個「**暫存區**」。

1.  **Reset Button**：現在點擊它，會清空 `bindingOverrides` 這個「待辦字典」，然後 `RefreshAllEntryTexts()` 會讓所有 `KeybindingEntryUI` 讀取它們的預設按鍵文字。因為字典裡沒有覆蓋項，所以顯示會正確地恢復預設。
2.  **Apply Button**：現在，只有當您點擊 `Apply` 時，`bindingOverrides` 字典裡的所有「待辦事項」才會被一次性地應用到 `Input System` 的運行時和 `PlayerPrefs` 存檔中。
3.  **不保存退出**：如果您修改了按鍵但沒有按 `Apply` 就直接關閉面板，`ClosePanelWithoutSaving()` 會從 `PlayerPrefs` 重新加載**上一次保存**的設定到運行時，您在這次面板中做的所有修改都會被拋棄。

```csharp
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;
using TMPro;

public class KeybindingUI : MonoBehaviour
{
    [Header("要綁定的動作列表")]
    [Tooltip("將所有想讓玩家自訂的動作 (InputActionReference) 拖到這裡。")]
    [SerializeField] private List<InputActionReference> actionsToBind;

    [Header("UI 預製件與容器")]
    [SerializeField] private GameObject entryPrefab;
    [SerializeField] private Transform container;
    
    [Header("控制按鈕")]
    [SerializeField] private Button applyButton;
    [SerializeField] private Button resetButton;
    [SerializeField] private Button backButton;

    [Header("重新綁定提示")]
    [SerializeField] private GameObject rebindingOverlay;
    [SerializeField] private TextMeshProUGUI rebindingText;
    
    private List<KeybindingEntryUI> spawnedEntries = new List<KeybindingEntryUI>();
    private InputActionRebindingExtensions.RebindingOperation rebindingOperation;
    
    private Dictionary<string, string> bindingOverrides = new Dictionary<string, string>();
    
    private bool isPopulated = false;

    void Start()
    {
        if (applyButton != null) applyButton.onClick.AddListener(ApplyAndSaveChanges);
        if (resetButton != null) resetButton.onClick.AddListener(ResetBindingsToDefault);
        if (backButton != null) backButton.onClick.AddListener(ClosePanelWithoutSaving);
        
        if (rebindingOverlay != null) rebindingOverlay.SetActive(false);
    }
    
    private void OnEnable()
    {
        if (InputManager.Instance != null && InputManager.Instance.IsInitialized)
        {
            if (!isPopulated)
            {
                PopulateUI();
            }
            
            LoadSavedOverridesToDictionary();
            RefreshAllEntryTexts();
        }
        else
        {
            Debug.LogWarning("KeybindingUI enabled, but InputManager is not ready yet. UI will not populate.");
        }
    }
    
    private void OnDisable()
    {
        rebindingOperation?.Cancel();
        rebindingOperation = null;
    }
    
    private void PopulateUI()
    {
        if (isPopulated || container == null || entryPrefab == null) return;

        foreach (Transform child in container) { Destroy(child.gameObject); }
        spawnedEntries.Clear();

        if (actionsToBind == null || actionsToBind.Count == 0) return;
        
        foreach (var actionRef in actionsToBind)
        {
            if (actionRef == null || actionRef.action == null) continue;
            if (actionRef.action.bindings.Count > 0 && actionRef.action.bindings[0].isComposite) continue;
            
            int bindingIndex = 0;

            GameObject entryGO = Instantiate(entryPrefab, container);
            KeybindingEntryUI entryUI = entryGO.GetComponent<KeybindingEntryUI>();
            
            if (entryUI != null)
            {
                entryUI.Setup(actionRef, bindingIndex, HandleRebindRequest);
                spawnedEntries.Add(entryUI);
            }
        }
        isPopulated = true;
        Debug.Log("KeybindingUI Populated with " + spawnedEntries.Count + " entries.");
    }
    
    private void HandleRebindRequest(KeybindingEntryUI entryToRebind)
    {
        rebindingOperation?.Cancel();
        
        if (rebindingOverlay != null)
        {
            rebindingOverlay.SetActive(true);
            if (rebindingText != null)
            {
                rebindingText.text = $"正在綁定: {entryToRebind.GetActionName()}...\n請按下任意鍵 (ESC 取消)";
            }
        }
        
        entryToRebind.StartRebinding(
            (op) => {
                rebindingOperation = op;
            },
            (operation) => {
                if (!operation.canceled)
                {
                    string newPath = operation.action.bindings[entryToRebind.BindingIndex].overridePath;
                    bindingOverrides[entryToRebind.GetActionId()] = newPath;
                    entryToRebind.UpdateKeyTextWithOverride(newPath);
                }
                
                if (rebindingOverlay != null) rebindingOverlay.SetActive(false);
                
                rebindingOperation?.Dispose();
                rebindingOperation = null;
            }
        );
    }
    
    private void RefreshAllEntryTexts()
    {
        if (!isPopulated) return;
        
        foreach(var entry in spawnedEntries)
        {
            if (entry == null) continue;
            
            string actionId = entry.GetActionId();
            if (bindingOverrides.TryGetValue(actionId, out string overridePath))
            {
                entry.UpdateKeyTextWithOverride(overridePath);
            }
            else
            {
                entry.UpdateKeyTextToDefault();
            }
        }
    }
    
    public void ApplyAndSaveChanges()
    {
        if (!isPopulated) return;
        
        string overridesJson = DictionaryToJson(bindingOverrides);
        
        if (InputManager.Instance != null && InputManager.Instance.GetPlayerControls() != null)
        {
            var playerControls = InputManager.Instance.GetPlayerControls();
            playerControls.LoadBindingOverridesFromJson(overridesJson, true);
        }
        
        PlayerPrefs.SetString("KeyRebinds", overridesJson);
        PlayerPrefs.Save();
        
        Debug.Log("按鍵綁定已套用並儲存。");
        ClosePanelWithoutSaving();
    }
    
    public void ResetBindingsToDefault()
    {
        if (!isPopulated) return;
        
        bindingOverrides.Clear();
        RefreshAllEntryTexts();
        Debug.Log("所有按鍵已在 UI 上恢復預設。按下 '套用' 以確認。");
    }

    public void ClosePanelWithoutSaving()
    {
        if (isPopulated)
        {
            LoadSavedBindingsAndApplyToRuntime();
        }
        gameObject.SetActive(false);
    }

    private void LoadSavedBindingsAndApplyToRuntime()
    {
        if (InputManager.Instance == null) return;
        var playerControls = InputManager.Instance.GetPlayerControls();
        if (playerControls == null) return;
        
        if (PlayerPrefs.HasKey("KeyRebinds"))
        {
            string rebinds = PlayerPrefs.GetString("KeyRebinds");
            playerControls.LoadBindingOverridesFromJson(rebinds);
        }
        else
        {
            playerControls.RemoveAllBindingOverrides();
        }
    }

    private void LoadSavedOverridesToDictionary()
    {
        bindingOverrides.Clear();
        if (PlayerPrefs.HasKey("KeyRebinds"))
        {
            string rebindsJson = PlayerPrefs.GetString("KeyRebinds");
            if (string.IsNullOrEmpty(rebindsJson)) return;

            var rebindsWrapper = JsonUtility.FromJson<RebindsWrapper>(rebindsJson);
            if (rebindsWrapper != null && rebindsWrapper.bindings != null)
            {
                foreach(var binding in rebindsWrapper.bindings)
                {
                    bindingOverrides[binding.id] = binding.path;
                }
            }
        }
    }
    
    private string DictionaryToJson(Dictionary<string, string> dict)
    {
        var bindingsList = dict.Select(kvp => 
            new RebindData { id = kvp.Key, path = kvp.Value }
        ).ToList();
        
        var wrapper = new RebindsWrapper { bindings = bindingsList };
        return JsonUtility.ToJson(wrapper);
    }
    
    [System.Serializable]
    private class RebindsWrapper { public List<RebindData> bindings; }

    [System.Serializable]
    private class RebindData { public string id; public string path; }
}
```

#### **6. `KeybindingEntryUI.cs(Prefab)` **

```csharp
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.InputSystem;
using TMPro;
using System;

public class KeybindingEntryUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private TextMeshProUGUI actionNameText;
    [SerializeField] private Button rebindButton;
    [SerializeField] private TextMeshProUGUI keyText;

    private InputActionReference actionReference;
    
    public int BindingIndex { get; private set; }

    public void Setup(InputActionReference actionRef, int index, Action<KeybindingEntryUI> onRebindClicked)
    {
        this.actionReference = actionRef;
        this.BindingIndex = index;
        
        if (actionNameText != null)
        {
            actionNameText.text = actionRef.action.name;
        }

        rebindButton.onClick.RemoveAllListeners();
        rebindButton.onClick.AddListener(() => onRebindClicked(this));
        
        UpdateKeyTextToDefault();
    }
    
    public string GetActionName()
    {
        return actionReference != null ? actionReference.action.name : "未知動作";
    }

    public string GetActionId()
    {
        if (actionReference == null || actionReference.action == null) return null;
        return actionReference.action.bindings[BindingIndex].id.ToString();
    }

    public void UpdateKeyTextToDefault()
    {
        if (keyText != null && actionReference != null && actionReference.action != null)
        {
            keyText.text = InputControlPath.ToHumanReadableString(
                actionReference.action.bindings[BindingIndex].path,
                InputControlPath.HumanReadableStringOptions.OmitDevice
            );
        }
    }

    public void UpdateKeyTextWithOverride(string overridePath)
    {
        if (keyText != null)
        {
             keyText.text = InputControlPath.ToHumanReadableString(
                overridePath,
                InputControlPath.HumanReadableStringOptions.OmitDevice
            );
        }
    }

    public void StartRebinding(Action<InputActionRebindingExtensions.RebindingOperation> onStarted, Action<InputActionRebindingExtensions.RebindingOperation> onComplete)
    {
        if (actionReference == null || actionReference.action == null) return;

        keyText.text = "...";
        rebindButton.interactable = false;
        
        var action = actionReference.action;
        action.Disable();

        var rebindOp = action.PerformInteractiveRebinding(BindingIndex)
            .WithControlsExcluding("Mouse")
            .WithCancelingThrough("<Keyboard>/escape")
            .OnMatchWaitForAnother(0.1f)
            .OnComplete(operation => {
                FinishRebinding(operation, onComplete);
            })
            .OnCancel(operation => {
                FinishRebinding(operation, onComplete);
            });
        
        onStarted?.Invoke(rebindOp);
        rebindOp.Start();
    }
    
    private void FinishRebinding(InputActionRebindingExtensions.RebindingOperation operation, Action<InputActionRebindingExtensions.RebindingOperation> onComplete)
    {
        rebindButton.interactable = true;
        actionReference.action.Enable();

        if (keyText != null)
        {
            keyText.text = InputControlPath.ToHumanReadableString(
                actionReference.action.bindings[BindingIndex].effectivePath,
                InputControlPath.HumanReadableStringOptions.OmitDevice
            );
        }
        onComplete?.Invoke(operation);
    }
}
```