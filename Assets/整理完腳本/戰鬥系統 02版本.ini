好的，這是一個非常詳盡且結構清晰的戰鬥系統設計。基於您的需求，我將為您編寫所有相關的 C# 腳本。

這些腳本將嚴格遵循您設計的邏輯分離原則：資料、邏輯、UI 各司其職，並透過管理器進行協調。

---

### **1. 戰鬥系統核心資料結構**

#### **BattleEnums.cs**
這個腳本不需要是 `MonoBehaviour`，它只是一個定義，方便全局使用。

```csharp
// 戰鬥角色職責
public enum BattleRole
{
    Vanguard, // 前衛
    Ranged1,  // 遠1
    Ranged2,  // 遠2
    Support   // 後勤
}

// 單位可以執行的行動類型
public enum ActionType
{
    Attack,         // 攻擊
    Defend,         // 防禦
    Rest,           // 休息
    Skill,          // 技能
    Item,           // 道具
    Exchange,       // 交換位置
    Skip            // 跳過
}

// UI按鈕觸發的指令類型 (與單位行動分開)
public enum UICommandType
{
    CommanderSkill,     // 指揮官技能
    Back,               // 返回上一步
    EndTurn,            // 回合結束
    ResetAll,           // 清空規劃
    CancelSingleAction  // 取消單一行動 (由ActionSlotUI的取消按鈕觸發)
}

// 回合管理器的宏觀狀態
public enum BattleState
{
    Setup,              // 戰鬥準備階段
    PlayerPlanning,     // 玩家規劃階段 (宏觀狀態)
    EnemyTurn,          // 敵人回合
    ActionExecution,    // 行動執行階段
    Won,                // 戰鬥勝利
    Lost                // 戰鬥失敗
}

// 玩家規劃階段的微觀子狀態 (用於TurnManager內部)
public enum PlanningSubState
{
    None,               // 無操作，等待流程推進
    SelectingRangedUnit,// 正在等待玩家選擇行動的遠程單位
    SelectingAction,    // 正在等待玩家為已選單位選擇行動
    SelectingTarget     // 正在等待玩家為已選行動選擇目標
}
```

#### **EnemyDataSO.cs (ScriptableObject)**
敵人的靜態資料模板。

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewEnemyData", menuName = "Battle System/Enemy Data")]
public class EnemyDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string enemyID;
    public string enemyName;
    public Sprite enemyIcon;
    public GameObject enemyPrefab; // 戰鬥中使用的模型Prefab

    [Header("基礎屬性")]
    public int baseHealth;
    public int baseAttack;
    public int baseStamina;
    public int attackRange;

    [Header("技能槽位")]
    [Tooltip("輸入對應 SkillData 的技能ID")]
    public List<string> skillIDs;

    [Header("物品掉落")]
    public int goldDrop;
    // public List<ItemDropInfo> itemDrops; // 未來可擴充為物品掉落
}
```

#### **BattleEncounterSO.cs (ScriptableObject)**
定義一場戰鬥遭遇的配置。

```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class EnemyPositioning
{
    public EnemyDataSO enemyData;
    public BattleRole role; // 指定這個敵人在戰鬥中的職責
}

[CreateAssetMenu(fileName = "NewBattleEncounter", menuName = "Battle System/Battle Encounter")]
public class BattleEncounterSO : ScriptableObject
{
    [Header("敵人隊伍配置")]
    public List<EnemyPositioning> enemyTeam;

    [Header("戰鬥獎勵")]
    public int totalGoldReward;
    // public List<ItemReward> itemRewards; // 預計的物品獎勵

    // 這個方法可以在編輯器中自動計算總獎勵
    private void OnValidate()
    {
        int calculatedGold = 0;
        if (enemyTeam != null)
        {
            foreach (var enemyPos in enemyTeam)
            {
                if (enemyPos.enemyData != null)
                {
                    calculatedGold += enemyPos.enemyData.goldDrop;
                }
            }
        }
        totalGoldReward = calculatedGold;
    }
}
```

#### **ActionPlan.cs**
儲存單一行動的數據結構，不是 `MonoBehaviour`。

```csharp
// 資料容器，用於儲存一個已規劃的行動
public class ActionPlan
{
    public BattleUnit Source { get; }      // 行動發起者
    public BattleUnit Target { get; }      // 行動目標
    public ActionType Type { get; }        // 行動類型
    public int PhaseIndex { get; }        // 歸屬的行動階段 (1-4)

    public ActionPlan(BattleUnit source, BattleUnit target, ActionType type, int phaseIndex)
    {
        Source = source;
        Target = target;
        Type = type;
        PhaseIndex = phaseIndex;
    }
}
```

#### **UnitStateSnapshot.cs(狀態快照的容器)**
一個簡單的類或結構來儲存一個單位在某個時間點的狀態。

```csharp
public class UnitStateSnapshot
{
    public BattleUnit Unit { get; }
    public int Stamina { get; }
    // 未來可以擴展，例如記錄當時的 Buff/Debuff
    // public List<StatusEffect> StatusEffects { get; } 

    public UnitStateSnapshot(BattleUnit unit)
    {
        Unit = unit;
        Stamina = unit.CurrentStamina;
        // StatusEffects = new List<StatusEffect>(unit.ActiveStatusEffects);
    }
}
```

---

### **2. Prefab 相關腳本**

#### **BattleUnit.cs**
附加在角色/敵人 Prefab 上的核心組件。

```csharp
using UnityEngine;
using UnityEngine.Events;

public class BattleUnit : MonoBehaviour
{
    // 靜態資料
    public MemberDataSO MemberData { get; private set; }
    public EnemyDataSO EnemyData { get; private set; }

    // 實例資料
    public MemberInstance MemberInstance { get; private set; }

    // 戰鬥相關屬性
    public BattleRole Role { get; private set; }
    public bool IsPlayerTeam { get; private set; }
    public string UnitName { get; private set; }
    public int MaxHP { get; private set; }
    public int CurrentHP { get; private set; }
    public int CurrentAttack { get; private set; }
    public int MaxStamina { get; private set; }
    public int CurrentStamina { get; private set; }
    public bool IsDead { get; private set; } = false;

    // 狀態
    private bool isDefending = false;

    [Header("元件連結")]
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private HealthUI healthUI;
    [SerializeField] private GameObject selectionHighlight; // 用於高亮顯示的物件

    public UnityAction<BattleUnit> OnUnitClicked;

    // 為玩家單位初始化
    public void Setup(MemberInstance instance, BattleRole role)
    {
        MemberInstance = instance;
        MemberData = instance.BaseData;
        UnitName = MemberData.memberName;
        Role = role;
        IsPlayerTeam = true;
        
        MaxHP = instance.MaxHP;
        CurrentHP = instance.currentHP; // 載入戰鬥前的血量
        CurrentAttack = instance.CurrentAttack;
        MaxStamina = instance.MaxStamina;
        CurrentStamina = instance.MaxStamina; // 戰鬥開始時體力全滿
        if (spriteRenderer != null)
        {
            spriteRenderer.sprite = MemberData.memberIcon;
        }

        Debug.Log($"[BattleUnit] 成功設置玩家單位: {UnitName}, HP: {CurrentHP}/{MaxHP}", this.gameObject);
    }

    // 為敵人單位初始化
    public void Setup(EnemyDataSO data, BattleRole role)
    {
        EnemyData = data;
        UnitName = EnemyData.enemyName;
        Role = role;
        IsPlayerTeam = false;
        
        MaxHP = data.baseHealth;
        CurrentHP = data.baseHealth;
        CurrentAttack = data.baseAttack;
        MaxStamina = data.baseStamina;
        CurrentStamina = data.baseStamina;
        if (spriteRenderer != null)
        {
            spriteRenderer.sprite = EnemyData.enemyIcon;
        }

        Debug.Log($"[BattleUnit] 成功設置敵人單位: {UnitName}, HP: {CurrentHP}/{MaxHP}", this.gameObject);
    }
    
    public void TakeDamage(int damage)
    {
        if (IsDead) return;

        if (isDefending)
        {
            damage /= 2;
        }

        CurrentHP -= damage;
        BattleLog.Instance.AddLog($"{UnitName} 受到 {damage} 點傷害。");

        if (CurrentHP <= 0)
        {
            CurrentHP = 0;
            Die();
        }
    }

    public void SetStaminaToMax()
    {
        CurrentStamina = MaxStamina;
    }

    public void RestoreStamina(int amount)
    {
        CurrentStamina += amount;
        if (CurrentStamina > MaxStamina)
        {
            CurrentStamina = MaxStamina;
        }
    }

    public void SetStamina(int value)
    {
        int oldStamina = this.CurrentStamina;

        CurrentStamina = value;
        // 進行邊界檢查，確保不會超過最大值或低於0
        if (CurrentStamina > MaxStamina)
        {
            CurrentStamina = MaxStamina;
        }
        if (CurrentStamina < 0)
        {
            CurrentStamina = 0;
        }
    }

    public void ConsumeStamina(int amount)
    {
        CurrentStamina -= amount;
        if (CurrentStamina < 0)
        {
            CurrentStamina = 0;
        }
    }

    private void Die()
    {
        IsDead = true;
        gameObject.SetActive(false); // 暫時先隱藏
        BattleLog.Instance.AddLog($"{UnitName} 已陣亡！");
    }

    // 處理點擊事件
    private void OnMouseDown()
    {
        Debug.Log("我被點擊了");
        OnUnitClicked?.Invoke(this);
    }
    
    public void SetHighlight(bool state)
    {
        if (selectionHighlight != null)
        {
            selectionHighlight.SetActive(state);
        }
    }

    public void SetDefenseState(bool defending)
    {
        isDefending = defending;
    }

    public void ChangeRole(BattleRole newRole)
    {
        this.Role = newRole;
        BattleLog.Instance.AddLog($"{UnitName} 的職責已變更為 {newRole}！");
    }
}
```

#### **ActionButtonUI.cs**
萬用按鈕的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionButtonUI : MonoBehaviour
{
    [SerializeField] private Button button;
    [SerializeField] private TextMeshProUGUI buttonText;
    
    private ActionType actionType;
    
    // 現在由 BattleUIManager 直接傳入 ActionType
    public void Setup(ActionType type, System.Action<ActionType> onClickCallback)
    {
        actionType = type;
        buttonText.text = GetActionName(type); // 根據類型設置文字
        
        button.onClick.RemoveAllListeners();
        button.onClick.AddListener(() => onClickCallback(actionType));
    }
    
    public void SetInteractable(bool interactable)
    {
        button.interactable = interactable;
    }

    // 輔助方法，將 Enum 轉為繁體中文名稱
    private string GetActionName(ActionType type)
    {
        switch (type)
        {
            case ActionType.Attack: return "攻擊";
            case ActionType.Defend: return "防禦";
            case ActionType.Rest: return "休息";
            case ActionType.Skill: return "技能";
            case ActionType.Item: return "道具";
            case ActionType.Exchange: return "交換";
            case ActionType.Skip: return "跳過";
            default: return type.ToString();
        }
    }
}
```

#### **ActionSlotUI.cs**
單一行動格的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionSlotUI : MonoBehaviour
{
    [Header("內容UI")]
    [SerializeField] private Image icon;
    [SerializeField] private TextMeshProUGUI actionText;

    [Header("狀態物件")]
    [SerializeField] private GameObject emptyStateObject;
    [SerializeField] private GameObject filledStateObject;

    [Header("互動元件")]
    [SerializeField] private Button cancelButton;

    private ActionPlan currentPlan;

    // 簡化 Setup，因為我們不再需要點擊選擇格子的功能
    public void Setup(System.Action<ActionPlan> onCancelClicked)
    {
        cancelButton.onClick.RemoveAllListeners();
        cancelButton.onClick.AddListener(() =>
        {
            if (currentPlan != null)
            {
                onCancelClicked(currentPlan);
            }
        });
    }

    public void UpdateView(ActionPlan plan)
    {
        currentPlan = plan;
        if (plan == null)
        {
            emptyStateObject.SetActive(true);
            filledStateObject.SetActive(false);
        }
        else
        {
            emptyStateObject.SetActive(false);
            filledStateObject.SetActive(true);
            
            if (plan.Source != null)
            {
                if (plan.Source.MemberData != null) icon.sprite = plan.Source.MemberData.memberIcon;
                else if (plan.Source.EnemyData != null) icon.sprite = plan.Source.EnemyData.enemyIcon;
                
                actionText.text = $"{plan.Source.UnitName[0]} > {GetActionName(plan.Type)}";
            }
            else
            {
                actionText.text = "錯誤";
            }
        }
    }

    private string GetActionName(ActionType type)
    {
        switch (type)
        {
            case ActionType.Attack: return "攻擊";
            case ActionType.Defend: return "防禦";
            case ActionType.Rest: return "休息";
            case ActionType.Skill: return "技能";
            case ActionType.Item: return "道具";
            case ActionType.Exchange: return "交換";
            case ActionType.Skip: return "跳過";
            default: return type.ToString();
        }
    }
}
```

#### **HealthUI.cs**
掛在 `BattleUnit` 上的血條 UI。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HealthUI : MonoBehaviour
{
    [SerializeField] private BattleUnit targetUnit;
    [SerializeField] private Slider healthSlider;
    [SerializeField] private TextMeshProUGUI healthText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if(targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (healthSlider != null)
        {
            healthSlider.minValue = 0;
            healthSlider.maxValue = 1;
        }
    }

    void Update()
    {
        if (targetUnit != null && !targetUnit.IsDead)
        {
            // 更新 Slider 的值 (0 到 1 之間)
            healthSlider.value = (float)targetUnit.CurrentHP / targetUnit.MaxHP;
            
            // 更新文字顯示
            if (healthText != null)
            {
                healthText.text = $"{targetUnit.CurrentHP} / {targetUnit.MaxHP}";
            }
            
            // 使血條始終面向攝影機
            transform.rotation = mainCamera.transform.rotation; 
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}
```

#### **BattleTrigger.cs**
戰鬥觸發器。

```csharp
using UnityEngine;

public class BattleTrigger : MonoBehaviour
{
    [SerializeField] private BattleEncounterSO battleEncounter;

    private void OnTriggerEnter(Collider other)
    {
        // 假設玩家物件帶有 "Player" 標籤
        if (other.CompareTag("Player"))
        {
            // 禁用觸發器避免重複觸發
            GetComponent<Collider>().enabled = false;
            
            // 通知 GameManager 啟動戰鬥
            GameManager.Instance.StartBattle(battleEncounter);
        }
    }
}
```

---

### **3. UI 管理腳本**

#### **ActionPanelUI.cs**
行動按鈕面板。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionPanelUI : MonoBehaviour
{
    [SerializeField] private GameObject panel;
    [SerializeField] private Transform buttonContainer;
    [SerializeField] private ActionButtonUI buttonPrefab;
    
    private List<ActionButtonUI> spawnedButtons = new List<ActionButtonUI>();

    public void ShowPanel(BattleUnit unit, System.Action<ActionType> onActionSelected)
    {
        ClearButtons();
        
        // 根據角色職責決定可用的行動列表
        List<ActionType> availableActions = GetActionsForRole(unit.Role);

        foreach (var actionType in availableActions)
        {
            ActionButtonUI newButton = Instantiate(buttonPrefab, buttonContainer);
            newButton.Setup(actionType, onActionSelected);
            spawnedButtons.Add(newButton);
        }
        
        panel.SetActive(true);
    }
    
    // 根據角色職責返回一個行動列表
    private List<ActionType> GetActionsForRole(BattleRole role)
    {
        switch (role)
        {
            case BattleRole.Vanguard:
            case BattleRole.Ranged1:
            case BattleRole.Ranged2:
                // 假設所有戰鬥單位都有這些基礎行動
                return new List<ActionType>
                {
                    ActionType.Attack,
                    ActionType.Defend,
                    ActionType.Rest,
                    ActionType.Skip // 必須加入跳過選項
                };
            // case BattleRole.Support: // 後勤的行動可以在這裡定義
            default:
                return new List<ActionType>();
        }
    }

    public void UpdateButtonStates(BattleUnit unit, BattleRules rules)
    {
        foreach (var btnUI in spawnedButtons)
        {
            // 簡化：這裡可以加入更複雜的規則，例如體力檢查
            // bool isInteractable = rules.CanPerformAction(unit, btnUI.ActionType);
            // btnUI.SetInteractable(isInteractable);
        }
    }

    public void HidePanel()
    {
        panel.SetActive(false);
        ClearButtons();
    }
    
    private void ClearButtons()
    {
        foreach (var btn in spawnedButtons)
        {
            Destroy(btn.gameObject);
        }
        spawnedButtons.Clear();
    }
}
```

#### **ActionSlotPanelUI.cs**
戰術規劃板。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionSlotPanelUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject panel;
    [SerializeField] private List<ActionSlotUI> vanguardSlots;
    [SerializeField] private List<ActionSlotUI> rangedSlots;
    [SerializeField] private List<GameObject> highlightObjects; // 8個高亮物件

    public void Initialize(System.Action<UICommandType, ActionPlan> onCommand)
    {
        // 為所有行動格設置取消回調
        foreach(var slot in vanguardSlots)
        {
            // 現在 Setup 只需一個參數，傳遞一個 Lambda 來呼叫 onCommand
            slot.Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
        foreach(var slot in rangedSlots)
        {
            // 同上
            slot.Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
    }
    
    public void UpdatePanel(TurnActionPlanner planner)
    {
        for(int i = 0; i < vanguardSlots.Count; i++)
        {
            int phaseIndex = i + 1;
            ActionPlan plan = planner.GetAction(phaseIndex, true, BattleRole.Vanguard);
            vanguardSlots[i].UpdateView(plan);
        }
        
        for(int i = 0; i < rangedSlots.Count; i++)
        {
            int phaseIndex = i + 1;
            ActionPlan plan = planner.GetRangedAction(phaseIndex, true);
            rangedSlots[i].UpdateView(plan);
        }
        
        panel.SetActive(true);
    }

    public void SetPlanningHighlight(int stepIndex) // stepIndex 是 0-7
    {
        for (int i = 0; i < highlightObjects.Count; i++)
        {
            if (highlightObjects[i] != null)
            {
                highlightObjects[i].SetActive(i == stepIndex);
            }
        }
    }
    
    public void HidePanel()
    {
        panel.SetActive(false);
    }
}
```

#### **BattleEndUI.cs**
戰鬥結算畫面。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BattleEndUI : MonoBehaviour
{
    [SerializeField] private GameObject victoryPanel;
    [SerializeField] private GameObject defeatPanel;
    [SerializeField] private TextMeshProUGUI rewardText;
    [SerializeField] private Button exitButton;

    private void Start()
    {
        exitButton.onClick.AddListener(OnExitButtonClicked);
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(false);
    }

    public void ShowVictory(int goldReward)
    {
        victoryPanel.SetActive(true);
        defeatPanel.SetActive(false);
        rewardText.text = $"獲得金幣: {goldReward}";
    }

    public void ShowDefeat()
    {
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(true);
    }

    private void OnExitButtonClicked()
    {
        // 通知 GameManager 返回主場景
        GameManager.Instance.EndBattle();
    }
}
```

#### **BattleLog.cs**
戰鬥日誌。

```csharp
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class BattleLog : MonoBehaviour
{
    public static BattleLog Instance { get; private set; }
    
    [SerializeField] private TextMeshProUGUI logText;
    [SerializeField] private ScrollRect scrollRect;
    private Queue<string> logMessages = new Queue<string>();
    private int maxMessages = 20;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public void AddLog(string message)
    {
        if (logMessages.Count >= maxMessages)
        {
            logMessages.Dequeue();
        }
        logMessages.Enqueue($"[{System.DateTime.Now:HH:mm:ss}] {message}");
        
        UpdateLogText();
    }

    private void UpdateLogText()
    {
        logText.text = string.Join("\n", logMessages);
        
        // 自動滾動到底部
        Canvas.ForceUpdateCanvases();
        scrollRect.verticalNormalizedPosition = 0f;
    }
}
```

#### **BattleUI.cs**
戰鬥場景 UI 總集。

```csharp
using UnityEngine;
using UnityEngine.UI;

public class BattleUI : MonoBehaviour
{
    [SerializeField] private Button endTurnButton;
    [SerializeField] private Button resetButton;
    [SerializeField] private Button backButton;

    // 將回調統一為一個，使用 UICommandType 來區分
    public void Setup(System.Action<UICommandType> onCommand)
    {
        endTurnButton.onClick.RemoveAllListeners();
        endTurnButton.onClick.AddListener(() => onCommand(UICommandType.EndTurn));
        
        resetButton.onClick.RemoveAllListeners();
        resetButton.onClick.AddListener(() => onCommand(UICommandType.ResetAll));
        
        backButton.onClick.RemoveAllListeners();
        backButton.onClick.AddListener(() => onCommand(UICommandType.Back));
    }
    
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        endTurnButton.interactable = interactable;
    }
    
    public void SetBackButtonVisible(bool visible)
    {
        backButton.gameObject.SetActive(visible);
    }

    public void SetResetButtonVisible(bool visible)
    {
        resetButton.gameObject.SetActive(visible);
    }
}
```

---

### **4. 管理器 (Managers)**

#### **TurnManager.cs**
回合與邏輯管理器，戰鬥的核心。

```csharp
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    // 宏觀狀態
    public BattleState CurrentState { get; private set; }

    // 系統引用
    private BattleManager battleManager;
    private BattleUIManager uiManager;
    private TurnActionPlanner actionPlanner;
    private BattleRules battleRules;
    private BattleActions battleActions;
    private EnemyBattleAI enemyAI;
    private CharacterStateRule characterStateRule;

    // 引導式規劃的內部狀態
    private int currentPlanningStepIndex; // 0-7, 代表8個規劃步驟
    private PlanningSubState currentSubState;
    private BattleUnit selectedUnitForAction;
    private ActionType selectedActionType;

    public void Initialize(BattleManager bm, BattleUIManager uim, TurnActionPlanner ap, BattleRules br, BattleActions ba, EnemyBattleAI eai, CharacterStateRule csr)
    {
        battleManager = bm;
        uiManager = uim;
        actionPlanner = ap;
        battleRules = br;
        battleActions = ba;
        enemyAI = eai;
        characterStateRule = csr;
    }

    public void StartBattle()
    {
        BattleLog.Instance.AddLog("戰鬥開始！");
        SetState(BattleState.PlayerPlanning);
    }

    private void SetState(BattleState newState)
    {
        if (CurrentState == newState) return;
        CurrentState = newState;
        StartCoroutine(OnEnterState(newState));
    }

    private IEnumerator OnEnterState(BattleState state)
    {
        switch (state)
        {
            case BattleState.PlayerPlanning:
                BattleLog.Instance.AddLog("==== 新回合：玩家規劃階段 ====");
                actionPlanner.PrepareForNewTurn();
                characterStateRule.RestoreAllUnitStamina(battleManager.PlayerUnits, battleManager.EnemyUnits);
                characterStateRule.RecordTurnStartStates(battleManager.PlayerUnits, battleManager.EnemyUnits);
                uiManager.EnterPlayerPlanningState(actionPlanner);
                StartCoroutine(StartGuidedPlanning());
                break;

            case BattleState.EnemyTurn:
                BattleLog.Instance.AddLog("==== 敵人回合 ====");
                uiManager.EnterEnemyTurnState();
                enemyAI.PlanActions(battleManager.EnemyUnits, battleManager.PlayerUnits, actionPlanner, battleRules);
                yield return new WaitForSeconds(1f); // 讓玩家看到日誌
                SetState(BattleState.ActionExecution);
                break;

            case BattleState.ActionExecution:
                BattleLog.Instance.AddLog("==== 行動執行階段 ====");
                uiManager.EnterActionExecutionState();
                StartCoroutine(ExecuteActions());
                break;

            case BattleState.Won:
                BattleLog.Instance.AddLog("★★ 戰鬥勝利 ★★");
                uiManager.ShowVictoryScreen(battleManager.EncounterData.totalGoldReward);
                break;

            case BattleState.Lost:
                BattleLog.Instance.AddLog("戰鬥失敗...");
                uiManager.ShowDefeatScreen();
                break;
        }
    }
    
    // --- 引導式規劃核心邏輯 ---
    private IEnumerator StartGuidedPlanning()
    {
        currentPlanningStepIndex = 0;
        AdvancePlanningStep();
        yield return null;
    }

    private void AdvancePlanningStep()
    {
        // 規劃完成
        if (currentPlanningStepIndex >= 8)
        {
            currentSubState = PlanningSubState.None;
            BattleLog.Instance.AddLog("所有行動已規劃完畢。請點擊「回合結束」。");
            uiManager.ShowPlanningFinishedState();
            return;
        }

        List<BattleUnit> eligibleActors = battleRules.GetEligibleActorsForStep(currentPlanningStepIndex, battleManager.PlayerUnits, actionPlanner);

        if (eligibleActors.Count == 0)
        {
            // 自動跳過
            BattleLog.Instance.AddLog($"步驟 {currentPlanningStepIndex + 1}: 無符合資格的單位，自動跳過。");
            currentPlanningStepIndex++;
            AdvancePlanningStep();
        }
        else if (eligibleActors.Count == 1)
        {
            // 只有一個單位，直接進入行動選擇
            selectedUnitForAction = eligibleActors[0];
            currentSubState = PlanningSubState.SelectingAction;
            uiManager.ShowActionSelectionFor(selectedUnitForAction, currentPlanningStepIndex);
        }
        else // (eligibleActors.Count > 1)，只可能發生在遠程階段
        {
            // 讓玩家選擇遠程單位
            currentSubState = PlanningSubState.SelectingRangedUnit;
            uiManager.ShowRangedUnitSelection(eligibleActors, currentPlanningStepIndex);
        }
    }

    // --- 玩家輸入處理 ---

    // 當玩家在需要選擇單位時，點擊了一個單位
    public void OnUnitClicked(BattleUnit unit)
    {
        if (currentSubState == PlanningSubState.SelectingRangedUnit)
        {
            // 選擇遠程單位
            selectedUnitForAction = unit;
            currentSubState = PlanningSubState.SelectingAction;
            uiManager.ShowActionSelectionFor(selectedUnitForAction, currentPlanningStepIndex);
        }
        else if (currentSubState == PlanningSubState.SelectingTarget)
        {
            // 選擇目標
            if (battleRules.GetValidTargets(selectedUnitForAction, battleManager.EnemyUnits).Contains(unit))
            {
                FinalizeActionPlan(unit);
            }
        }
    }

    // 當玩家點擊了行動按鈕
    public void OnActionSelected(ActionType type)
    {
        if (currentSubState != PlanningSubState.SelectingAction) return;

        selectedActionType = type;
        
        // 處理體力消耗與跳過邏輯
        if (type == ActionType.Attack)
        {
            int cost = battleActions.GetAttackStaminaCost();
            if (selectedUnitForAction.CurrentStamina >= cost)
            {
                characterStateRule.ConsumeStamina(selectedUnitForAction, cost);
                currentSubState = PlanningSubState.SelectingTarget;
                var validTargets = battleRules.GetValidTargets(selectedUnitForAction, battleManager.EnemyUnits);
                uiManager.ShowTargetSelection(validTargets);
            }
            else
            {
                BattleLog.Instance.AddLog($"{selectedUnitForAction.UnitName} 體力不足，無法攻擊！");
                // 體力不足，停留在原地讓玩家重選
            }
        }
        else
        {
            // 其他行動（防禦、休息、跳過）不需要目標
            FinalizeActionPlan(null); // 目標為null
        }
    }

    // 統一的UI指令處理
    public void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        switch (command)
        {
            case UICommandType.EndTurn:
                if (CurrentState == BattleState.PlayerPlanning) SetState(BattleState.EnemyTurn);
                break;
                
            case UICommandType.ResetAll:
                if (CurrentState != BattleState.PlayerPlanning) return;
                actionPlanner.ClearPlayerPlans();
                characterStateRule.RestoreAllUnitsFromSnapshot();
                uiManager.EnterPlayerPlanningState(actionPlanner); // 刷新UI
                StartCoroutine(StartGuidedPlanning()); // 重新開始
                BattleLog.Instance.AddLog("已重置所有規劃。");
                break;

            case UICommandType.Back:
                HandleBackCommand();
                break;
                
            case UICommandType.CancelSingleAction:
                if (CurrentState != BattleState.PlayerPlanning || planData == null) return;
                actionPlanner.RemovePlan(planData);
                characterStateRule.RefundStaminaForPlan(planData, battleActions.GetAttackStaminaCost());
                uiManager.UpdateActionSlots(actionPlanner);
                BattleLog.Instance.AddLog($"已取消行動: {planData.Source.UnitName} -> {planData.Type}");
                break;
        }
    }

    private void HandleBackCommand()
    {
        switch (currentSubState)
        {
            case PlanningSubState.SelectingTarget:
                // 從選目標返回選行動
                characterStateRule.RefundStaminaForPlan(
                    new ActionPlan(selectedUnitForAction, null, selectedActionType, 0), 
                    battleActions.GetAttackStaminaCost()
                );
                currentSubState = PlanningSubState.SelectingAction;
                uiManager.ShowActionSelectionFor(selectedUnitForAction, currentPlanningStepIndex);
                break;

            case PlanningSubState.SelectingAction:
                // 從選行動返回選單位 (僅當有多個遠程單位可選時)
                bool isRangedStep = currentPlanningStepIndex % 2 != 0;
                if (isRangedStep)
                {
                    List<BattleUnit> eligibleActors = battleRules.GetEligibleActorsForStep(currentPlanningStepIndex, battleManager.PlayerUnits, actionPlanner);
                    if (eligibleActors.Count > 1)
                    {
                        currentSubState = PlanningSubState.SelectingRangedUnit;
                        uiManager.ShowRangedUnitSelection(eligibleActors, currentPlanningStepIndex);
                    }
                }
                break;
        }
    }

    private void FinalizeActionPlan(BattleUnit target)
    {
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        ActionPlan newPlan = new ActionPlan(selectedUnitForAction, target, selectedActionType, phaseIndex);
        actionPlanner.AddPlan(newPlan);
        
        // 重置臨時數據
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;

        uiManager.UpdateActionSlots(actionPlanner);

        // 推進到下一步
        currentPlanningStepIndex++;
        AdvancePlanningStep();
    }

    // --- 行動執行 ---
    private IEnumerator ExecuteActions()
    {
        for (int i = 1; i <= 4; i++)
        {
            yield return StartCoroutine(ExecuteSingleAction(i, true, BattleRole.Vanguard));
            if (CheckBattleEnd()) yield break;
            yield return StartCoroutine(ExecuteSingleAction(i, false, BattleRole.Vanguard));
            if (CheckBattleEnd()) yield break;
            yield return StartCoroutine(ExecuteRangedAction(i, true));
            if (CheckBattleEnd()) yield break;
            yield return StartCoroutine(ExecuteRangedAction(i, false));
            if (CheckBattleEnd()) yield break;
        }
        if (CurrentState == BattleState.ActionExecution)
        {
            SetState(BattleState.PlayerPlanning); // 開始新回合
        }
    }
    
    // 以下執行邏輯與之前版本相同...
    private IEnumerator ExecuteSingleAction(int phase, bool isPlayer, BattleRole role)
    {
        ActionPlan plan = actionPlanner.GetAction(phase, isPlayer, role);
        if (plan != null && !plan.Source.IsDead)
        {
            battleActions.Execute(plan);
            yield return new WaitForSeconds(1.0f);
        }
    }
    private IEnumerator ExecuteRangedAction(int phase, bool isPlayer)
    {
        ActionPlan plan = actionPlanner.GetRangedAction(phase, isPlayer);
        if (plan != null && !plan.Source.IsDead)
        {
            battleActions.Execute(plan);
            yield return new WaitForSeconds(1.0f);
        }
    }
    private bool CheckBattleEnd()
    {
        actionPlanner.RemovePlansFromDeadUnits(battleManager.PlayerUnits, battleManager.EnemyUnits);
        battleManager.HandleTeamPromotions();
        if (battleRules.IsVictory(battleManager.EnemyUnits)) { SetState(BattleState.Won); return true; }
        if (battleRules.IsDefeat(battleManager.PlayerUnits)) { SetState(BattleState.Lost); return true; }
        return false;
    }
}
```

#### **BattleManager.cs**
戰鬥場景總控制器。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattleManager : MonoBehaviour
{
    public static BattleManager Instance { get; private set; }
    public BattleEncounterSO EncounterData { get; private set; }
    public List<BattleUnit> PlayerUnits { get; private set; }
    public List<BattleUnit> EnemyUnits { get; private set; }

    [Header("場景物件")]
    [SerializeField] private Transform[] playerSpawns;
    [SerializeField] private Transform[] enemySpawns;

    [Header("系統模組")]
    [SerializeField] private TurnManager turnManager;
    [SerializeField] private BattleUIManager uiManager;
    [SerializeField] private BattleRules battleRules;
    [SerializeField] private BattleActions battleActions;
    [SerializeField] private EnemyBattleAI enemyAI;
    [SerializeField] private CharacterStateRule characterStateRule;
    
    private TurnActionPlanner actionPlanner;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    void Start()
    {
        EncounterData = GameManager.Instance.CurrentEncounter;
        if (EncounterData == null)
        {
            Debug.LogError("沒有傳入戰鬥遭遇數據！");
            return;
        }

        InitializeSystems();
        SpawnUnits();
        
        turnManager.StartBattle();
    }

    private void InitializeSystems()
    {
        actionPlanner = new TurnActionPlanner();
        PlayerUnits = new List<BattleUnit>();
        EnemyUnits = new List<BattleUnit>();

        turnManager.Initialize(this, uiManager, actionPlanner, battleRules, battleActions, enemyAI, characterStateRule);
        
        // 修正此處的呼叫，只傳遞一個參數
        uiManager.Initialize(turnManager);
    }
    
    private void SpawnUnits()
    {
        // 玩家單位
        var battleParty = PartyManager.Instance.BattleParty;
        for (int i = 0; i < battleParty.Count; i++)
        {
            if (i >= playerSpawns.Length) break;
            BattleRole role = (BattleRole)i;
            MemberDataSO memberData = battleParty[i].BaseData;
            if (memberData.unitPrefab == null) continue;

            GameObject unitGO = Instantiate(memberData.unitPrefab, playerSpawns[i].position, playerSpawns[i].rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(battleParty[i], role);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            PlayerUnits.Add(unit);
        }

        // 敵人單位
        foreach (var enemyPos in EncounterData.enemyTeam)
        {
            int roleIndex = (int)enemyPos.role;
            if (roleIndex >= enemySpawns.Length) continue;
            
            GameObject unitGO = Instantiate(enemyPos.enemyData.enemyPrefab, enemySpawns[roleIndex].position, enemySpawns[roleIndex].rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(enemyPos.enemyData, enemyPos.role);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            EnemyUnits.Add(unit);
        }
    }

    // HandleTeamPromotions 和 IsBattleWon 方法保持不變...
    public void HandleTeamPromotions()
    {
        CheckAndPromote(PlayerUnits, true);
        CheckAndPromote(EnemyUnits, false);
    }
    private void CheckAndPromote(List<BattleUnit> team, bool isPlayerTeam)
    {
        BattleUnit vanguard = team.FirstOrDefault(u => u.Role == BattleRole.Vanguard);
        if (vanguard == null || vanguard.IsDead)
        {
            BattleUnit ranged1 = team.FirstOrDefault(u => u.Role == BattleRole.Ranged1 && !u.IsDead);
            if (ranged1 != null) { PromoteUnit(ranged1, BattleRole.Vanguard, isPlayerTeam); return; }
            BattleUnit ranged2 = team.FirstOrDefault(u => u.Role == BattleRole.Ranged2 && !u.IsDead);
            if (ranged2 != null) { PromoteUnit(ranged2, BattleRole.Vanguard, isPlayerTeam); return; }
        }
    }
    private void PromoteUnit(BattleUnit unitToPromote, BattleRole newRole, bool isPlayerTeam)
    {
        int roleIndex = (int)newRole;
        Transform targetSpawn = isPlayerTeam ? playerSpawns[roleIndex] : enemySpawns[roleIndex];
        unitToPromote.transform.position = targetSpawn.position;
        unitToPromote.ChangeRole(newRole);

    }
    public bool IsBattleWon()
    {
        return turnManager != null && turnManager.CurrentState == BattleState.Won;
    }
}
```

#### **BattleUIManager.cs**
UI 系統協調者。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class BattleUIManager : MonoBehaviour
{
    private TurnManager turnManager;

    [Header("UI 面板")]
    [SerializeField] private ActionPanelUI actionPanel;
    [SerializeField] private ActionSlotPanelUI actionSlotPanel;
    [SerializeField] private BattleUI battleUI;
    [SerializeField] private BattleEndUI battleEndUI;
    
    public void Initialize(TurnManager tm)
    {
        turnManager = tm;
        // 使用 Lambda 表達式來匹配 Setup 的參數需求
        battleUI.Setup(cmd => OnUICommand(cmd, null));
        actionSlotPanel.Initialize((cmd, plan) => OnUICommand(cmd, plan));
    }

    // --- 狀態進入時的 UI 設置 ---

    public void EnterPlayerPlanningState(TurnActionPlanner planner)
    {
        HideAllActionPanels();
        actionSlotPanel.UpdatePanel(planner);
        actionSlotPanel.gameObject.SetActive(true);
        battleUI.SetEndTurnButtonInteractable(false); // 規劃完成前不可結束
        battleUI.SetResetButtonVisible(true);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterEnemyTurnState()
    {
        HideAllActionPanels();
        battleUI.SetEndTurnButtonInteractable(false);
        battleUI.SetResetButtonVisible(false);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterActionExecutionState()
    {
        HideAllActionPanels();
    }
    
    // --- 引導式規劃的 UI 顯示 ---

    public void ShowRangedUnitSelection(List<BattleUnit> units, int stepIndex)
    {
        HideAllActionPanels();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        units.ForEach(u => u.SetHighlight(true));
        battleUI.SetBackButtonVisible(false); // 選擇單位是第一步，不能返回
        BattleLog.Instance.AddLog("請選擇一位遠程單位來規劃行動。");
    }

    public void ShowActionSelectionFor(BattleUnit unit, int stepIndex)
    {
        DeselectAllHighlights();
        unit.SetHighlight(true); // 讓玩家知道在為誰規劃
        actionPanel.ShowPanel(unit, turnManager.OnActionSelected);
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        battleUI.SetBackButtonVisible(true);
    }
    
    public void ShowTargetSelection(List<BattleUnit> validTargets)
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        validTargets.ForEach(t => t.SetHighlight(true));
        BattleLog.Instance.AddLog("請選擇一個目標。");
    }

    public void ShowPlanningFinishedState()
    {
        HideAllActionPanels();
        actionSlotPanel.SetPlanningHighlight(-1); // 關閉所有高亮
        battleUI.SetEndTurnButtonInteractable(true);
        battleUI.SetBackButtonVisible(false);
    }
    
    public void UpdateActionSlots(TurnActionPlanner planner)
    {
        actionSlotPanel.UpdatePanel(planner);
    }

    // --- 其他 UI 控制 ---

    public void ShowVictoryScreen(int gold) { battleEndUI.ShowVictory(gold); }
    public void ShowDefeatScreen() { battleEndUI.ShowDefeat(); }
    
    private void HideAllActionPanels()
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(-1);
    }

    private void DeselectAllHighlights()
    {
        if (BattleManager.Instance == null) return;
        foreach(var unit in BattleManager.Instance.PlayerUnits) unit.SetHighlight(false);
        foreach(var unit in BattleManager.Instance.EnemyUnits) unit.SetHighlight(false);
    }

    // --- 輸入中繼 ---
    private void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        turnManager.OnUICommand(command, planData);
    }
}

#### **GameManager.cs**
遊戲狀態管理器。

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Linq;
using System.Collections.Generic;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    
    public BattleEncounterSO CurrentEncounter { get; private set; }
    
    private string mainSceneName = "Title"; // 假設您的非戰鬥場景名
    private string battleSceneName = "BattleScene"; // 假設您的戰鬥場景名

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    public void StartBattle(BattleEncounterSO encounter)
    {
        CurrentEncounter = encounter;
        SceneManager.LoadScene(battleSceneName);
    }

    public void EndBattle()
    {
        ProcessBattleResults();
        UpdatePartyStatusAfterBattle();
        // 可以在這裡處理獎勵發放等邏輯
        CurrentEncounter = null;
        SceneManager.LoadScene(mainSceneName);
    }

    private void UpdatePartyStatusAfterBattle()
    {
        // 檢查 BattleManager 和 PartyManager 是否存在，避免在編輯器中單獨運行場景時出錯
        if (BattleManager.Instance == null || PartyManager.Instance == null)
        {
            Debug.LogWarning("無法更新隊伍狀態，因為 BattleManager 或 PartyManager 不存在。");
            return;
        }

        // 遍歷所有參與戰鬥的玩家單位
        foreach (var unit in BattleManager.Instance.PlayerUnits)
        {
            // 在 PartyManager 的總成員列表中，找到與之對應的那個實例
            // 我們使用獨一無二的 instanceID 來進行匹配
            MemberInstance instanceToUpdate = PartyManager.Instance.AllMembers.FirstOrDefault(
                m => m.instanceID == unit.MemberInstance.instanceID
            );

            if (instanceToUpdate != null)
            {
                // 將戰鬥結束時的血量寫回實例
                instanceToUpdate.currentHP = unit.CurrentHP;
                Debug.Log($"已更新成員 [{instanceToUpdate.BaseData.memberName}] 的血量為: {instanceToUpdate.currentHP}");
            }
        }
        // (可選) 在這裡也可以觸發一次存檔
        // PartyManager.Instance.SaveParty();
    }

    private void ProcessBattleResults()
    {
        if (BattleManager.Instance == null) return;
        
        // 檢查戰鬥是否勝利 (失敗則不處理獎勵和進度)
        if (BattleManager.Instance.IsBattleWon())
        {
            // 處理金錢和經驗值獎勵
            var encounterData = BattleManager.Instance.EncounterData;
            int totalGold = 0;
            // int totalExp = 0; // 暫時註解掉未使用的變數

            foreach(var enemyUnit in BattleManager.Instance.EnemyUnits)
            {
                if(enemyUnit.EnemyData != null)
                {
                    totalGold += enemyUnit.EnemyData.goldDrop;
                    // totalExp += enemyUnit.EnemyData.expDrop; // 這行也保持註解
                }
            }

            if(PlayerState.Instance != null)
            {
                PlayerState.Instance.AddMoney(totalGold);
                // PlayerState.Instance.GainExperience(totalExp); // 這行也保持註解
                Debug.Log($"戰鬥勝利！獲得金幣: {totalGold}");
            }

            // 處理擊殺任務進度
            if (QuestManager.Instance != null)
            {
                foreach (var enemyUnit in BattleManager.Instance.EnemyUnits)
                {
                    // 確保只計算被擊殺的敵人
                    if (enemyUnit.IsDead && enemyUnit.EnemyData != null)
                    {
                        string enemyID = enemyUnit.EnemyData.enemyID;
                        QuestManager.Instance.AdvanceObjective(enemyID, QuestObjectiveType.Kill, 1);
                        Debug.Log($"向任務系統報告擊殺: {enemyID}");
                    }
                }
            }
        }
    }
}
```

---

### **5. 戰鬥邏輯**

#### **BattleRules.cs**
戰鬥法典。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "BattleRules", menuName = "Battle System/Battle Rules")]
public class BattleRules : ScriptableObject
{
    public List<BattleUnit> GetEligibleActorsForStep(int stepIndex, List<BattleUnit> playerUnits, TurnActionPlanner planner)
    {
        var eligibleActors = new List<BattleUnit>();
        bool isVanguardStep = stepIndex % 2 == 0;

        if (isVanguardStep)
        {
            BattleUnit vanguard = playerUnits.FirstOrDefault(u => u.Role == BattleRole.Vanguard);
            if (CanUnitAct(vanguard, planner, 4))
            {
                eligibleActors.Add(vanguard);
            }
        }
        else
        {
            BattleUnit ranged1 = playerUnits.FirstOrDefault(u => u.Role == BattleRole.Ranged1);
            BattleUnit ranged2 = playerUnits.FirstOrDefault(u => u.Role == BattleRole.Ranged2);

            if (CanUnitAct(ranged1, planner, 2))
            {
                eligibleActors.Add(ranged1);
            }
            if (CanUnitAct(ranged2, planner, 2))
            {
                eligibleActors.Add(ranged2);
            }
        }
        return eligibleActors;
    }

    // 將此方法改為 public，讓 AI 可以存取
    public bool CanUnitAct(BattleUnit unit, TurnActionPlanner planner, int maxActions)
    {
        if (unit == null || unit.IsDead) return false;
        return planner.GetActionCountForUnit(unit) < maxActions;
    }

    public List<BattleUnit> GetValidTargets(BattleUnit attacker, List<BattleUnit> allEnemies)
    {
        var validTargets = new List<BattleUnit>();
        BattleUnit enemyVanguard = allEnemies.FirstOrDefault(u => u.Role == BattleRole.Vanguard && !u.IsDead);
        if (enemyVanguard != null)
        {
            validTargets.Add(enemyVanguard);
        }
        return validTargets;
    }

    public bool IsVictory(List<BattleUnit> enemyUnits) { return enemyUnits.All(u => u.IsDead); }
    public bool IsDefeat(List<BattleUnit> playerUnits) { return playerUnits.All(u => u.IsDead); }
}
```

#### **BattleActions.cs**
行動邏輯的執行者。

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "BattleActions", menuName = "Battle System/Battle Actions")]
public class BattleActions : ScriptableObject
{
    [Header("行動數值")]
    [SerializeField] private int attackStaminaCost = 3;
    [SerializeField] private int restStaminaRecovery = 5;

    public int GetAttackStaminaCost() { return attackStaminaCost; }
    
    public void Execute(ActionPlan plan)
    {
        if (plan.Source.IsDead) return;

        ActionType finalActionType = plan.Type;
        if (plan.Type == ActionType.Attack && (plan.Target == null || plan.Target.IsDead))
        {
            finalActionType = (plan.Source.Role == BattleRole.Vanguard) ? ActionType.Defend : ActionType.Rest;
            BattleLog.Instance.AddLog($"{plan.Source.UnitName} 的攻擊目標已消失，行動自動變更為 [{finalActionType}]！");
        }

        switch (finalActionType)
        {
            case ActionType.Attack:
                BattleLog.Instance.AddLog($"{plan.Source.UnitName} 對 {plan.Target.UnitName} 發動攻擊！");
                plan.Target.TakeDamage(plan.Source.CurrentAttack);
                break;
            case ActionType.Defend:
                plan.Source.SetDefenseState(true);
                BattleLog.Instance.AddLog($"{plan.Source.UnitName} 進入防禦姿態。");
                break;
            case ActionType.Rest:
                plan.Source.RestoreStamina(restStaminaRecovery);
                BattleLog.Instance.AddLog($"{plan.Source.UnitName} 進行休息，恢復了 {restStaminaRecovery} 點體力。");
                break;
            case ActionType.Skip:
                BattleLog.Instance.AddLog($"{plan.Source.UnitName} 選擇跳過本次行動。");
                // 不執行任何操作
                break;
        }
    }
}
```

#### **TurnActionPlanner.cs**
回合行動規劃器。

```csharp
using System.Collections.Generic;
using System.Linq;

public class TurnActionPlanner
{
    private List<ActionPlan> plannedActions = new List<ActionPlan>();

    public void AddPlan(ActionPlan plan)
    {
        plannedActions.Add(plan);
    }

    public void RemovePlan(ActionPlan planToRemove)
    {
        if (planToRemove != null)
        {
            plannedActions.Remove(planToRemove);
        }
    }

    public void ClearPlayerPlans()
    {
        var enemyPlans = plannedActions.Where(p => p.Source != null && !p.Source.IsPlayerTeam).ToList();
        plannedActions = enemyPlans;
    }

    // 將方法改名以匹配 TurnManager 的呼叫
    public void PrepareForNewTurn()
    {
        // 在清除之前，重置所有單位的防禦狀態
        foreach (var plan in plannedActions)
        {
            if (plan.Source != null && plan.Type == ActionType.Defend)
            {
                plan.Source.SetDefenseState(false);
            }
        }
        plannedActions.Clear();
    }

    public ActionPlan GetAction(int phaseIndex, bool isPlayerTeam, BattleRole role)
    {
        return plannedActions.FirstOrDefault(p =>
            p.Source != null &&
            p.PhaseIndex == phaseIndex &&
            p.Source.IsPlayerTeam == isPlayerTeam &&
            p.Source.Role == role);
    }

    public ActionPlan GetRangedAction(int phaseIndex, bool isPlayerTeam)
    {
        return plannedActions.FirstOrDefault(p =>
            p.Source != null &&
            p.PhaseIndex == phaseIndex &&
            p.Source.IsPlayerTeam == isPlayerTeam &&
            (p.Source.Role == BattleRole.Ranged1 || p.Source.Role == BattleRole.Ranged2));
    }

    public int GetActionCountForUnit(BattleUnit unit)
    {
        return plannedActions.Count(p => p.Source == unit);
    }

    public List<int> GetPlannedPhaseIndicesForUnit(BattleUnit unit)
    {
        return plannedActions.Where(p => p.Source == unit).Select(p => p.PhaseIndex).ToList();
    }

    public void RemovePlansFromDeadUnits(List<BattleUnit> playerUnits, List<BattleUnit> enemyUnits)
    {
        var allUnits = playerUnits.Concat(enemyUnits);
        var deadUnits = allUnits.Where(u => u.IsDead).ToList();
        if (deadUnits.Any())
        {
            plannedActions.RemoveAll(plan => deadUnits.Contains(plan.Source));
        }
    }
}
```
**注意**: `TurnActionPlanner` 不適合做成 ScriptableObject，因為它需要儲存每一場戰鬥的即時數據。這裡我已將其改為一個普通的類，您需要在 `BattleManager` 中 `new TurnActionPlanner()` 來創建實例。

#### **CharacterStateRule.cs**
角色狀態變化規則。

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "CharacterStateRule", menuName = "Battle System/Character State Rule")]
public class CharacterStateRule : ScriptableObject
{
    private List<UnitStateSnapshot> turnStartSnapshots = new List<UnitStateSnapshot>();

    // 在回合開始時記錄所有單位的狀態
    public void RecordTurnStartStates(List<BattleUnit> playerUnits, List<BattleUnit> enemyUnits)
    {
        turnStartSnapshots.Clear();
        foreach (var unit in playerUnits)
        {
            if (!unit.IsDead) turnStartSnapshots.Add(new UnitStateSnapshot(unit));
        }
        foreach (var unit in enemyUnits)
        {
            if (!unit.IsDead) turnStartSnapshots.Add(new UnitStateSnapshot(unit));
        }
    }

    // 當玩家點擊「清空規劃」時，從快照恢復所有單位狀態
    public void RestoreAllUnitsFromSnapshot()
    {
        foreach (var snapshot in turnStartSnapshots)
        {
            if (snapshot.Unit != null && !snapshot.Unit.IsDead)
            {
                snapshot.Unit.SetStamina(snapshot.Stamina);
            }
        }
    }

    // 為單個單位預扣體力
    public void ConsumeStamina(BattleUnit unit, int amount)
    {
        unit.ConsumeStamina(amount);
    }
    
    // 為被取消的行動返還體力
    public void RefundStaminaForPlan(ActionPlan plan, int attackCost)
    {
        if (plan == null || plan.Source == null) return;
        if (plan.Type == ActionType.Attack)
        {
            plan.Source.RestoreStamina(attackCost);
        }
    }
    
    // 在回合開始時回滿體力
    public void RestoreAllUnitStamina(List<BattleUnit> playerUnits, List<BattleUnit> enemyUnits)
    {
        foreach (var unit in playerUnits)
        {
            if (!unit.IsDead) unit.SetStamina(unit.MaxStamina);
        }
        foreach (var unit in enemyUnits)
        {
            if (!unit.IsDead) unit.SetStamina(unit.MaxStamina);
        }
    }
}
```

#### **EnemyBattleAI.cs**
敵人進攻邏輯。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "EnemyBattleAI", menuName = "Battle System/Enemy AI")]
public class EnemyBattleAI : ScriptableObject
{
    public void PlanActions(List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules)
    {
        // 為前衛規劃
        PlanForRole(BattleRole.Vanguard, 4, selfUnits, opponentUnits, planner, rules);

        // 為遠程規劃
        PlanForRole(BattleRole.Ranged1, 2, selfUnits, opponentUnits, planner, rules);
        PlanForRole(BattleRole.Ranged2, 2, selfUnits, opponentUnits, planner, rules);

        BattleLog.Instance.AddLog("敵人已完成行動規劃。");
    }

    private void PlanForRole(BattleRole role, int maxActions, List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules)
    {
        BattleUnit unit = selfUnits.FirstOrDefault(u => u.Role == role);
        if (unit == null || unit.IsDead) return;

        int actionsToPlan = maxActions - planner.GetActionCountForUnit(unit);

        for (int i = 0; i < actionsToPlan; i++)
        {
            // 尋找一個可用的行動階段 (1-4)
            int? availablePhase = FindAvailablePhase(unit, planner);
            if (availablePhase == null) break; // 沒有可用的格子了

            ActionType action = ActionType.Attack;
            // 簡單的體力判斷
            if (unit.CurrentStamina < 3)
            {
                action = ActionType.Defend;
            }

            var targets = rules.GetValidTargets(unit, opponentUnits);
            BattleUnit target = (targets.Count > 0) ? targets.First() : null;

            if (target != null && action == ActionType.Attack)
            {
                planner.AddPlan(new ActionPlan(unit, target, action, availablePhase.Value));
            }
            else
            {
                // 沒有目標或體力不足，改為防禦
                planner.AddPlan(new ActionPlan(unit, null, ActionType.Defend, availablePhase.Value));
            }
        }
    }

    // 輔助方法：為指定單位尋找一個尚未被佔用的行動階段
    private int? FindAvailablePhase(BattleUnit unit, TurnActionPlanner planner)
    {
        var plannedPhases = planner.GetPlannedPhaseIndicesForUnit(unit);
        for (int phase = 1; phase <= 4; phase++)
        {
            if (!plannedPhases.Contains(phase))
            {
                // 如果是遠程，還要檢查該格子是否已被其他遠程佔用
                if (unit.Role == BattleRole.Ranged1 || unit.Role == BattleRole.Ranged2)
                {
                    if (planner.GetRangedAction(phase, false) == null) // false = isPlayerTeam
                    {
                        return phase;
                    }
                }
                else // 前衛沒有這個限制
                {
                    return phase;
                }
            }
        }
        return null; // 找不到可用的階段
    }
}
```