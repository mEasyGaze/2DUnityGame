好的，這是一個非常清晰且有趣的戰鬥系統設計！它融合了傳統回合制與策略性的資源（行動格）分配。

根據您提供的設計思路和遊戲規則，我將為您編寫對應的 C# 腳本。這些腳本將構成一個功能完整的戰鬥系統框架，您可以在此基礎上擴展動畫、特效和更複雜的技能邏輯。

---

### **1. 戰鬥系統核心資料結構**

#### **`BattleEnums.cs`**
這個腳本定義了整個戰鬥系統所需的枚舉，無需附加到任何物件。

```csharp
// 戰鬥角色的職責
public enum BattleRole
{
    Vanguard, // 前衛
    Ranged1,  // 遠程1
    Ranged2,  // 遠程2
    Support,  // 後勤
    Enemy     // 敵人
}

// 玩家可執行的行動類型
public enum PlayerActionType
{
    None,     // 無行動
    Attack,   // 攻擊
    Defend,   // 防禦
    Skill,    // 技能
    Item,     // 道具
    Swap,     // 交換位置
    CommanderSkill, // 指揮官技能
    EndTurn   // 結束回合
}

// 回合管理器的狀態
public enum TurnState
{
    BattleStart,     // 戰鬥開始
    PlayerPlanning,  // 玩家規劃階段
    ActionExecution, // 行動執行階段
    EnemyTurn,       // 敵人回合
    BattleWon,       // 戰鬥勝利
    BattleLost       // 戰鬥失敗
}
```

#### **`PlannedAction.cs`**
一個簡單的資料容器類，代表一個已規劃的行動。

```csharp
// 代表一個單一的、已規劃的行動
public class PlannedAction
{
    public BattleUnit Actor; // 執行此行動的角色
    public PlayerActionType ActionType; // 執行的行動類型
    public BattleUnit Target; // 行動的目標 (可選)

    public PlannedAction(BattleUnit actor, PlayerActionType actionType, BattleUnit target = null)
    {
        this.Actor = actor;
        this.ActionType = actionType;
        this.Target = target;
    }
}
```

#### **`ActionSlot.cs`**
代表一個行動格，包含前衛和一位遠程的行動計畫。

```csharp
// 代表一個行動格，包含兩個行動計畫
public class ActionSlot
{
    public PlannedAction VanguardAction { get; set; }
    public PlannedAction RangedAction { get; set; }

    public ActionSlot()
    {
        // 初始化時為空，等待玩家填入計畫
        VanguardAction = null;
        RangedAction = null;
    }

    public void Clear()
    {
        VanguardAction = null;
        RangedAction = null;
    }
}
```

---

### **2. 核心戰鬥邏輯**

#### **`BattleUnit.cs`**
附加在所有戰鬥單位（我方與敵方）的 Prefab 上。

```csharp
using UnityEngine;
using System.Collections; // 用於協程

public class BattleUnit : MonoBehaviour
{
    public MemberInstance MemberData { get; set; }
    public BattleRole Role { get; private set; }

    private EnemyDataSO enemyDataSource;

    public string UnitName => enemyDataSource != null ? enemyDataSource.enemyName : MemberData.BaseData.memberName;
    public int MaxHP => enemyDataSource != null ? enemyDataSource.baseHealth : MemberData.MaxHP;

    // 戰鬥中的即時屬性
    public int currentHP;
    public int currentAttack;
    public bool isDefending = false;

    // 初始化戰鬥單位
    public void Setup(MemberInstance memberData, BattleRole role)
    {
        this.MemberData = memberData;
        this.Role = role;

        // 從 MemberInstance 初始化戰鬥屬性
        this.currentHP = memberData.currentHP;
        this.currentAttack = memberData.CurrentAttack;
    }
    
    // 敵人專用的簡易 Setup
    public void SetupEnemy(EnemyDataSO data)
    {
        this.enemyDataSource = data; // 儲存敵人資料來源
        this.Role = BattleRole.Enemy;
        this.currentHP = data.baseHealth;
        this.currentAttack = data.baseAttack;

        // 為了統一，敵人也使用一個 MemberInstance，但僅用於儲存ID和名字
        // 這樣可以避免 BattleUI 在讀取 MemberData 時出錯
        this.MemberData = new MemberInstance
        {
            instanceID = System.Guid.NewGuid().ToString()
            // 注意：這裡不設定 BaseData，因為所有屬性都從 enemyDataSource 讀取
        };
    }

    // 接收傷害
    public bool TakeDamage(int damage)
    {
        if (isDefending)
        {
            damage /= 2; // 防禦時傷害減半
        }

        currentHP -= damage;
        Debug.Log($"{MemberData.BaseData.memberName} 受到 {damage} 點傷害, 剩餘HP: {currentHP}");

        if (currentHP <= 0)
        {
            currentHP = 0;
            Die();
            return true; // 回傳 true 表示已死亡
        }
        return false; // 回傳 false 表示還活著
    }

    // 死亡邏輯
    private void Die()
    {
        Debug.Log($"{MemberData.BaseData.memberName} 已陣亡!");
        // 通知 TurnManager 處理死亡事件
        TurnManager.Instance.OnUnitDied(this);
        // 播放死亡動畫、從場上移除等
        gameObject.SetActive(false);
    }

    // 改變職責 (用於補位)
    public void ChangeRole(BattleRole newRole)
    {
        Debug.Log($"{MemberData.BaseData.memberName} 的職責從 {this.Role} 變為 {newRole}");
        this.Role = newRole;
    }

    // 重置回合狀態 (例如: 解除防禦)
    public void ResetTurnState()
    {
        isDefending = false;
    }

    // 執行交換位置或補位的移動
    public void MoveToPosition(Vector3 newPosition)
    {
        // 這裡可以是一個平滑的移動協程，目前為求簡單直接瞬移
        Debug.Log($"{MemberData.BaseData.memberName} 移動到新位置 {newPosition}");
        transform.position = newPosition;
    }
}
```

#### **`TurnManager.cs`**
戰鬥流程的大腦，負責控制回合、行動執行與死亡處理。

```csharp
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    public static TurnManager Instance { get; private set; }

    public TurnState currentState;
    public ActionSlot[] actionSlots = new ActionSlot[4];

    private BattleManager battleManager;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
        }
        else
        {
            Instance = this;
        }
    }

    public void Setup(BattleManager manager)
    {
        this.battleManager = manager;
        for (int i = 0; i < 4; i++)
        {
            actionSlots[i] = new ActionSlot();
        }
    }

    public void StartBattle()
    {
        Debug.Log("戰鬥開始!");
        StartPlayerPlanningPhase();
    }

    // 1. 玩家規劃階段
    public void StartPlayerPlanningPhase()
    {
        currentState = TurnState.PlayerPlanning;
        Debug.Log("--- 玩家規劃階段 ---");

        // 清空上一回合的行動計畫
        foreach (var slot in actionSlots)
        {
            slot.Clear();
        }
        // 重置所有單位的狀態
        foreach (var unit in battleManager.GetAllUnits())
        {
            unit.ResetTurnState();
        }
        
        // 通知 UI 更新
        BattleUIManager.Instance.UpdateUIForState(currentState);
    }
    
    // 由 UI 呼叫，用來設定行動
    public bool PlanAction(BattleRole role, PlayerActionType action, int slotIndex)
    {
        BattleUnit actor = battleManager.GetUnitByRole(role);
        if (actor == null) return false;

        // 前衛總是行動
        if (role == BattleRole.Vanguard)
        {
            actionSlots[slotIndex].VanguardAction = new PlannedAction(actor, action, battleManager.GetFirstAliveEnemy());
            Debug.Log($"[行動格 {slotIndex + 1}] 已規劃 [前衛] 的行動: {action}");
            return true;
        }

        // 遠程行動
        if (role == BattleRole.Ranged1 || role == BattleRole.Ranged2)
        {
            if (actionSlots[slotIndex].RangedAction != null)
            {
                Debug.LogWarning($"[行動格 {slotIndex + 1}] 已被另一位遠程佔據!");
                return false;
            }
            actionSlots[slotIndex].RangedAction = new PlannedAction(actor, action, battleManager.GetFirstAliveEnemy());
            Debug.Log($"[行動格 {slotIndex + 1}] 已規劃 [{role}] 的行動: {action}");
            return true;
        }
        return false;
    }

    // 玩家按下「回合結束」按鈕後呼叫此方法
    public void ConfirmActionsAndEndTurn()
    {
        // 可以在此處加入檢查，例如是否所有行動格都已規劃
        StartCoroutine(ExecuteTurn());
    }

    // 2. 行動執行階段
    private IEnumerator ExecuteTurn()
    {
        currentState = TurnState.ActionExecution;
        BattleUIManager.Instance.UpdateUIForState(currentState);
        Debug.Log("--- 行動執行階段 ---");

        for (int i = 0; i < 4; i++)
        {
            Debug.Log($"--- 執行行動格 {i + 1} ---");
            ActionSlot currentSlot = actionSlots[i];

            // 執行前衛行動
            if (currentSlot.VanguardAction != null && currentSlot.VanguardAction.Actor.currentHP > 0)
            {
                ExecuteSingleAction(currentSlot.VanguardAction);
                yield return new WaitForSeconds(1.0f); // 等待動畫或效果
            }
            // 執行遠程行動
            if (currentSlot.RangedAction != null && currentSlot.RangedAction.Actor.currentHP > 0)
            {
                ExecuteSingleAction(currentSlot.RangedAction);
                yield return new WaitForSeconds(1.0f); // 等待動畫或效果
            }
            
            // 每次行動後都檢查戰鬥是否結束
            if (CheckForBattleEnd()) yield break;
        }

        StartCoroutine(EnemyTurn());
    }
    
    private void ExecuteSingleAction(PlannedAction action)
    {
        Debug.Log($"{action.Actor.Role} 執行 {action.ActionType}");
        switch (action.ActionType)
        {
            case PlayerActionType.Attack:
                if (action.Target != null && action.Target.currentHP > 0)
                {
                    int damage = action.Actor.currentAttack;
                    action.Target.TakeDamage(damage);
                }
                else
                {
                    Debug.Log("目標已死亡或不存在，攻擊取消。");
                }
                break;
            case PlayerActionType.Defend:
                action.Actor.isDefending = true;
                Debug.Log($"{action.Actor.Role} 進入防禦姿態。");
                break;
            // 其他技能、道具等邏輯可在此擴充
        }
    }

    // 3. 敵人回合
    private IEnumerator EnemyTurn()
    {
        currentState = TurnState.EnemyTurn;
        BattleUIManager.Instance.UpdateUIForState(currentState);
        Debug.Log("--- 敵人回合 ---");
        yield return new WaitForSeconds(1.0f);

        foreach (var enemy in battleManager.GetAliveEnemies())
        {
            BattleUnit target = battleManager.GetUnitByRole(BattleRole.Vanguard);
            if (target == null || target.currentHP <= 0)
            {
                Debug.Log("找不到前衛，敵人無法攻擊。"); // 理論上會被補位機制處理
                continue;
            }
            
            Debug.Log($"{enemy.MemberData.BaseData.memberName} 攻擊 {target.Role}");
            enemy.TakeDamage(target.currentAttack);
            yield return new WaitForSeconds(1.0f);

            if (CheckForBattleEnd()) yield break;
        }

        Debug.Log("敵人回合結束。");
        StartPlayerPlanningPhase();
    }

    // 4. 處理死亡
    public void OnUnitDied(BattleUnit deadUnit)
    {
        Debug.Log($"偵測到單位死亡: {deadUnit.Role}");

        if (deadUnit.Role == BattleRole.Enemy)
        {
            battleManager.RemoveEnemy(deadUnit);
        }
        else // 我方單位死亡
        {
            battleManager.RemovePlayerUnit(deadUnit.Role);
            // 執行補位邏輯
            HandlePositionFilling();
        }
        
        CheckForBattleEnd();
    }
    
    private void HandlePositionFilling()
    {
        // 檢查前衛是否陣亡
        if (battleManager.GetUnitByRole(BattleRole.Vanguard) == null)
        {
            BattleUnit newVanguard = battleManager.GetUnitByRole(BattleRole.Ranged1);
            if (newVanguard != null) // 如果遠程1存在
            {
                battleManager.UpdateUnitRole(BattleRole.Ranged1, BattleRole.Vanguard);
                newVanguard.MoveToPosition(battleManager.GetPositionForRole(BattleRole.Vanguard));

                // 遠程2補位到遠程1
                BattleUnit newRanged1 = battleManager.GetUnitByRole(BattleRole.Ranged2);
                if (newRanged1 != null)
                {
                    battleManager.UpdateUnitRole(BattleRole.Ranged2, BattleRole.Ranged1);
                    newRanged1.MoveToPosition(battleManager.GetPositionForRole(BattleRole.Ranged1));
                }
            }
            else // 如果遠程1也不存在，檢查後勤
            {
                BattleUnit support = battleManager.GetUnitByRole(BattleRole.Support);
                if (support != null)
                {
                    battleManager.UpdateUnitRole(BattleRole.Support, BattleRole.Vanguard);
                    support.MoveToPosition(battleManager.GetPositionForRole(BattleRole.Vanguard));
                    Debug.Log("後勤人員親自上陣！指揮官效果消失。");
                }
            }
        }
    }
    
    private bool CheckForBattleEnd()
    {
        if (battleManager.GetAlivePlayerUnits().Count == 0)
        {
            currentState = TurnState.BattleLost;
            Debug.Log("戰鬥失敗...");
            GameManager.Instance.EndBattle(false, null);
            return true;
        }

        if (battleManager.GetAliveEnemies().Count == 0)
        {
            currentState = TurnState.BattleWon;
            Debug.Log("戰鬥勝利！");
            // BattleUIManager.Instance.ShowEndPanel(true);
            // 從 BattleManager 取得獎勵資料並傳遞
            GameManager.Instance.EndBattle(true, battleManager.CurrentBattleEncounter.rewards);
            return true;
        }
        return false;
    }
}
```

---

### **3. 戰鬥管理器**

#### **`BattleManager.cs`**
戰鬥場景的總控制器，負責生成單位和管理職責。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattleManager : MonoBehaviour
{
    public static BattleManager Instance { get; private set; }

    [Header("單位 Prefabs")]
    [SerializeField] private BattleUnit playerUnitPrefab;
    // [SerializeField] private BattleUnit enemyUnitPrefab; // 這個可以移到 EnemyDataSO 中

    [Header("單位生成點")]
    [SerializeField] private Transform[] playerPositions; // 0:前衛, 1:遠1, 2:遠2, 3:後勤
    [SerializeField] private Transform[] enemyPositions;

    // 儲存所有場上單位
    private Dictionary<BattleRole, BattleUnit> playerUnits = new Dictionary<BattleRole, BattleUnit>();
    private List<BattleUnit> enemyUnits = new List<BattleUnit>();

    [SerializeField] private TurnManager turnManager;

    public BattleEncounterSO CurrentBattleEncounter { get; private set; }

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
        }
        else
        {
            Instance = this;
        }
    }

    // 由 GameManager 呼叫
    public void SetupBattle(BattleEncounterSO encounter)
    {
        this.CurrentBattleEncounter = encounter;
        
        List<MemberInstance> party = PartyManager.Instance.BattleParty;
        // 如果隊伍為空，使用假資料進行測試
        if (party == null || party.Count == 0)
        {
            party = CreateMockParty();
        }

        SpawnPlayerUnits(party);
        SpawnEnemyUnits(encounter.enemiesInEncounter);

        turnManager.Setup(this);
        turnManager.StartBattle();
    }

    private void SpawnPlayerUnits(List<MemberInstance> party)
    {
        BattleRole[] roles = { BattleRole.Vanguard, BattleRole.Ranged1, BattleRole.Ranged2, BattleRole.Support };
        for (int i = 0; i < party.Count && i < 4; i++)
        {
            playerUnits.Clear();
            BattleUnit newUnit = Instantiate(playerUnitPrefab, playerPositions[i].position, Quaternion.identity);
            newUnit.Setup(party[i], roles[i]);
            playerUnits.Add(roles[i], newUnit);
        }
        Debug.Log($"生成了 {playerUnits.Count} 名我方單位。");
    }

    private void SpawnEnemyUnits(List<EnemyPlacement> enemyPlacements)
    {
        enemyUnits.Clear();
        foreach (var placement in enemyPlacements)
        {
            if (placement.positionIndex < 0 || placement.positionIndex >= enemyPositions.Length)
            {
                Debug.LogError($"敵人 {placement.enemyData.enemyName} 的位置索引 {placement.positionIndex} 無效！");
                continue;
            }

            BattleUnit prefab = placement.enemyData.enemyPrefab;
            Transform spawnPoint = enemyPositions[placement.positionIndex];
            
            BattleUnit newEnemy = Instantiate(prefab, spawnPoint.position, Quaternion.identity, spawnPoint);
            newEnemy.SetupEnemy(placement.enemyData); // 現在會呼叫修正後的 SetupEnemy 方法
            enemyUnits.Add(newEnemy);
        }
    }

    // --- 公用查詢方法 ---
    public BattleUnit GetUnitByRole(BattleRole role)
    {
        playerUnits.TryGetValue(role, out BattleUnit unit);
        return unit;
    }

    public List<BattleUnit> GetAlivePlayerUnits() => playerUnits.Values.Where(u => u.currentHP > 0).ToList();
    public List<BattleUnit> GetAliveEnemies() => enemyUnits.Where(u => u.currentHP > 0).ToList();
    public List<BattleUnit> GetAllUnits() => playerUnits.Values.Concat(enemyUnits).ToList();
    public BattleUnit GetFirstAliveEnemy() => enemyUnits.FirstOrDefault(e => e.currentHP > 0);
    public Vector3 GetPositionForRole(BattleRole role)
    {
        int index = (int)role; // 巧妙利用枚舉的順序
        if (index >= 0 && index < playerPositions.Length)
        {
            return playerPositions[index].position;
        }
        return Vector3.zero;
    }

    // --- 單位管理 ---
    public void RemovePlayerUnit(BattleRole role) => playerUnits.Remove(role);
    public void RemoveEnemy(BattleUnit enemy) => enemyUnits.Remove(enemy);
    public void UpdateUnitRole(BattleRole oldRole, BattleRole newRole)
    {
        BattleUnit unit = GetUnitByRole(oldRole);
        if (unit != null)
        {
            playerUnits.Remove(oldRole);
            unit.ChangeRole(newRole);
            playerUnits.Add(newRole, unit);
        }
    }
    
    // 建立一個假的隊伍資料用於測試
    private List<MemberInstance> CreateMockParty()
    {
        // 確保你有名為 "Template_Warrior", "Template_Archer" 等的 MemberDataSO
        var p1 = new MemberInstance("Template_Warrior", 5);
        var p2 = new MemberInstance("Template_Archer", 5);
        var p3 = new MemberInstance("Template_Mage", 5);
        var p4 = new MemberInstance("Template_Healer", 5);
        return new List<MemberInstance> { p1, p2, p3, p4 };
    }
}
```

#### **`BattleUIManager.cs`**
UI 的總管，負責根據遊戲狀態顯示/隱藏介面，並處理玩家的按鈕點擊。

```csharp
using UnityEngine;
using TMPro;

public class BattleUIManager : MonoBehaviour
{
    public static BattleUIManager Instance { get; private set; }

    [Header("UI 面板")]
    [SerializeField] private GameObject planningPanel; // 玩家規劃行動的UI面板
    [SerializeField] private GameObject executionPanel; // 顯示 "行動執行中..." 的面板
    [SerializeField] private BattleEndUI endPanel; // 戰鬥結算面板

    [Header("資訊顯示")]
    [SerializeField] private TextMeshProUGUI turnInfoText;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
        }
        else
        {
            Instance = this;
        }
    }
    
    private void Start()
    {
        // 初始狀態下隱藏所有面板
        planningPanel.SetActive(false);
        executionPanel.SetActive(false);
        endPanel.gameObject.SetActive(false);
    }
    
    // 由 TurnManager 呼叫，根據狀態更新整體UI
    public void UpdateUIForState(TurnState state)
    {
        planningPanel.SetActive(state == TurnState.PlayerPlanning);
        executionPanel.SetActive(state == TurnState.ActionExecution || state == TurnState.EnemyTurn);
        
        switch (state)
        {
            case TurnState.PlayerPlanning:
                turnInfoText.text = "請規劃您的行動";
                break;
            case TurnState.ActionExecution:
                turnInfoText.text = "我方行動中...";
                break;
            case TurnState.EnemyTurn:
                turnInfoText.text = "敵方行動中...";
                break;
        }
    }
    
    // 顯示戰鬥結束畫面
    public void ShowEndPanel(bool didWin)
    {
        endPanel.Show(didWin);
    }

    // --- 以下為 UI 按鈕會呼叫的方法範例 ---
    
    // 範例: 當玩家點擊"攻擊"按鈕，並選擇了第1個行動格
    public void OnAttackButtonPress(int slotIndex)
    {
        // 這裡需要一個機制來確定是哪個遠程角色在行動
        // 為求簡單，我們假設有個UI Toggle Group讓玩家選擇遠程1的格子
        // bool isRanged1Turn = IsSlotForRanged1(slotIndex);
        // BattleRole rangedRole = isRanged1Turn ? BattleRole.Ranged1 : BattleRole.Ranged2;
        
        // 暫時簡化：單數格給遠1，雙數格給遠2
        BattleRole rangedRole = (slotIndex % 2 == 0) ? BattleRole.Ranged1 : BattleRole.Ranged2;

        TurnManager.Instance.PlanAction(BattleRole.Vanguard, PlayerActionType.Attack, slotIndex);
        TurnManager.Instance.PlanAction(rangedRole, PlayerActionType.Attack, slotIndex);
    }
    
    // 範例: 當玩家點擊"防禦"按鈕 (只有前衛能用)
    public void OnDefendButtonPress(int slotIndex)
    {
        TurnManager.Instance.PlanAction(BattleRole.Vanguard, PlayerActionType.Defend, slotIndex);
    }
    
    // 當玩家完成所有規劃，按下「回合結束」
    public void OnEndTurnButtonPress()
    {
        TurnManager.Instance.ConfirmActionsAndEndTurn();
    }
}
```

---

### **4. 戰鬥 UI 元件**

#### **`BattleUI.cs`**
這個腳本可以附加在每個角色的血條UI上，或者一個總的UI控制器上。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BattleUI : MonoBehaviour
{
    [SerializeField] private BattleUnit targetUnit;
    [SerializeField] private Slider hpSlider;
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI nameText;

    void Update()
    {
        if (targetUnit != null && targetUnit.isActiveAndEnabled)
        {
            // 隨時更新血條
            float maxHP = targetUnit.MemberData.MaxHP;
            float currentHP = targetUnit.currentHP;
            
            hpSlider.value = currentHP / maxHP;
            hpText.text = $"{currentHP} / {maxHP}";
        }
        else
        {
            // 如果目標死亡，可以隱藏此UI
            gameObject.SetActive(false);
        }
    }

    public void Setup(BattleUnit unit)
    {
        targetUnit = unit;
        nameText.text = unit.MemberData.BaseData.memberName;
        Update(); // 立即更新一次
    }
}
```

#### **`BattleEndUI.cs`**
附加在結算畫面 Panel 上的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.SceneManagement; // 用於返回主場景

public class BattleEndUI : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI resultText;
    [SerializeField] private Button exitButton;

    private void Awake()
    {
        exitButton.onClick.AddListener(ExitBattle);
    }
    
    public void Show(bool didWin)
    {
        gameObject.SetActive(true);
        if (didWin)
        {
            resultText.text = "戰 鬥 勝 利";
            // 顯示獎勵...
        }
        else
        {
            resultText.text = "戰 鬥 失 敗";
        }
    }
    
    private void ExitBattle()
    {
        // 這裡應返回大地圖或主選單
        Debug.Log("退出戰鬥場景...");
        // SceneManager.LoadScene("WorldMap"); // 範例
    }
}
```

#### **`EnemyDataSO.cs`**
這是敵人的靜態資料模板，在 Unity 編輯器中創建和設定。
```csharp
using UnityEngine;
using System.Collections.Generic;

// 預先定義一個 AI 行為模式的枚舉，方便在編輯器中選擇
public enum EnemyAIType
{
    SimpleAttack,       // 只會攻擊當前的前衛
    RandomAttack,       // 隨機攻擊任一存活的我方角色
    FocusLowestHP,      // 優先攻擊血量最低的角色
    AggressiveSkillUser // 頻繁使用技能
}

[CreateAssetMenu(fileName = "NewEnemyData", menuName = "Battle System/Enemy Data")]
public class EnemyDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string enemyID;
    public string enemyName;
    public BattleUnit enemyPrefab; // 直接引用包含 BattleUnit 的 Prefab

    [Header("基礎屬性")]
    public int baseHealth;
    public int baseAttack;
    
    [Header("AI 與技能")]
    public EnemyAIType aiType;
    // public List<SkillDataSO> availableSkills; // 未來擴充技能系統時使用
}
```

#### **`BattleEncounterSO.cs`**
用來打包一場完整的戰鬥，包含敵人、位置和獎勵。
```csharp
using UnityEngine;
using System.Collections.Generic;

// 由於 Unity 的 Inspector 無法直接顯示複雜列表，我們需要一個可序列化的輔助類
[System.Serializable]
public class EnemyPlacement
{
    public EnemyDataSO enemyData; // 要生成的敵人是誰
    public int positionIndex;     // 要生成在哪個位置 (對應 BattleManager 的 enemyPositions 陣列索引)
}

[System.Serializable]
public class BattleRewards
{
    public int experience;
    public int gold;
    // public List<ItemDrop> itemDrops; // 未來擴充道具掉落系統時使用
}

[CreateAssetMenu(fileName = "NewBattleEncounter", menuName = "Battle System/Battle Encounter")]
public class BattleEncounterSO : ScriptableObject
{
    [Header("敵人配置")]
    public List<EnemyPlacement> enemiesInEncounter;

    [Header("戰鬥獎勵")]
    public BattleRewards rewards;

    // 還可以加入其他戰鬥相關設定，例如:
    // public AudioClip battleMusic;
    // public Sprite battleBackground;
}
```

#### **`GameManager.cs`**
凌駕於所有系統之上的最高層級管理者，負責場景切換和狀態控制。
```csharp
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    public enum GameState
    {
        World,  // 在大地圖/探索
        Battle, // 戰鬥中
        Paused  // 暫停
    }

    public GameState CurrentState { get; private set; }

    private BattleEncounterSO currentEncounter;
    private string previousSceneName; // 儲存進入戰鬥前的場景名稱

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);

        // 監聽場景載入完成的事件
        SceneManager.sceneLoaded += OnSceneLoaded;
    }
    
    private void OnDestroy()
    {
        // 移除監聽，避免記憶體洩漏
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    // 由 BattleTrigger 呼叫，用來啟動一場戰鬥
    public void StartBattle(BattleEncounterSO encounter)
    {
        if (CurrentState == GameState.Battle)
        {
            Debug.LogWarning("已經在戰鬥中了，無法啟動新戰鬥！");
            return;
        }

        CurrentState = GameState.Battle;
        currentEncounter = encounter;
        previousSceneName = SceneManager.GetActiveScene().name;

        Debug.Log($"準備開始戰鬥: {encounter.name}。從場景 {previousSceneName} 載入戰鬥場景...");
        // 假設你的戰鬥場景名為 "BattleScene"
        SceneManager.LoadScene("BattleScene");
    }

    // 當戰鬥結束後，由 BattleManager 呼叫
    public void EndBattle(bool playerWon, BattleRewards rewards)
    {
        CurrentState = GameState.World;
        Debug.Log($"戰鬥結束，玩家 {(playerWon ? "勝利" : "失敗")}。返回場景 {previousSceneName}...");

        if (playerWon)
        {
            // 在這裡處理戰鬥獎勵的分發
            Debug.Log($"獲得獎勵: {rewards.experience} 經驗, {rewards.gold} 金幣。");
            // PartyManager.Instance.AddExperience(rewards.experience);
        }

        SceneManager.LoadScene(previousSceneName);
    }
    
    // 當場景載入完成時會自動呼叫此方法
    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        // 檢查是否載入的是戰鬥場景，並且我們正處於戰鬥狀態
        if (scene.name == "BattleScene" && CurrentState == GameState.Battle)
        {
            // 找到新場景中的 BattleManager，並將戰鬥配置傳遞給它
            BattleManager battleManager = FindObjectOfType<BattleManager>();
            if (battleManager != null)
            {
                battleManager.SetupBattle(currentEncounter);
            }
            else
            {
                Debug.LogError("在戰鬥場景中找不到 BattleManager！");
            }
        }
    }
}
```

#### **`BattleTrigger.cs`**
放置在地圖上，當玩家接觸時，通知 GameManager 開始戰鬥。
```csharp
using UnityEngine;

public class BattleTrigger : MonoBehaviour
{
    [SerializeField]
    private BattleEncounterSO encounterToTrigger;

    // 建議將此觸發器的 Collider 設為 isTrigger
    private void OnTriggerEnter(Collider other)
    {
        // 檢查碰到的是否是玩家
        if (other.CompareTag("Player"))
        {
            Debug.Log($"玩家碰到了戰鬥觸發器: {gameObject.name}");
            if (encounterToTrigger != null)
            {
                // 通知 GameManager 開始戰鬥
                GameManager.Instance.StartBattle(encounterToTrigger);

                // 觸發後可以選擇禁用此觸發器，避免重複觸發
                // gameObject.SetActive(false);
            }
            else
            {
                Debug.LogError("此戰鬥觸發器沒有配置 BattleEncounterSO！");
            }
        }
    }
}
```