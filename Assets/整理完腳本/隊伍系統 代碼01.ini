### **1. 隊伍系統**

#### **資料層 (Data Layer)**

*   **`MemberDataSO.cs` (ScriptableObject):**
    *   **職責**：定義一個成員的「原始設計藍圖」。
    *   **功能**：
        *   包含成員的靜態資料，如 ID、名稱、圖像、基礎屬性與成長規則。
        *   由開發者在 Unity 編輯器中設定，作為遊戲的基礎設定值，一旦設定好就不會改變。

*   **`PartyDatabase.cs` (ScriptableObject):**
    *   **職責**：作為遊戲中所有成員設計藍圖 (`MemberDataSO`) 的「中央資料庫」。
    *   **功能**：
        *   持有一個遊戲中所有 `MemberDataSO` 的列表。
        *   提供一個全域靜態方法 (`GetMemberDataByID`)，讓任何腳本都能透過 ID 快速查詢到成員的原始資料，是整個系統的資料來源。

*   **`MemberInstance.cs` (Serializable Class):**
    *   **職責**：代表一個玩家「實際擁有、會成長」的成員個體。
    *   **功能**：
        *   儲存動態資料，如等級、經驗值、當前血量。
        *   透過 `memberDataSO_ID` 關聯到它的設計藍圖，並以此計算出當前的最大血量、攻擊力等屬性。
        *   擁有一個獨一無二的 `instanceID`，用於在存檔中識別每一個體。
        *   這個類別的物件會被寫入 JSON 存檔中，記錄玩家進度。

*   **`SkillData.cs`(ScriptableObject):**
    *   **職責**：定義一個技能的「原始設計藍圖」。
    *   **功能**：
        *   被動技能、主動技能、指揮官技能
        *   包含成員的靜態資料，如 ID、名稱、描述、是否為攻擊(若是-攻擊距離)、是否為回血(若是-使用距離)、是否為被動技能。

*   **`SkillDatabase.cs` (ScriptableObject):**
    *   **職責**：作為遊戲中所有技能設計藍圖 (`SkillData`) 的「中央資料庫」。
    *   **功能**：
        *  持有一個遊戲中所有 `SkillData` 的列表。
        *  提供一個全域靜態方法 (`GetSkillDataByID`)，讓任何腳本都能透過 ID 快速查詢到成員的原始資料，是整個系統的資料來源。

---

#### **邏輯層 (Logic Layer)**

*   **`PartyManager.cs`:**
    *   **職責**：作為隊伍系統的「中央管理器」，處理所有隊伍相關的邏輯與狀態變更。
    *   **功能**：
        *   管理玩家的兩個核心列表：`AllMembers` (所有成員倉庫) 和 `BattleParty` (戰鬥隊伍)。
        *   提供方法來執行操作，如「上陣」、「卸下」、「交換順序」。
        *   當隊伍資料發生任何變動（如成員增減、順序變更）時，會觸發一個全域事件 (`OnPartyUpdated`)，通知所有 UI 介面進行更新。
        *   作為存檔和讀檔的發起點，會呼叫 `JSONSaveManager` 來執行實際的檔案操作。

---

#### **表現層 (View / UI Layer)**

*   **`MemberCardUI.cs`:**
    *   **職責**：作為可重用的 UI 元件，專門用來顯示成員的「基礎資訊卡片」（如倉庫列表）。
    *   **功能**：
        *   接收一個 `MemberInstance` 資料，並在卡片上顯示其名稱和圖像。
        *   處理點擊事件，通知上層管理器（如 `PartyHolderUI`）玩家選擇了哪個成員。
        *   根據傳入的狀態（如是否被選中、是否在戰鬥隊伍中）顯示不同的視覺效果，例如發光的邊框。

*   **`MemberStatCardUI.cs`:**
    *   **職責**：作為可重用的 UI 元件，專門用來顯示成員的「詳細戰鬥屬性卡片」（如戰鬥隊伍欄位）。
    *   **功能**：
        *   接收一個 `MemberInstance` 資料，並顯示更詳細的資訊，如名稱、圖像、當前/最大血量、攻擊力等。

*   **`PartyHolderUI.cs`:**
    *   **職責**：管理「全部成員倉庫」的 UI 介面。
    *   **功能**：
        *   監聽 `PartyManager` 的 `OnPartyUpdated` 事件。
        *   事件觸發時，它會根據 `PartyManager` 的 `AllMembers` 列表，動態生成或更新所有 `MemberCardUI`。
        *   當卡片被點擊時，它會呼叫 `PartyDetailUI` 來顯示該成員的詳細資料。

*   **`PartyBattleUI.cs`:**
    *   **職責**：管理「當前戰鬥隊伍」的 UI 介面。
    *   **功能**：
        *   同樣監聽 `OnPartyUpdated` 事件。
        *   事件觸發時，它會根據 `PartyManager` 的 `BattleParty` 列表，更新戰鬥隊伍欄位中的 `MemberStatCardUI`。
        *   負責顯示當前出戰成員的卡片，並處理拖曳交換順序等互動。

*   **`PartyDetailUI.cs`:**
    *   **職責**：管理「成員詳細資料」的彈出式面板。
    *   **功能**：
        *   平時隱藏，在玩家點擊任一成員卡片時被呼叫並顯示。
        *   展示指定 `MemberInstance` 的所有詳細數據（等級、經驗、屬性等）。
        *   面板上的「上陣/卸下」按鈕會根據該成員的當前狀態動態改變其文字和功能。

---

### **2. JSON 系統**

*   **`JSONSaveManager.cs`:**
    *   **職責**：專職的「存檔與讀檔工具人」，負責處理 JSON 序列化與檔案系統操作。
    *   **功能**：
        *   提供 `SavePartyData` 方法，將 `PartySaveData` 物件轉換成 JSON 格式的文字，並寫入硬碟檔案。
        *   提供 `LoadPartyData` 方法，從硬碟讀取 JSON 檔案，將其轉換回 `PartySaveData` 物件，並交還給 `PartyManager`。
        *   管理存檔路徑，並能在讀檔時進行資料驗證，確保存檔的相容性。

*   **`PartySaveData.cs` (Serializable Class):**
    *   **職責**：作為一個資料「包裹」或「容器」，專門用來配合 Unity 的 JSON 工具進行序列化。
    *   **功能**：
        *   它的存在是為了解決技術限制：Unity 的 `JsonUtility` 無法直接序列化一個根層級的 List。
        *   它將所有需要存檔的列表（如 `AllMembers` 和 `BattlePartyInstanceIDs`）打包成一個單一的物件，讓 `JSONSaveManager` 可以順利地處理。好的，這就為您口語化地整理一下剛剛那些腳本的功能介紹。

---

### **成員資料 (Data Layer)**

#### **1. MemberDataSO.cs (ScriptableObject)**
這是成員的靜態資料模板，在 Unity 編輯器中創建和設定。

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewMemberData", menuName = "Party System/Member Data")]
public class MemberDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string memberID; // 成員ID (獨一無二的編號)
    public string memberName; // 成員名稱
    public Sprite memberIcon; // 成員圖像

    [Header("基礎屬性")]
    public int baseHealth; // 基礎血量
    public int baseAttack; // 基礎攻擊力
    public int baseStamina; // 體力 (用於攻擊、施放技能)
    public int attackRange; // 基礎攻擊距離

    // 註解：移除行動點數，改為統一的體力值
    // public int attackActionPoints;
    // public int defenseActionPoints;

    [Header("技能槽位")]
    [Tooltip("在此輸入對應 SkillData 的技能ID")]
    public List<string> skillIDs; // 存放此成員擁有的技能ID列表

    [Header("成長規則 (暫不使用)")]
    // 根據您的要求，暫時註解掉成長相關屬性
    public int healthPerLevel; // 每級提升的血量
    public int attackPerLevel; // 每級提升的攻擊力
}
```

#### **2. PartyDatabase.cs (ScriptableObject)**
作為遊戲中所有 `MemberDataSO` 的中央資料庫。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "PartyDatabase", menuName = "Party System/Party Database")]
public class PartyDatabase : ScriptableObject
{
    public List<MemberDataSO> allMembers;

    // 使用字典來加速查找，避免每次都遍歷列表
    private static Dictionary<string, MemberDataSO> memberDictionary;

    // 在遊戲啟動時或編輯器中啟用時，建立字典
    private void OnEnable()
    {
        if (allMembers == null)
        {
            allMembers = new List<MemberDataSO>();
        }

        // 使用 LINQ 快速建立字典
        memberDictionary = allMembers.ToDictionary(member => member.memberID, member => member);
        Debug.Log("隊伍資料庫已載入，共 " + memberDictionary.Count + " 名成員。");
    }

    // 提供一個全局靜態方法來透過ID獲取成員模板數據
    public static MemberDataSO GetMemberDataByID(string id)
    {
        if (memberDictionary == null)
        {
            Debug.LogError("隊伍資料庫尚未初始化！請確保它被載入。");
            return null;
        }

        memberDictionary.TryGetValue(id, out MemberDataSO data);
        if (data == null)
        {
            Debug.LogWarning($"在資料庫中找不到ID為 '{id}' 的成員資料。");
        }
        return data;
    }
}
```
**注意**: 為了讓 `PartyDatabase` 的靜態方法能正常運作，你需要在遊戲啟動時確保這個 ScriptableObject 被載入。一個常見做法是將它放在 `Resources` 資料夾中，並在一個啟動腳本中執行 `Resources.Load("PartyDatabase")`。

#### **3. MemberInstance.cs (可序列化 Class)**
這是玩家實際擁有的成員個體，用於存檔。它不是 `MonoBehaviour`。

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

[System.Serializable]
public class MemberInstance
{
    public string memberDataSO_ID;  // 關聯到 MemberDataSO 的 ID
    public string instanceID;       // 每個實例獨一無二的識別碼
    public int level;
    public int experience;

    // 動態狀態值，這些會被存檔
    public int currentHP;
    public int currentStamina;

    [NonSerialized]
    private MemberDataSO _baseData;
    public MemberDataSO BaseData
    {
        get
        {
            if (_baseData == null)
            {
                _baseData = PartyDatabase.GetMemberDataByID(memberDataSO_ID);
            }
            return _baseData;
        }
    }

    // 計算屬性：最大值和攻擊力會根據基礎值和等級計算
    // 即使成長規則被註解，我們仍保留計算結構，方便未來重新啟用
    public int MaxHP => BaseData != null ? BaseData.baseHealth + (level - 1) * BaseData.healthPerLevel : 0;
    public int CurrentAttack => BaseData != null ? BaseData.baseAttack + (level - 1) * BaseData.attackPerLevel : 0;
    public int MaxStamina => BaseData != null ? BaseData.baseStamina : 0;

    // 一個方便獲取完整技能資料列表的屬性
    [NonSerialized]
    private List<SkillData> _skills;
    public List<SkillData> Skills
    {
        get
        {
            // 如果從未獲取過，就從資料庫查詢一次
            if (_skills == null && BaseData != null)
            {
                _skills = BaseData.skillIDs.Select(id => SkillDatabase.GetSkillDataByID(id)).Where(skill => skill != null).ToList();
            }
            return _skills ?? new List<SkillData>(); // 如果_skills還是null，返回一個空列表避免錯誤
        }
    }


    // 構造函數，用於創建一個新的成員實例
    public MemberInstance(string so_id, int startLevel = 1)
    {
        memberDataSO_ID = so_id;
        instanceID = Guid.NewGuid().ToString();
        level = startLevel;
        experience = 0;

        // 初始化時，將當前狀態設為最大值
        currentHP = MaxHP;
        currentStamina = MaxStamina;
    }

    // JSON反序列化後需要一個無參數的構造函數
    public MemberInstance() { }
}
```

#### **4. SkillData.cs (ScriptableObject)**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "SkillDatabase", menuName = "Party System/Skill Database")]
public class SkillDatabase : ScriptableObject
{
    public List<SkillData> allSkills;

    private static Dictionary<string, SkillData> skillDictionary;

    private void OnEnable()
    {
        if (allSkills == null)
        {
            allSkills = new List<SkillData>();
        }

        skillDictionary = allSkills.ToDictionary(skill => skill.skillID, skill => skill);
        Debug.Log("技能資料庫已載入，共 " + skillDictionary.Count + " 個技能。");
    }

    // 提供一個全局靜態方法來透過ID獲取技能模板數據
    public static SkillData GetSkillDataByID(string id)
    {
        if (skillDictionary == null)
        {
            Debug.LogError("技能資料庫尚未初始化！請確保它被載入。");
            return null;
        }

        skillDictionary.TryGetValue(id, out SkillData data);
        if (data == null)
        {
            Debug.LogWarning($"在資料庫中找不到ID為 '{id}' 的技能資料。");
        }
        return data;
    }
}
```

#### **5. SkillDatabase.cs (ScriptableObject)**

```csharp
using UnityEngine;

// 技能類型的枚舉 (Enums)
public enum SkillType
{
    Passive,    // 被動技能
    Active,     // 主動技能
    Commander   // 指揮官技能
}

[CreateAssetMenu(fileName = "NewSkillData", menuName = "Party System/Skill Data")]
public class SkillData : ScriptableObject
{
    [Header("基礎資訊")]
    public string skillID;          // 技能ID (獨一無二)
    public string skillName;        // 技能名稱
    [TextArea(3, 5)]
    public string skillDescription; // 技能描述

    [Header("技能類型與規則")]
    public SkillType skillType;     // 技能類型 (主動/被動/指揮官)

    public bool isAttackSkill;      // 是否為攻擊型技能
    public int attackRange;         // 若是攻擊技能，其攻擊距離

    public bool isHealSkill;        // 是否為治療型技能
    public int healRange;           // 若是治療技能，其使用距離
    
    // 未來可擴充，例如：
    // public int staminaCost;      // 技能體力消耗
    // public Sprite skillIcon;     // 技能圖示
    // public GameObject vfxPrefab; // 技能特效
}
```

---

### **隊伍管理器 (Logic Layer)**

#### **1. PartyManager.cs**
管理玩家的所有成員和戰鬥隊伍的核心邏輯。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class PartyManager : MonoBehaviour
{
    // 使用單例模式確保全局只有一個 PartyManager
    public static PartyManager Instance { get; private set; }

    [Header("隊伍設定")]
    [SerializeField] private int maxBattlePartySize = 4;

    [Header("玩家隊伍資料")]
    public List<MemberInstance> AllMembers; // 玩家擁有的所有成員
    public List<MemberInstance> BattleParty; // 當前出戰的成員

    // 全局事件，當隊伍資料更新時觸發
    public static event System.Action OnPartyUpdated;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject); // 確保在場景切換時管理器不被銷毀

        AllMembers = new List<MemberInstance>();
        BattleParty = new List<MemberInstance>();
    }

    // 將指定ID的成員加入到玩家的倉庫 (Holder)
    public void AddMemberToHolder(string memberID)
    {
        MemberDataSO data = PartyDatabase.GetMemberDataByID(memberID);
        if (data != null)
        {
            // 檢查是否已存在同類型的成員（可選，根據遊戲設計決定是否允許重複）
            // 為求簡單，此處允許玩家擁有多個同類型的成員
            MemberInstance newMember = new MemberInstance(memberID);
            AllMembers.Add(newMember);
            Debug.Log($"已將成員 [{data.memberName}] 加入到玩家的倉庫 (Holder)。");
            OnPartyUpdated?.Invoke(); // 觸發事件，通知UI刷新
        }
        else
        {
            Debug.LogWarning($"嘗試新增ID為 '{memberID}' 的成員失敗，在資料庫中找不到該成員。");
        }
    }

    // 將成員設置到戰鬥隊伍
    public void SetToBattleParty(MemberInstance member)
    {
        if (BattleParty.Count >= maxBattlePartySize)
        {
            Debug.LogWarning("戰鬥隊伍已滿，無法新增！");
            return;
        }
        if (!BattleParty.Contains(member) && AllMembers.Contains(member))
        {
            BattleParty.Add(member);
            OnPartyUpdated?.Invoke();
        }
    }

    // 從戰鬥隊伍中移除成員
    public void RemoveFromBattleParty(MemberInstance member)
    {
        if (BattleParty.Contains(member))
        {
            BattleParty.Remove(member);
            OnPartyUpdated?.Invoke();
        }
    }

    // 交換戰鬥成員的順序
    public void SwapBattlePartyOrder(int fromIndex, int toIndex)
    {
        if (fromIndex < 0 || fromIndex >= BattleParty.Count || toIndex < 0 || toIndex >= BattleParty.Count)
        {
            return;
        }
        MemberInstance temp = BattleParty[fromIndex];
        BattleParty[fromIndex] = BattleParty[toIndex];
        BattleParty[toIndex] = temp;
        OnPartyUpdated?.Invoke();
    }

    // 判斷是否有可戰鬥的成員
    public bool HasBattleReadyMembers()
    {
        return BattleParty.Any(member => member.currentHP > 0);
    }

    // 提供一個公開的方法讓外部系統可以請求UI刷新
    public void NotifyPartyUpdated()
    {
        Debug.Log("PartyManager 收到通知，正在觸發 OnPartyUpdated 事件。");
        OnPartyUpdated?.Invoke();
    }
    
    // 觸發存檔
    public void SaveParty()
    {
        JSONSaveManager.SavePartyData(AllMembers, BattleParty.Select(m => m.instanceID).ToList());
        Debug.Log("隊伍資料已儲存。");
    }

    // 觸發載入
    public void LoadParty()
    {
        PartySaveData saveData = JSONSaveManager.LoadPartyData();
        if (saveData != null)
        {
            AllMembers = saveData.AllMembers;
            
            // 根據存檔中的ID順序重建戰鬥隊伍
            BattleParty.Clear();
            foreach (string instanceId in saveData.BattlePartyInstanceIDs)
            {
                MemberInstance member = AllMembers.FirstOrDefault(m => m.instanceID == instanceId);
                if (member != null)
                {
                    BattleParty.Add(member);
                }
            }
            Debug.Log("隊伍資料已載入。");
            OnPartyUpdated?.Invoke();
        }
    }
}
```

---

### **JSON 儲存、讀取系統 (Persistence Layer)**

#### **1. JSONSaveManager.cs**
專門處理 JSON 序列化與檔案讀寫。

```csharp
using UnityEngine;
using System.IO;
using System.Collections.Generic;

// 一個輔助類，因為 Unity 的 JsonUtility 無法直接序列化根層級的 List
[System.Serializable]
public class PartySaveData
{
    public List<MemberInstance> AllMembers;
    public List<string> BattlePartyInstanceIDs; // 只儲存戰鬥隊伍的 instanceID 來重建
}

public static class JSONSaveManager
{
    private static readonly string fileName = "PartyData.json";

    // 獲取存檔路徑
    private static string GetSavePath()
    {
        return Path.Combine(Application.persistentDataPath, fileName);
    }

    // 儲存隊伍資料
    public static void SavePartyData(List<MemberInstance> allMembers, List<string> battlePartyInstanceIDs)
    {
        PartySaveData saveData = new PartySaveData
        {
            AllMembers = allMembers,
            BattlePartyInstanceIDs = battlePartyInstanceIDs
        };

        string json = JsonUtility.ToJson(saveData, true); // true 讓JSON格式化，方便閱讀
        File.WriteAllText(GetSavePath(), json);
    }

    // 載入隊伍資料
    public static PartySaveData LoadPartyData()
    {
        string path = GetSavePath();
        if (File.Exists(path))
        {
            string json = File.ReadAllText(path);
            PartySaveData saveData = JsonUtility.FromJson<PartySaveData>(json);

            // (可選) 資料驗證
            if (saveData != null && saveData.AllMembers != null)
            {
                // 移除在當前遊戲版本中已不存在的成員
                saveData.AllMembers.RemoveAll(instance => PartyDatabase.GetMemberDataByID(instance.memberDataSO_ID) == null);
            }

            return saveData;
        }
        else
        {
            Debug.Log("找不到存檔檔案，將創建新的隊伍資料。");
            return null;
        }
    }
}
```

---

### **隊伍UI (View Layer)**
以下腳本需要您在 Unity 編輯器中建立對應的 UI 元件並連結。

#### **1. MemberCardUI.cs (附加在 MemberCard Prefab 上)**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro; // 使用 TextMeshPro
using UnityEngine.EventSystems; // 引入事件系統

public class MemberCardUI : MonoBehaviour
{
    [SerializeField] private Image memberIconImage;
    [SerializeField] private TextMeshProUGUI memberNameText;
    [SerializeField] private Button cardButton;
    [SerializeField] private GameObject selectedBorder; // 用於顯示選中狀態的邊框
    [SerializeField] private GameObject inBattleIndicator; // 用於顯示在戰鬥隊伍中的標示

    private MemberInstance currentMember;

    // 填充卡片資料
    public void Setup(MemberInstance memberInstance, System.Action<MemberInstance> onClickCallback)
    {
        currentMember = memberInstance;

        // 從 BaseData 獲取靜態資訊
        memberNameText.text = currentMember.BaseData.memberName;
        memberIconImage.sprite = currentMember.BaseData.memberIcon;

        // 設定按鈕點擊事件
        cardButton.onClick.RemoveAllListeners();
        cardButton.onClick.AddListener(() => onClickCallback(currentMember));
    }

    // 更新卡片的視覺狀態
    public void UpdateVisualState(bool isSelected, bool isInBattleParty)
    {
        if (selectedBorder != null)
        {
            selectedBorder.SetActive(isSelected);
        }
        if (inBattleIndicator != null)
        {
            inBattleIndicator.SetActive(isInBattleParty);
        }
    }
}
```

#### **2. MemberStatCardUI.cs (附加在 MemberStatCard Prefab 上)**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class MemberStatCardUI : MonoBehaviour
{
    [Header("基礎連結")]
    [SerializeField] private Image memberIconImage;
    [SerializeField] private TextMeshProUGUI memberNameText;
    [SerializeField] private Button cardButton;
    [SerializeField] private GameObject selectedBorder;

    [Header("屬性連結")]
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI attackText;
    [SerializeField] private TextMeshProUGUI staminaText;
    [SerializeField] private TextMeshProUGUI attackRangeText;

    private MemberInstance currentMember;

    // 填充卡片資料，包含詳細屬性
    public void Setup(MemberInstance memberInstance, System.Action<MemberInstance> onClickCallback)
    {
        currentMember = memberInstance;
        MemberDataSO baseData = currentMember.BaseData;

        // 填充基礎資訊
        memberNameText.text = baseData.memberName;
        memberIconImage.sprite = baseData.memberIcon;

        // 填充戰鬥屬性
        hpText.text = $"HP: {currentMember.currentHP}/{currentMember.MaxHP}";
        attackText.text = $"ATK: {currentMember.CurrentAttack}";
        staminaText.text = $"體力: {currentMember.currentStamina}/{currentMember.MaxStamina}";
        attackRangeText.text = $"射程: {baseData.attackRange}";

        // 設定按鈕點擊事件
        cardButton.onClick.RemoveAllListeners();
        cardButton.onClick.AddListener(() => onClickCallback(currentMember));
    }

    // 更新卡片的視覺狀態
    public void UpdateVisualState(bool isSelected)
    {
        if (selectedBorder != null)
        {
            selectedBorder.SetActive(isSelected);
        }
    }
}
```

#### **3. PartyHolderUI.cs (全部成員倉庫)**

```csharp
using UnityEngine;
using System.Collections.Generic;

public class PartyHolderUI : MonoBehaviour
{
    [SerializeField] private GameObject holderPanel;
    [SerializeField] private Transform contentParent; // Scroll View 的 Content
    [SerializeField] private MemberCardUI cardPrefab;

    private List<MemberCardUI> spawnedCards = new List<MemberCardUI>();

    private void Awake()
    {
        if (holderPanel == null) holderPanel = this.gameObject; // 如果沒指定，就用掛載此腳本的物件
        holderPanel.SetActive(false);
    }

    private void OnEnable()
    {
        PartyManager.OnPartyUpdated += UpdateUI;
    }

    private void OnDisable()
    {
        PartyManager.OnPartyUpdated -= UpdateUI;

        if (PartyDetailUI.Instance != null)
        {
            PartyDetailUI.Instance.Hide();
        }
    }

    // 切換面板顯示/隱藏的方法
    public void TogglePanel()
    {
        bool isActive = !holderPanel.activeSelf;
        holderPanel.SetActive(isActive);

        // 只有在打開面板時才更新UI，節省效能
        if (isActive)
        {
            UpdateUI();
        }
    }

    private void UpdateUI()
    {
        // 清理舊的卡片
        foreach (var card in spawnedCards)
        {
            Destroy(card.gameObject);
        }
        spawnedCards.Clear();

        // 根據 PartyManager 的資料生成新卡片
        foreach (var member in PartyManager.Instance.AllMembers)
        {
            MemberCardUI newCard = Instantiate(cardPrefab, contentParent);
            newCard.Setup(member, OnMemberCardClicked);
            
            // 假設 PartyDetailUI 也是單例
            bool isSelected = PartyDetailUI.Instance != null && PartyDetailUI.Instance.IsShowingDetailsFor(member);
            bool isInBattle = PartyManager.Instance.BattleParty.Contains(member);
            newCard.UpdateVisualState(isSelected, isInBattle);
            
            spawnedCards.Add(newCard);
        }
    }

    private void OnMemberCardClicked(MemberInstance member)
    {
        // 通知詳細資料面板顯示
        PartyDetailUI.Instance.ShowMemberDetails(member);
        // 再次刷新UI以更新選中狀態
        UpdateUI(); 
    }
}
```

#### **4. PartyBattleUI.cs (戰鬥隊伍)**
(這個腳本只展示基礎顯示，拖曳功能較複雜，需要 `IDragHandler` 等接口，此處簡化為點擊)

```csharp
using UnityEngine;
using System.Collections.Generic;

public class PartyBattleUI : MonoBehaviour
{
    [SerializeField] private GameObject battlePanel;
    [SerializeField] private Transform battleSlotsParent; // 存放戰鬥隊伍卡片的容器
    
    // 將 Prefab 的類型從 MemberCardUI 改為 MemberStatCardUI
    [SerializeField] private MemberStatCardUI cardPrefab; 

    // 列表的類型也需要同步修改
    private List<MemberStatCardUI> spawnedCards = new List<MemberStatCardUI>();

    private void Awake()
    {
        if (battlePanel == null) battlePanel = this.gameObject; // 如果沒指定，就用掛載此腳本的物件
        battlePanel.SetActive(false);
    }

    private void OnEnable()
    {
        PartyManager.OnPartyUpdated += UpdateUI;
    }

    private void OnDisable()
    {
        PartyManager.OnPartyUpdated -= UpdateUI;

        if (PartyDetailUI.Instance != null)
        {
            PartyDetailUI.Instance.Hide();
        }
    }

    // 切換面板顯示/隱藏的方法
    public void TogglePanel()
    {
        bool isActive = !battlePanel.activeSelf;
        battlePanel.SetActive(isActive);

        if (isActive)
        {
            UpdateUI();
        }
    }

    private void UpdateUI()
    {
        foreach (var card in spawnedCards)
        {
            Destroy(card.gameObject);
        }
        spawnedCards.Clear();

        foreach (var member in PartyManager.Instance.BattleParty)
        {
            // 實例化新的 Prefab
            MemberStatCardUI newCard = Instantiate(cardPrefab, battleSlotsParent);
            newCard.Setup(member, OnMemberCardClicked);
            
            bool isSelected = PartyDetailUI.Instance != null && PartyDetailUI.Instance.IsShowingDetailsFor(member);
            
            // UpdateVisualState 不再需要 is_in_battle 參數
            newCard.UpdateVisualState(isSelected);
            
            spawnedCards.Add(newCard);
        }
    }

    private void OnMemberCardClicked(MemberInstance member)
    {
        // 點擊後依然是顯示最詳細的 PartyDetailUI 面板
        PartyDetailUI.Instance.ShowMemberDetails(member);
        
        // 為了更新所有卡片的選中框，手動觸發一次刷新
        UpdateUI();
    }
}
```

#### **5. PartyDetailUI.cs (成員詳細資料面板)**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class PartyDetailUI : MonoBehaviour
{
    public static PartyDetailUI Instance { get; private set; }
    
    [Header("UI 連結")]
    [SerializeField] private GameObject detailPanel;
    [SerializeField] private Image memberIcon;
    [SerializeField] private TextMeshProUGUI memberNameText;
    // *** 移除: [SerializeField] private TextMeshProUGUI levelText; ***
    // *** 移除: [SerializeField] private TextMeshProUGUI expText; ***
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI attackText;
    [SerializeField] private TextMeshProUGUI staminaText;
    [SerializeField] private TextMeshProUGUI attackRangeText;

    [Header("互動元件")]
    [SerializeField] private Button actionButton;
    [SerializeField] private TextMeshProUGUI actionButtonText;
    [SerializeField] private Button closeButton;

    private MemberInstance currentMember;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        
        detailPanel.SetActive(false);
        closeButton.onClick.AddListener(Hide);
    }

    public void ShowMemberDetails(MemberInstance member)
    {
        currentMember = member;
        detailPanel.SetActive(true);
        MemberDataSO baseData = member.BaseData; // 先獲取基礎資料，方便取用

        // 填充資料
        memberIcon.sprite = baseData.memberIcon;
        memberNameText.text = baseData.memberName;
        hpText.text = $"生命值: {member.currentHP} / {member.MaxHP}";
        attackText.text = $"攻擊力: {member.CurrentAttack}";
        staminaText.text = $"體力: {member.currentStamina} / {member.MaxStamina}";
        attackRangeText.text = $"攻擊距離: {baseData.attackRange}";

        // levelText.text = $"等級: {member.level}";
        // expText.text = $"經驗值: {member.experience} / 100"; 

        // 根據成員是否在戰鬥隊伍中，更新按鈕功能和文字 (此邏輯不變)
        bool isInBattleParty = PartyManager.Instance.BattleParty.Contains(member);
        if (isInBattleParty)
        {
            actionButtonText.text = "移除";
            actionButton.onClick.RemoveAllListeners();
            actionButton.onClick.AddListener(RemoveFromBattleParty);
        }
        else
        {
            actionButtonText.text = "上陣";
            actionButton.onClick.RemoveAllListeners();
            actionButton.onClick.AddListener(AddToBattleParty);
        }
    }

    public void Hide()
    {
        currentMember = null;
        detailPanel.SetActive(false);
        
        if (PartyManager.Instance != null)
        {
            PartyManager.Instance.NotifyPartyUpdated();
        }
    }
    
    public bool IsShowingDetailsFor(MemberInstance member)
    {
        return detailPanel.activeSelf && currentMember == member;
    }

    private void AddToBattleParty()
    {
        if (currentMember != null)
        {
            PartyManager.Instance.SetToBattleParty(currentMember);
            ShowMemberDetails(currentMember); // 重新調用以更新按鈕狀態
        }
    }

    private void RemoveFromBattleParty()
    {
        if (currentMember != null)
        {
            PartyManager.Instance.RemoveFromBattleParty(currentMember);
            ShowMemberDetails(currentMember); // 重新調用以更新按鈕狀態
        }
    }
}
```

### **總結與執行順序**

1.  **專案設置**:
    *   在 `Assets/Resources` 資料夾下創建一個 `PartyDatabase` ScriptableObject。
    *   使用 `Assets > Create > Party System > Member Data` 創建幾個 `MemberDataSO` 檔案，填寫好ID、名稱等資料。
    *   將創建好的 `MemberDataSO` 拖曳到 `PartyDatabase` 的 `allMembers` 列表中。

2.  **場景設置**:
    *   創建一個空的 GameObject，命名為 `SystemManagers`。
    *   將 `PartyManager.cs` 附加到 `SystemManagers` 上。
    *   創建 UI 畫布 (`Canvas`)。
    *   根據 `PartyHolderUI`, `PartyBattleUI`, `PartyDetailUI` 的設計，創建對應的 UI 元件（Scroll View, Layout Groups, Panels 等）。
    *   創建 `MemberCardUI` Prefab，並將其連結到 `PartyHolderUI` 的 `cardPrefab` 欄位。
    *   創建 `MemberStatCardUI` Prefab，並將其連結到 `PartyBattleUI` 的 `cardPrefab` 欄位。
    *   將 `PartyHolderUI.cs`, `PartyBattleUI.cs`, `PartyDetailUI.cs` 腳本分別附加到對應的 UI Panel 上，並在 Inspector 中連結所有必要的 UI 元素。

3.  **遊戲流程**:
    *   遊戲啟動時，`PartyManager` 的 `Awake` 會執行，`PartyDatabase` 會被載入並初始化。
    *   您可以通過腳本調用 `PartyManager.Instance.AddMemberToAllMembers("成員ID")` 來給予玩家初始成員。
    *   當 `AddMemberToAllMembers` 被調用時，它會觸發 `OnPartyUpdated` 事件。
    *   所有監聽此事件的 UI (`PartyHolderUI`, `PartyBattleUI`) 會自動執行它們的 `UpdateUI` 方法，刷新顯示內容。
    *   玩家點擊卡片，`PartyDetailUI` 顯示詳細資料和對應按鈕。
    *   點擊「上陣」/「卸下」按鈕，會調用 `PartyManager` 的方法，再次觸發 `OnPartyUpdated`，所有 UI 同步更新。
    *   在適當時機（例如離開隊伍介面或關閉遊戲），調用 `PartyManager.Instance.SaveParty()` 來存檔。
    *   遊戲啟動時，調用 `PartyManager.Instance.LoadParty()` 來讀取進度。