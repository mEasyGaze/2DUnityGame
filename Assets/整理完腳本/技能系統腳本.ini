### 技能系統：

1. SkillEnums.cs(技能字典)：
(1) 技能總體類型：[主動技能][被動技能][指揮官技能]
(2) 技能目標選擇：[無須目標][自己]、[敵方單體][敵方穿透][敵方全體]、[友方單體][友方全體]、[被動技能的擁有者][被動技能的所有隊友]
(3) 狀態效果：增傷、減傷、增體、減體耗、增血。

2. SkillData.cs (ScriptableObject)：
(1) 技能資料：包含獨一無二的`skillID`、名稱、圖標、描述。
(2) 核心規則定義：`技能類型`和`目標類型`。
(3) 消耗與限制：定義`體力消耗`和`施放距離`。
(4) 特殊標記：包含一個布林值 `isCommanderSkill_OneTimeUse`，用於標記此技能是否為一場戰鬥只能使用一次的指揮官技能。
(5) 效果列表：持有一個 `SkillEffect` 模板的列表，決定此技能會觸發哪些具體效果。

3. SkillDatabase.cs (ScriptableObject)：
(1) 統一存放：作為一個中央資料庫，存放遊戲中所有 `SkillData` 的引用。
(2) 全局查詢：提供一個全局靜態方法 `GetSkillDataByID()`，讓任何系統都能透過 ID 快速查詢到技能的原始數據。

4. SkillEffect.cs：
(1) 效果抽象：一個抽象基類，定義了所有技能效果的共同接口。
(2) 效果描述：設計一個欄位，方便開發者理解效果用途。

5. SkillEffect_Damage.cs (ScriptableObject)：
(1) 直接造成傷害效果。
(2) 持續造成傷害效果(狀態數值、狀態時常)。
(3) 攻擊數量：單體、穿透攻擊(穿透2人、穿透3人)。

6. SkillEffect_Heal.cs (ScriptableObject)：
(1) 直接造成回復效果。
(2) 持續造成回復效果(狀態數值、狀態時常)。
(3) 回復數量：單體、全體。

7. SkillEffect_ApplyBuff.cs (ScriptableObject)：
(1) 直接造成提升效果：增加攻擊、減少受到傷害、增加最大體力、減體力消耗、添加護盾。
(2) 狀態時長。
(3) Buff數量：單體、全體。

8. SkillManager.cs：
(1) 技能系統管理器，負責在遊戲啟動時載入並初始化`SkillDatabase`，確保技能數據隨時可用。

9. SkillSelectionPanel.cs：
(1) 技能選單，負責技能的選擇。

10. SkillButtonUI.cs (Prefabs)：
(1) 技能選單的按鈕。

11. BuffController.cs (Prefabs)：
(1) 單位附屬：作為一個組件，附加在每個單位身上。
(2) 狀態管理：管理該單位身上的所有持續性 Buff 和 Debuff。
(3) 回合更新與觸發：更新每回合 Buff 狀態(時間、效果)，和觸發持續性的 Buff 或 Debuff 效果。

12. BuffInstance.cs (Class)：
(1) 用於追蹤一個施加在單位身上的具體 Buff 實例（它從哪個技能來，還剩幾回合等）。

13. BuffManager.cs：
(1) 回合驅動：負責管理整個遊戲的BUFF驅動。
(2) 統一更新：更新所有 BuffController 的狀態。

---

### 技能系統核心結構

1. SkillEnums.cs：
```csharp
// 技能的總體類型
public enum SkillType
{
    Active,     // 主動技能
    Passive,    // 被動技能
    Commander   // 指揮官技能
}

// 技能的目標選擇邏輯
public enum SkillTargetType
{
    // --- 無目標或自動目標 ---
    None,               // 無需目標 (例如，一個只對自己生效的Buff)
    Self,               // 僅自己

    // --- 攻擊型目標 ---
    Enemy_Single,       // 敵方單體
    Enemy_Penetrate,    // 敵方穿透 (前衛 & 遠1)
    Enemy_All,          // 敵方全體 (除後勤)

    // --- 友方目標 ---
    Ally_Single,        // 友方單體
    Ally_All,           // 友方全體 (除後勤)

    // --- 被動觸發目標 (暫時定義，待被動系統實作時使用) ---
    Passive_Owner,      // 被動技能的擁有者
    Passive_AllAllies   // 被動技能的所有隊友
}

// 狀態效果（Buff/Debuff）的具體類型
public enum BuffType
{
    // --- 增益效果 (Buffs) ---
    IncreaseAttack_Value,   // 增加固定數值的攻擊力
    IncreaseAttack_Percent, // 增加百分比的攻擊力
    IncreaseDefense_Value,  // 增加固定數值的防禦力（減傷）
    IncreaseDefense_Percent,// 增加百分比的防禦力（減傷）
    AddShield,              // 添加一個臨时的護盾值
    HealOverTime,           // 持續回血 (HOT)

    // --- 減益效果 (Debuffs) ---
    DecreaseAttack_Value,   // 降低固定數值的攻擊力
    DecreaseAttack_Percent, // 降低百分比的攻擊力
    DecreaseDefense_Value,  // 降低固定數值的防禦力（破甲）
    DecreaseDefense_Percent,// 降低百分比的防禦力（破甲）
    DamageOverTime,         // 持續傷害 (DOT)
    Stun,                   // 暈眩 (無法行動)
}
```

2. SkillData.cs：
```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewSkill", menuName = "Skill System/Skill Data")]
public class SkillData : ScriptableObject
{
    [Header("基礎資訊")]
    public string skillID;
    public string skillName;
    public Sprite skillIcon;
    [TextArea(3, 5)]
    public string skillDescription;

    [Header("核心規則")]
    public SkillType skillType;
    public SkillTargetType targetType;

    [Header("消耗與限制 (主動/指揮官技能)")]
    [Tooltip("施放此技能需要消耗的體力值。")]
    public int staminaCost;
    [Tooltip("如果是指揮官技能，將此設為 True。")]
    public bool isCommanderSkill_OneTimeUse;
    [Tooltip("施放此技能的最大距離。0 代表無距離限制。")]
    public int range;

    [Header("技能效果列表")]
    [Tooltip("將此技能會觸發的所有效果 (SkillEffect) 模板拖曳至此。")]
    public List<SkillEffect> effects;
}
```

3. SkillDatabase.cs：
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "SkillDatabase", menuName = "Party System/Skill Database")]
public class SkillDatabase : ScriptableObject
{
    public List<SkillData> allSkills;

    private Dictionary<string, SkillData> skillDictionary;
    private bool isInitialized = false;

    private void OnEnable()
    {
        isInitialized = false;
    }

    public void Initialize()
    {
        if (isInitialized) return;

        if (allSkills == null)
        {
            allSkills = new List<SkillData>();
        }

        skillDictionary = allSkills.ToDictionary(skill => skill.skillID, skill => skill);
        foreach (var skill in allSkills)
        {
            if (skill != null && !skillDictionary.ContainsKey(skill.skillID))
            {
                skillDictionary.Add(skill.skillID, skill);
            }
            else
            {
                Debug.LogWarning($"技能資料庫中發現重複或空的技能ID: {skill?.skillID}");
            }
        }
        isInitialized = true;
    }

    public SkillData GetSkillDataByID(string id)
    {
        if (!isInitialized)
        {
            Debug.LogError("SkillDatabase 尚未初始化！請確保 SkillManager 已運行。");
            return null;
        }

        if (skillDictionary.TryGetValue(id, out SkillData data))
        {
            return data;
        }
        else
        {
            return null;
        }
    }
}
```

4. SkillEffect.cs：
```csharp
using UnityEngine;
using System.Collections.Generic;

public abstract class SkillEffect : ScriptableObject
{
    [Header("效果描述")]
    [TextArea] 
    [Tooltip("這個效果的內部描述，方便開發者理解其作用。")]
    public string effectDescription;
    
    // 這是所有子類都必須實現的核心方法。
    // source: 技能的施放者。
    // targets: 所有被技能影響的目標單位列表。
    // battleManager: 用於訪問戰鬥場景的全局狀態和物件。
    public abstract void Execute(IBattleUnit_ReadOnly source, List<IBattleUnit_ReadOnly> targets, BattleManager battleManager);
}
```

### 技能效果

5. SkillEffect_Damage.cs：
```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "DamageEffect", menuName = "Skill System/Effects/Damage")]
public class SkillEffect_Damage : SkillEffect
{
    [Header("傷害設定")]
    [Tooltip("技能造成的基礎傷害值。")]
    public int baseDamage;
    [Tooltip("勾選後，傷害會額外加上施法者攻擊力的一定比例。")]
    public bool scalesWithAttack;
    [Tooltip("攻擊力的加成比例。1.0 代表 100% 的攻擊力。")]
    public float attackScalingFactor = 1.0f;

    public override void Execute(IBattleUnit_ReadOnly source, List<IBattleUnit_ReadOnly> targets, BattleManager battleManager)
    {
        foreach (var target in targets)
        {
            if (target == null || target.IsDead) continue;

            int totalDamage = baseDamage;
            if (scalesWithAttack && source != null)
            {
                totalDamage += Mathf.RoundToInt(source.CurrentAttack * attackScalingFactor);
            }
            target.GetMonoBehaviour().TakeDamage(totalDamage);
            BattleLog.Instance.AddLog($"{source.UnitName} 的技能對 {target.UnitName} 造成了 {totalDamage} 點傷害！");
        }
    }
}
```

6. SkillEffect_Heal.cs：
```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "HealEffect", menuName = "Skill System/Effects/Heal")]
public class SkillEffect_Heal : SkillEffect
{
    [Header("治療設定")]
    [Tooltip("技能提供的基礎治療量。")]
    public int healAmount;

    public override void Execute(IBattleUnit_ReadOnly source, List<IBattleUnit_ReadOnly> targets, BattleManager battleManager)
    {
        foreach (var target in targets)
        {
            if (target == null || target.IsDead) continue;

            target.GetMonoBehaviour().Heal(healAmount);
            BattleLog.Instance.AddLog($"{source.UnitName} 的技能使 {target.UnitName} 恢復了 {healAmount} 點生命！");
        }
    }
}
```

7. SkillEffect_ApplyBuff.cs：
```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class BuffDefinition
{
    [Tooltip("要施加的狀態效果類型。")]
    public BuffType Type;

    [Tooltip("效果的數值。對於百分比類型，0.2 代表 20%。對於固定值，代表具體數值。")]
    public float Value;

    [Tooltip("效果的持續回合數。0 代表立即生效，1 代表持續到下回合開始前。")]
    public int Duration;
}

[CreateAssetMenu(fileName = "ApplyBuffEffect", menuName = "Skill System/Effects/Apply Buff")]
public class SkillEffect_ApplyBuff : SkillEffect
{
    [Header("Buff 設定")]
    [Tooltip("此技能效果會施加的所有 Buff/Debuff 列表。")]
    public List<BuffDefinition> BuffsToApply;

    [Header("指揮官被動光環")]
    [Tooltip("如果這是一個指揮官被動技能提供的、持續生效的光環效果，請勾選此項。")]
    public bool isCommanderPassiveAura = false;

    public override void Execute(IBattleUnit_ReadOnly source, List<IBattleUnit_ReadOnly> targets, BattleManager battleManager)
    {
        foreach (var target in targets)
        {
            if (target == null || target.IsDead) continue;

            var buffController = target.GetMonoBehaviour().GetComponent<BuffController>();
            if (buffController == null) continue;

            foreach (var buffDef in BuffsToApply)
            {
                buffController.ApplyBuff(buffDef, source);
            }
        }
    }
}
```

### 技能管理器

8. SkillManager.cs：
```csharp
using UnityEngine;
using UnityEngine.SceneManagement;

public class SkillManager : MonoBehaviour
{
    public static SkillManager Instance { get; private set; }

    [Header("資料庫引用")]
    [SerializeField] private SkillDatabase skillDatabase;

    public SkillDatabase Database => skillDatabase;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            SceneManager.sceneLoaded += OnSceneLoaded;
            InitializeManager();
        }
        else if (Instance != this)
        {
            Destroy(gameObject);
        }
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        InitializeManager();
    }

    private void InitializeManager()
    {
        if (skillDatabase == null)
        {
            skillDatabase = Resources.Load<SkillDatabase>("SkillDatabase");
            
            if (skillDatabase == null)
            {
                Debug.LogError("SkillManager 無法找到 SkillDatabase！請在 Inspector 中指定它，或將其放置在 'Resources' 文件夾下。");
                return;
            }
        }
        skillDatabase.Initialize(); 
        Debug.Log("SkillManager 已成功初始化 SkillDatabase。");
    }

    private void OnDestroy()
    {
        if (Instance == this)
        {
            SceneManager.sceneLoaded -= OnSceneLoaded;
        }
    }
}
```

### 技能面板

9. SkillSelectionPanel.cs：
```csharp
using UnityEngine;
using System.Collections.Generic;

public class SkillSelectionPanelUI : MonoBehaviour
{
    [Header("UI 參考")]
    [SerializeField] private GameObject panel;
    [SerializeField] private Transform buttonContainer;
    [SerializeField] private SkillButtonUI buttonPrefab;

    private List<SkillButtonUI> spawnedButtons = new List<SkillButtonUI>();

    void Awake()
    {
        if (panel == null) panel = this.gameObject;
        panel.SetActive(false);
    }

    public void ShowPanel(Dictionary<SkillData, bool> skillFeasibility, System.Action<SkillData> onSkillSelectedCallback)
    {
        ClearButtons();

        if (skillFeasibility == null || skillFeasibility.Count == 0)
        {
            BattleLog.Instance.AddLog("此單位沒有可用的技能。");
            return;
        }

        foreach (var pair in skillFeasibility)
        {
            SkillData skill = pair.Key;
            bool isUsable = pair.Value;

            SkillButtonUI newButton = Instantiate(buttonPrefab, buttonContainer);
            
            System.Action<SkillData> wrappedCallback = (selectedSkill) => {
                onSkillSelectedCallback(selectedSkill);
                HidePanel();
            };
            
            newButton.Setup(skill, isUsable, wrappedCallback);
            spawnedButtons.Add(newButton);
        }

        panel.SetActive(true);
    }

    public void HidePanel()
    {
        panel.SetActive(false);
        ClearButtons();
    }

    private void ClearButtons()
    {
        foreach (var btn in spawnedButtons)
        {
            if (btn != null) Destroy(btn.gameObject);
        }
        spawnedButtons.Clear();
    }
}
```

### 技能按鈕 Prefab

10. SkillButtonUI.cs：
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class SkillButtonUI : MonoBehaviour
{
    [SerializeField] private Button button;
    [SerializeField] private TextMeshProUGUI skillNameText;
    [SerializeField] private Image skillIcon;

    public void Setup(SkillData skill, bool isUsable, System.Action<SkillData> onClickCallback)
    {
        if (skillNameText != null) skillNameText.text = skill.skillName;
        if (skillIcon != null)
        {
            skillIcon.sprite = skill.skillIcon;
            skillIcon.enabled = (skill.skillIcon != null);
        }

        button.onClick.RemoveAllListeners();
        button.onClick.AddListener(() => {
            onClickCallback(skill);
        });
        button.interactable = isUsable;
    }
}
```

11. BuffController.cs：
```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class BuffController : MonoBehaviour
{
    private BattleUnit owner;
    private readonly List<BuffInstance> activeBuffs = new List<BuffInstance>();
    private readonly List<BuffInstance> activeAuras = new List<BuffInstance>();
    public float CurrentShield { get; private set; }

    void Awake()
    {
        owner = GetComponent<BattleUnit>();
    }

    public void ApplyBuff(BuffDefinition definition, IBattleUnit_ReadOnly source)
    {
        if (definition.Type == BuffType.AddShield)
        {
            CurrentShield += definition.Value;
            BattleLog.Instance.AddLog($"{owner.UnitName} 獲得了 {Mathf.RoundToInt(definition.Value)} 點護盾！");
            return;
        }
        BuffInstance newBuff = new BuffInstance(definition, source);
        activeBuffs.Add(newBuff);
        BattleLog.Instance.AddLog($"{owner.UnitName} 獲得了 [{definition.Type}] 效果！");
    }

    public void ClearShield()
    {
        CurrentShield = 0;
    }

    public int AbsorbDamage(int incomingDamage)
    {
        if (CurrentShield <= 0) return 0;

        float damageToAbsorb = Mathf.Min(incomingDamage, CurrentShield);

        CurrentShield -= damageToAbsorb;
        
        int absorbedAmount = Mathf.RoundToInt(damageToAbsorb);

        if (absorbedAmount > 0)
        {
            BattleLog.Instance.AddLog($"{owner.UnitName} 的護盾吸收了 {absorbedAmount} 點傷害。");
        }
        return absorbedAmount;
    }

    public void ApplyAura(BuffDefinition definition, IBattleUnit_ReadOnly source)
    {
        BuffInstance newAura = new BuffInstance(definition, source);
        activeAuras.Add(newAura);
    }

    public void ClearAllAuras()
    {
        activeAuras.Clear();
    }

    public void TickAllBuffs()
    {
        foreach (var buff in activeBuffs)
        {
            if (buff.IsExpired()) continue;
            if (buff.Definition.Type == BuffType.HealOverTime)
            {
                int healAmount = Mathf.RoundToInt(buff.Definition.Value);
                owner.Heal(healAmount); 
                BattleLog.Instance.AddLog($"{owner.UnitName} 因 [持續治療] 效果恢復了 {healAmount} 點生命。");
            }
            else if (buff.Definition.Type == BuffType.DamageOverTime)
            {
                int dotDamage = Mathf.RoundToInt(buff.Definition.Value);
                owner.TakeDamage(dotDamage);
                BattleLog.Instance.AddLog($"{owner.UnitName} 因 [持續傷害] 效果受到了 {dotDamage} 點傷害。");
            }
        }

        for (int i = activeBuffs.Count - 1; i >= 0; i--)
        {
            activeBuffs[i].Tick();
            if (activeBuffs[i].IsExpired())
            {
                BattleLog.Instance.AddLog($"{owner.UnitName} 身上的 [{activeBuffs[i].Definition.Type}] 效果消失了。");
                activeBuffs.RemoveAt(i);
            }
        }
    }

    public float GetBuffValue(BuffType type)
    {
        float timedBuffValue = activeBuffs
            .Where(b => b.Definition.Type == type && !b.IsExpired())
            .Sum(b => b.Definition.Value);
        float auraBuffValue = activeAuras
            .Where(a => a.Definition.Type == type)
            .Sum(a => a.Definition.Value);
        return timedBuffValue + auraBuffValue;
    }
    
    public bool HasBuff(BuffType type)
    {
        return activeBuffs.Any(b => b.Definition.Type == type && !b.IsExpired()) || activeAuras.Any(a => a.Definition.Type == type);
    }
}
```

12. BuffInstance.cs：
```csharp
public class BuffInstance
{
    public BuffDefinition Definition { get; }
    public int RemainingDuration { get; private set; }
    public IBattleUnit_ReadOnly Source { get; }

    public BuffInstance(BuffDefinition definition, IBattleUnit_ReadOnly source)
    {
        Definition = definition;
        RemainingDuration = definition.Duration;
        Source = source;
    }

    public void Tick()
    {
        if (RemainingDuration > 0)
        {
            RemainingDuration--;
        }
    }

    public bool IsExpired()
    {
        return RemainingDuration <= 0;
    }
}
```

13. BuffManager.cs：
```csharp
using System.Collections.Generic;
using UnityEngine;

public class BuffManager : MonoBehaviour
{
    public static BuffManager Instance { get; private set; }

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
    public void TickAllBuffsOnAllUnits(List<BattleUnit> allUnits)
    {
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                var controller = unit.GetComponent<BuffController>();
                if (controller != null)
                {
                    controller.TickAllBuffs();
                }
            }
        }
    }
}
```