
好的，這是一個非常清晰且完整的戰鬥系統設計。延續之前的隊伍系統框架，我們現在來建構這個回合制戰鬥系統的程式碼。

我會按照您提供的結構，逐步完成每個腳本。

---

### **戰鬥系統核心資料結構 (資料層)**

#### **1. BattleEnums.cs (遊戲字典)**
這個腳本不繼承 `MonoBehaviour`，只是一個存放枚舉的檔案。

```csharp
// BattleEnums.cs

// 戰鬥中的角色職責
public enum BattleRole
{
    Vanguard,   // 前衛
    Ranged1,    // 遠1
    Ranged2,    // 遠2
    Support     // 後勤
}

// 玩家可執行的行動類型
public enum ActionType
{
    Attack,         // 攻擊
    Defend,         // 防禦
    Rest,           // 休息
    Skill,          // 技能
    Item,           // 道具
    SwapPosition,   // 交換位置
    CommanderSkill, // 指揮官技能
    EndTurn         // 結束回合
}

// 回合管理器的狀態
public enum TurnState
{
    BattleStart,        // 戰鬥開始
    PlayerPlanning,     // 玩家規劃階段
    PlayerTargeting,    // 玩家選擇目標階段
    ActionExecution,    // 行動執行階段
    EnemyTurn,          // 敵人回合
    BattleVictory,      // 戰鬥勝利
    BattleDefeat        // 戰鬥失敗
}
```

#### **2. EnemyDataSO.cs (ScriptableObject)**
直接複製 `MemberDataSO`，並稍作修改以符合「敵人」的語意。

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "NewEnemyData", menuName = "Battle System/Enemy Data")]
public class EnemyDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string enemyID; // 敵人ID (獨一無二的編號)
    public string enemyName; // 敵人名稱
    public Sprite enemyIcon; // 敵人圖像 (或3D模型引用)

    [Header("基礎屬性")]
    public int baseHealth; // 基礎血量
    public int baseAttack; // 基礎攻擊力
    public int baseStamina; // 體力
    public int attackRange; // 攻擊距離

    // 敵人通常沒有複雜的成長規則，但可以保留以備擴充
    // public int healthPerLevel;
    // public int attackPerLevel;
}
```

#### **3. BattleEncounterSO.cs (ScriptableObject)**
戰鬥遭遇的配置檔案。

```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class EnemySpawnInfo
{
    public EnemyDataSO enemyData;
    public BattleRole initialPosition;
}

[CreateAssetMenu(fileName = "NewBattleEncounter", menuName = "Battle System/Battle Encounter")]
public class BattleEncounterSO : ScriptableObject
{
    [Header("敵人配置")]
    public List<EnemySpawnInfo> enemySpawns;

    [Header("勝利獎勵")]
    public int moneyReward;
    public List<ItemDropInfo> itemDrops; // 假設有一個 ItemDropInfo 類別

    // 可以在這裡加入方法來計算最終獎勵，例如根據掉落率
    public List<string> GetFinalItemDrops()
    {
        // 根據 itemDrops 中的機率計算實際掉落的道具
        // 這裡僅為範例，返回所有可能的道具名稱
        List<string> droppedItems = new List<string>();
        foreach (var drop in itemDrops)
        {
            // if (Random.value <= drop.dropChance)
            // {
            //     droppedItems.Add(drop.itemName);
            // }
        }
        return droppedItems;
    }
}

// 範例：道具掉落資訊
[System.Serializable]
public class ItemDropInfo
{
    public string itemName;
    public float dropChance; // 掉落機率 (0.0 to 1.0)
}
```

#### **4. ActionPlan.cs (可序列化 Class)**
儲存單一行動指令的資料容器。

```csharp
[System.Serializable]
public class ActionPlan
{
    public BattleUnit Actor;        // 行動發起者
    public ActionType ActionType;   // 行動類型
    public BattleUnit Target;       // 行動目標 (可以是自己或敵人)
    public int ActionSlotIndex;     // 該行動在哪一個行動格

    public ActionPlan(BattleUnit actor, ActionType actionType, BattleUnit target, int slotIndex)
    {
        this.Actor = actor;
        this.ActionType = actionType;
        this.Target = target;
        this.ActionSlotIndex = slotIndex;
    }
}
```

#### **5. ActionSlot.cs (可序列化 Class)**
代表一個行動格的資料結構。

```csharp
[System.Serializable]
public class ActionSlot
{
    // 一個行動格可能包含多個角色的行動，這裡根據設計簡化
    // 假設前衛和遠程的行動是分開記錄的
    public ActionPlan VanguardAction;
    public ActionPlan RangedAction;

    public void Clear()
    {
        VanguardAction = null;
        RangedAction = null;
    }
}
```

---

### **Prefab (預製件)**

#### **1. BattleUnit.cs**
附加在戰鬥單位 Prefab 上的核心腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class BattleUnit : MonoBehaviour, IPointerClickHandler
{
    [Header("狀態")]
    public MemberInstance MemberData; // 玩家成員資料
    public EnemyDataSO EnemyData;     // 敵人資料
    public BattleRole Role;           // 當前職責
    public int CurrentHP;
    public int CurrentStamina;

    [Header("視覺回饋")]
    [SerializeField] private HealthUI healthUI;
    [SerializeField] private GameObject targetableIndicator; // 可被選為目標的提示框

    [Header("視覺元件")]
    [SerializeField] private SpriteRenderer characterSpriteRenderer; // 如果角色是場景中的 Sprite
    [SerializeField] private Image characterUIImage; // 如果角色是畫布上的 Image

    // 事件，通知UI管理器自己被點擊了
    public static event System.Action<BattleUnit> OnUnitClicked;

    // 初始化玩家單位
    public void Initialize(MemberInstance memberInstance, BattleRole role)
    {
        this.MemberData = memberInstance;
        this.EnemyData = null;
        this.Role = role;

        // 我們需要確保 memberInstance.BaseData 不是 null
        if (memberInstance.BaseData == null)
        {
            Debug.LogError($"初始化 BattleUnit 失敗：ID 為 '{memberInstance.memberDataSO_ID}' 的成員無法從 PartyDatabase 中找到基礎資料！");
            this.name = $"Player_INVALID_DATA_{role}";
            return; // 直接返回，避免後續錯誤
        }

        this.name = $"Player_{memberInstance.BaseData.memberName}_{role}";

        CurrentHP = memberInstance.currentHP;
        CurrentStamina = memberInstance.BaseData.baseStamina;
        
        // 設定角色圖像
        if (characterSpriteRenderer != null)
        {
            characterSpriteRenderer.sprite = memberInstance.BaseData.memberIcon;
        }
        if (characterUIImage != null)
        {
            characterUIImage.sprite = memberInstance.BaseData.memberIcon;
        }
        
        if (healthUI != null)
        {
            healthUI.TrackUnit(this);
        }
    }

    // 初始化敵人單位
    public void Initialize(EnemyDataSO enemyData, BattleRole role)
    {
        this.MemberData = null;
        this.EnemyData = enemyData;
        this.Role = role;
        this.name = $"Enemy_{enemyData.enemyName}_{role}";

        CurrentHP = enemyData.baseHealth;
        CurrentStamina = enemyData.baseStamina;

        // 設定敵人圖像
        if (characterSpriteRenderer != null)
        {
            characterSpriteRenderer.sprite = enemyData.enemyIcon;
        }
        if (characterUIImage != null)
        {
            characterUIImage.sprite = enemyData.enemyIcon;
        }
        
        if (healthUI != null)
        {
            healthUI.TrackUnit(this);
        }
    }

    // 接受傷害
    public void TakeDamage(int amount)
    {
        CurrentHP -= amount;
        if (CurrentHP < 0) CurrentHP = 0;
        // 可以在此處觸發傷害數字顯示、血條更新等事件
        Debug.Log($"{this.name} 受到 {amount} 點傷害, 剩餘HP: {CurrentHP}");

        if (CurrentHP <= 0)
        {
            Die();
        }
    }

    // 單位死亡
    private void Die()
    {
        Debug.Log($"{this.name} 已陣亡。");
        // 觸發死亡動畫、從戰鬥列表中移除等
        gameObject.SetActive(false); // 簡單處理
    }
    
    // 變更位置 (邏輯由 BattleManager 或 BattleRules 處理，此處只更新自身狀態)
    public void SetNewRole(BattleRole newRole)
    {
        this.Role = newRole;
        // 可能需要更新UI標籤或位置
    }

    // 顯示或隱藏「可被選為目標」的提示
    public void SetTargetable(bool isTargetable)
    {
        if (targetableIndicator != null)
        {
            targetableIndicator.SetActive(isTargetable);
        }
    }

    // 當滑鼠點擊此單位時觸發
    public void OnPointerClick(PointerEventData eventData)
    {
        Debug.Log($"{this.name} 被點擊了！");
        OnUnitClicked?.Invoke(this);
    }
}
```

#### **2. ActionButtonUI.cs (萬用按鈕)**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionButtonUI : MonoBehaviour
{
    [SerializeField] private Image iconImage;
    [SerializeField] private TextMeshProUGUI nameText;
    [SerializeField] private Button button;

    private ActionType associatedAction;
    private System.Action<ActionType> onClickCallback;

    public void Setup(ActionType action, string text, Sprite icon, System.Action<ActionType> callback)
    {
        associatedAction = action;
        nameText.text = text;
        iconImage.sprite = icon;
        onClickCallback = callback;
        
        button.onClick.RemoveAllListeners();
        button.onClick.AddListener(OnButtonClicked);
    }

    private void OnButtonClicked()
    {
        onClickCallback?.Invoke(associatedAction);
    }
}
```

#### **3. ActionSlotUI.cs**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionSlotUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject vanguardActionContainer; // 裝前衛行動資訊的容器
    [SerializeField] private TextMeshProUGUI vanguardActionText; // 顯示前衛行動名稱
    // [SerializeField] private Image vanguardActionIcon; // 未來可擴充顯示圖示

    [SerializeField] private GameObject rangedActionContainer; // 裝遠程行動資訊的容器
    [SerializeField] private TextMeshProUGUI rangedActionText; // 顯示遠程行動名稱
    // [SerializeField] private Image rangedActionIcon; // 未來可擴充顯示圖示
    
    [SerializeField] private GameObject highlightBorder; // 用於高亮顯示的邊框

    private void Awake()
    {
        // 初始時先清空顯示
        ClearDisplay();
    }

    // 根據傳入的行動格資料更新顯示
    public void UpdateDisplay(ActionSlot slotData)
    {
        // 更新前衛行動顯示
        if (slotData != null && slotData.VanguardAction != null)
        {
            vanguardActionContainer.SetActive(true);
            // 簡單顯示行動類型，未來可以更換成技能名稱
            vanguardActionText.text = slotData.VanguardAction.ActionType.ToString();
        }
        else
        {
            vanguardActionContainer.SetActive(false);
        }

        // 更新遠程行動顯示
        if (slotData != null && slotData.RangedAction != null)
        {
            rangedActionContainer.SetActive(true);
            rangedActionText.text = slotData.RangedAction.ActionType.ToString();
        }
        else
        {
            rangedActionContainer.SetActive(false);
        }
    }

    // 清空所有顯示
    public void ClearDisplay()
    {
        if (vanguardActionContainer != null) vanguardActionContainer.SetActive(false);
        if (rangedActionContainer != null) rangedActionContainer.SetActive(false);
        if (highlightBorder != null) highlightBorder.SetActive(false); // 順便關閉高亮
    }

    // 設定是否高亮顯示此行動格
    public void SetHighlight(bool isHighlighted)
    {
        if (highlightBorder != null)
        {
            highlightBorder.SetActive(isHighlighted);
        }
    }
}
```

#### **4. HealthUI.cs (血條)**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HealthUI : MonoBehaviour
{
    [SerializeField] private Slider healthSlider;
    [SerializeField] private TextMeshProUGUI hpText;

    private BattleUnit targetUnit;

    public void TrackUnit(BattleUnit unit)
    {
        targetUnit = unit;
        UpdateHealthDisplay();
    }

    void Update()
    {
        // 為了效能，最好是事件驅動，但Update是簡單的實現方式
        if (targetUnit != null && targetUnit.gameObject.activeInHierarchy)
        {
            UpdateHealthDisplay();
        }
    }

    private void UpdateHealthDisplay()
    {
        int maxHP = 0;
        if (targetUnit.MemberData != null)
        {
            maxHP = targetUnit.MemberData.MaxHP;
        }
        else if (targetUnit.EnemyData != null)
        {
            maxHP = targetUnit.EnemyData.baseHealth;
        }

        if (maxHP > 0)
        {
            healthSlider.value = (float)targetUnit.CurrentHP / maxHP;
            hpText.text = $"{targetUnit.CurrentHP} / {maxHP}";
        }
    }
}
```

#### **5. BattleTrigger.cs (戰鬥觸發器)**

```csharp
using UnityEngine;

[RequireComponent(typeof(Collider2D))]
public class BattleTrigger : MonoBehaviour
{
    [SerializeField] private BattleEncounterSO encounterData;

    private void Awake()
    {
        // 確保碰撞體被設定為觸發器
        GetComponent<Collider2D>().isTrigger = true;
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            if (encounterData == null)
            {
                Debug.LogError($"BattleTrigger '{gameObject.name}' 沒有設定 BattleEncounterSO！");
                return;
            }
            
            Debug.Log($"玩家觸碰了戰鬥觸發器，遭遇戰鬥: {encounterData.name}");
            
            // GameManager 會處理場景切換和資料傳遞，確保玩家的隊伍資料被帶入戰鬥場景
            GameManager.Instance.StartBattle(encounterData);
            gameObject.SetActive(false);
        }
    }
}
```

---

### **UI (使用者介面)**
這些UI腳本主要由 `BattleUIManager` 控制。

#### **1. ActionPanelUI.cs (行動按鈕面板)**

```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionPanelUI : MonoBehaviour
{
    [SerializeField] private Transform buttonContainer;
    [SerializeField] private ActionButtonUI buttonPrefab;

    // 清理所有按鈕
    private void ClearButtons()
    {
        foreach (Transform child in buttonContainer)
        {
            Destroy(child.gameObject);
        }
    }

    // 根據角色職責顯示對應的行動按鈕
    public void ShowActionsForRole(BattleRole role, System.Action<ActionType> onActionSelected)
    {
        ClearButtons();
        gameObject.SetActive(true);

        List<ActionType> availableActions = BattleRules.GetAvailableActionsForRole(role);

        foreach (var action in availableActions)
        {
            ActionButtonUI newButton = Instantiate(buttonPrefab, buttonContainer);
            // 這裡應從資料庫獲取按鈕的文字和圖示，暫用枚舉名稱
            newButton.Setup(action, action.ToString(), null, onActionSelected);
        }
    }

    public void Hide()
    {
        gameObject.SetActive(false);
    }
}
```

#### **2. ActionSlotPanelUI.cs (戰術規劃板)**

```csharp
using UnityEngine;

public class ActionSlotPanelUI : MonoBehaviour
{
    // 假設有4個行動格的UI元件陣列
    [SerializeField] private ActionSlotUI[] actionSlotUIs;

    public void UpdateSlots(ActionSlot[] plannedSlots)
    {
        for (int i = 0; i < actionSlotUIs.Length; i++)
        {
            if (i < plannedSlots.Length)
            {
                actionSlotUIs[i].UpdateDisplay(plannedSlots[i]);
            }
            else
            {
                actionSlotUIs[i].ClearDisplay();
            }
        }
    }

    public void HighlightSlot(int index)
    {
        for (int i = 0; i < actionSlotUIs.Length; i++)
        {
            actionSlotUIs[i].SetHighlight(i == index);
        }
    }
}
```

#### **3. BattleEndUI.cs (戰鬥結算)**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BattleEndUI : MonoBehaviour
{
    [SerializeField] private GameObject victoryPanel;
    [SerializeField] private TextMeshProUGUI victoryRewardText;
    [SerializeField] private Button victoryExitButton;

    [SerializeField] private GameObject defeatPanel;
    [SerializeField] private Button defeatExitButton;

    private void Awake()
    {
        victoryExitButton.onClick.AddListener(OnExitButtonClicked);
        defeatExitButton.onClick.AddListener(OnExitButtonClicked);
        gameObject.SetActive(false);
    }

    public void ShowVictory(int money, System.Collections.Generic.List<string> items)
    {
        gameObject.SetActive(true);
        victoryPanel.SetActive(true);
        defeatPanel.SetActive(false);
        victoryRewardText.text = $"獲得金錢: {money}\n獲得道具: {string.Join(", ", items)}";
    }

    public void ShowDefeat()
    {
        gameObject.SetActive(true);
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(true);
    }

    private void OnExitButtonClicked()
    {
        // 通知 GameManager 結束戰鬥並返回
        GameManager.Instance.EndBattle();
    }
}
```

#### **4. BattleLog.cs (戰鬥日誌)**

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Text;

public class BattleLog : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI logText;
    [SerializeField] private ScrollRect scrollRect;
    private StringBuilder logBuilder = new StringBuilder();

    public static BattleLog Instance { get; private set; }
    
    private void Awake()
    {
        Instance = this;
    }

    public void Initialize()
    {
        logBuilder.Clear();
        logBuilder.AppendLine("--- 戰鬥開始 ---");
        UpdateLogDisplay();
    }

    public void AddEntry(string message)
    {
        logBuilder.AppendLine(message);
        UpdateLogDisplay();
    }

    private void UpdateLogDisplay()
    {
        logText.text = logBuilder.ToString();
        // 自動滾動到底部
        Canvas.ForceUpdateCanvases();
        scrollRect.verticalNormalizedPosition = 0f;
    }
}
```

#### **5. BattleUI.cs (戰鬥場景UI總集)**

```csharp
using UnityEngine;
using UnityEngine.UI;

public class BattleUI : MonoBehaviour
{
    [SerializeField] private Button cancelButton;
    [SerializeField] private Button endTurnButton; // 回合結束按鈕的引用

    private void Awake()
    {
        // 綁定取消按鈕的事件
        if (cancelButton != null)
        {
            cancelButton.onClick.AddListener(() => {
                if (TurnManager.Instance != null)
                {
                    TurnManager.Instance.CancelTargetSelection();
                }
            });
        }
        
        // 綁定回合結束按鈕的事件
        if (endTurnButton != null)
        {
            endTurnButton.onClick.AddListener(() => {
                if (TurnManager.Instance != null)
                {
                    // 這裡的呼叫現在是合法的
                    TurnManager.Instance.PlayerEndsPlanning(); 
                }
            });
        }
    }
    
    // 控制取消按鈕的顯示/隱藏
    public void SetCancelButtonVisibility(bool isVisible)
    {
        if (cancelButton != null)
        {
            cancelButton.gameObject.SetActive(isVisible);
        }
    }

    // 控制回合結束按鈕的顯示/隱藏
    public void SetEndTurnButtonVisibility(bool isVisible)
    {
        if (endTurnButton != null)
        {
            endTurnButton.gameObject.SetActive(isVisible);
        }
    }
}
```

---

### **Manager (管理層)**
這些是場景中的核心單例物件。

#### **1. GameManager.cs (遊戲狀態管理器)**

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    // 在 GameManager 中持有對核心資料庫的引用，確保它們被載入
    [Header("核心資料庫")]
    [SerializeField] private PartyDatabase partyDatabase;
    [SerializeField] private SkillDatabase skillDatabase;

    private BattleEncounterSO currentEncounter;
    private string sceneBeforeBattle;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);

        // 確保資料庫在遊戲一開始就被喚醒
        if (partyDatabase == null || skillDatabase == null)
        {
            Debug.LogError("GameManager 未設定核心資料庫 (PartyDatabase 或 SkillDatabase)！");
        }

        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    private void OnDestroy()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    public void StartBattle(BattleEncounterSO encounter)
    {
        currentEncounter = encounter;
        sceneBeforeBattle = SceneManager.GetActiveScene().name;
        SceneManager.LoadScene("BattleScene"); // 假設戰鬥場景名為 BattleScene
    }

    public void EndBattle()
    {
        if (!string.IsNullOrEmpty(sceneBeforeBattle))
        {
            SceneManager.LoadScene(sceneBeforeBattle);
        }
        else
        {
            SceneManager.LoadScene(0); // 返回主選單或預設場景
        }
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        if (scene.name == "BattleScene")
        {
            // 等待一幀確保場景中的物件都 Awake 了
            StartCoroutine(SetupBattleScene());
        }
    }

    private System.Collections.IEnumerator SetupBattleScene()
    {
        yield return null; // 等待下一幀
        if (BattleManager.Instance != null && currentEncounter != null)
        {
            BattleManager.Instance.SetupBattle(currentEncounter);
        }
    }
}
```

#### **2. BattleManager.cs (戰鬥場景總控制器)**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattleManager : MonoBehaviour
{
    public static BattleManager Instance { get; private set; }

    [Header("預製件與生成點")]
    [SerializeField] private BattleUnit unitPrefab;
    [SerializeField] private Transform[] playerSpawnPoints;
    [SerializeField] private Transform[] enemySpawnPoints;
    
    [Header("戰鬥單位列表")]
    public List<BattleUnit> PlayerUnits = new List<BattleUnit>();
    public List<BattleUnit> EnemyUnits = new List<BattleUnit>();

    private void Awake()
    {
        Instance = this;
    }

    public void SetupBattle(BattleEncounterSO encounter)
    {
        // 1. 清理舊單位
        PlayerUnits.Clear();
        EnemyUnits.Clear();

        // 2. 實例化玩家單位
        var playerParty = PartyManager.Instance.BattleParty;
        for (int i = 0; i < playerParty.Count; i++)
        {
            BattleRole role = (BattleRole)i; // 簡單地根據順序分配職責
            BattleUnit newUnit = Instantiate(unitPrefab, playerSpawnPoints[(int)role]);
            newUnit.Initialize(playerParty[i], role);
            PlayerUnits.Add(newUnit);
        }

        // 3. 實例化敵人單位
        foreach (var enemyInfo in encounter.enemySpawns)
        {
            BattleUnit newUnit = Instantiate(unitPrefab, enemySpawnPoints[(int)enemyInfo.initialPosition]);
            newUnit.Initialize(enemyInfo.enemyData, enemyInfo.initialPosition);
            EnemyUnits.Add(newUnit);
        }

        // 4. 通知回合管理器開始戰鬥
        TurnManager.Instance.StartCombat(PlayerUnits, EnemyUnits);
    }
    
    public void EndBattle(bool isVictory, BattleEncounterSO encounter)
    {
        if (isVictory)
        {
            Debug.Log("戰鬥勝利！");
            // 可以在此處將經驗值、狀態等寫回 PartyManager
            // ...
            PartyManager.Instance.SaveParty(); // 保存戰鬥後的狀態
            
            // 顯示勝利畫面
            BattleUIManager.Instance.ShowVictoryScreen(encounter);
        }
        else
        {
            Debug.Log("戰鬥失敗！");
            // 顯示失敗畫面
            BattleUIManager.Instance.ShowDefeatScreen();
        }
    }
}
```

#### **3. BattleUIManager.cs (UI 協調器)**

```csharp
using UnityEngine;
using System.Collections.Generic;

public class BattleUIManager : MonoBehaviour
{
    public static BattleUIManager Instance { get; private set; }

    [Header("UI 面板參考")]
    [SerializeField] private ActionPanelUI actionPanel;
    [SerializeField] private ActionSlotPanelUI actionSlotPanel;
    [SerializeField] private BattleEndUI battleEndPanel;
    [SerializeField] private BattleUI battleUI; // 主戰鬥UI，包含取消按鈕

    private void Awake()
    {
        Instance = this;
    }
    
    private void OnEnable()
    {
        BattleUnit.OnUnitClicked += OnBattleUnitClicked;
    }
    
    private void OnDisable()
    {
        BattleUnit.OnUnitClicked -= OnBattleUnitClicked;
    }

    // 接收來自 TurnManager 的指令
    public void SetUIState(TurnState state)
    {
        actionPanel.Hide();
        battleUI.SetCancelButtonVisibility(false);

        switch(state)
        {
            case TurnState.PlayerPlanning:
                // 這部分邏輯會更複雜，需要知道是為哪個角色規劃
                // TurnManager 會調用更具體的方法，例如 ShowPlanningFor(unit)
                break;
            case TurnState.PlayerTargeting:
                battleUI.SetCancelButtonVisibility(true);
                break;
        }
    }

    public void ShowActionPanelFor(BattleUnit unit)
    {
        actionPanel.ShowActionsForRole(unit.Role, (actionType) => {
            TurnManager.Instance.PlayerRequestsAction(unit, actionType);
        });
    }

    public void HighlightTargetableUnits(List<BattleUnit> units, bool highlight)
    {
        // 先關閉所有單位的高亮
        foreach(var u in BattleManager.Instance.PlayerUnits) u.SetTargetable(false);
        foreach(var u in BattleManager.Instance.EnemyUnits) u.SetTargetable(false);
        
        // 再打開指定單位的高亮
        if (highlight)
        {
            foreach (var unit in units)
            {
                unit.SetTargetable(true);
            }
        }
    }

    private void OnBattleUnitClicked(BattleUnit clickedUnit)
    {
        // 將點擊事件轉發給回合管理器
        TurnManager.Instance.PlayerSelectsTarget(clickedUnit);
    }

    // 控制回合結束按鈕
    public void ShowEndTurnButton(bool show)
    {
        if (battleUI != null)
        {
            battleUI.SetEndTurnButtonVisibility(show);
        }
    }
    
    public void ShowVictoryScreen(BattleEncounterSO encounter)
    {
        battleEndPanel.ShowVictory(encounter.moneyReward, encounter.GetFinalItemDrops());
    }
    
    public void ShowDefeatScreen()
    {
        battleEndPanel.ShowDefeat();
    }
}
```

#### **4. TurnManager.cs (回合、邏輯管理器)**
這是最複雜的腳本之一，控制整個戰鬥流程。

```csharp
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    public static TurnManager Instance { get; private set; }

    private TurnState currentState;
    private List<BattleUnit> playerUnits;
    private List<BattleUnit> enemyUnits;
    private TurnActionPlanner actionPlanner;
    
    // 用於暫存目標選擇的相關資訊
    private BattleUnit currentActor;
    private ActionType currentActionType;
    private List<BattleUnit> validTargets;

    private void Awake()
    {
        Instance = this;
        actionPlanner = GetComponent<TurnActionPlanner>();
        if (actionPlanner == null)
        {
            actionPlanner = gameObject.AddComponent<TurnActionPlanner>();
        }
    }

    public void StartCombat(List<BattleUnit> players, List<BattleUnit> enemies)
    {
        this.playerUnits = players;
        this.enemyUnits = enemies;
        if (BattleLog.Instance != null)
        {
            BattleLog.Instance.Initialize();
        }
        SetState(TurnState.BattleStart);
    }
    
    private void SetState(TurnState newState)
    {
        currentState = newState;
        Debug.Log("戰鬥狀態變更為: " + newState);
        if (BattleUIManager.Instance != null)
        {
            BattleUIManager.Instance.SetUIState(newState);
        }

        switch (newState)
        {
            case TurnState.BattleStart:
                StartCoroutine(BattleStartRoutine());
                break;
            case TurnState.PlayerPlanning:
                // 進入規劃階段時，顯示回合結束按鈕
                if (BattleUIManager.Instance != null) BattleUIManager.Instance.ShowEndTurnButton(true);
                StartPlayerPlanningPhase();
                break;
            case TurnState.PlayerTargeting:
                // 選擇目標時，暫時隱藏回合結束按鈕
                if (BattleUIManager.Instance != null) BattleUIManager.Instance.ShowEndTurnButton(false);
                break;
            case TurnState.ActionExecution:
                // 執行階段，隱藏回合結束按鈕
                if (BattleUIManager.Instance != null) BattleUIManager.Instance.ShowEndTurnButton(false);
                StartCoroutine(ActionExecutionRoutine());
                break;
            case TurnState.EnemyTurn:
                StartCoroutine(EnemyTurnRoutine());
                break;
            case TurnState.BattleVictory:
                if (BattleManager.Instance != null) BattleManager.Instance.EndBattle(true, null); // 應傳入遭遇數據
                break;
            case TurnState.BattleDefeat:
                if (BattleManager.Instance != null) BattleManager.Instance.EndBattle(false, null);
                break;
        }
    }

    private IEnumerator BattleStartRoutine()
    {
        yield return new WaitForSeconds(1f); // 播放開場動畫等
        SetState(TurnState.PlayerPlanning);
    }
    
    private void StartPlayerPlanningPhase()
    {
        if (actionPlanner != null)
        {
            actionPlanner.StartNewTurn();
        }

        var vanguard = playerUnits.FirstOrDefault(u => u.Role == BattleRole.Vanguard && u.CurrentHP > 0);
        if (vanguard != null)
        {
            if (BattleUIManager.Instance != null)
            {
                BattleUIManager.Instance.ShowActionPanelFor(vanguard);
            }
        }
        else
        {
            // 如果沒有前衛，跳到下個階段或直接結束回合
            SetState(TurnState.ActionExecution);
        }
    }
    
    // 由 BattleUIManager 透過按鈕點擊調用
    public void PlayerRequestsAction(BattleUnit actor, ActionType actionType)
    {
        currentActor = actor;
        currentActionType = actionType;

        // 如果行動是「結束回合」，直接呼叫對應方法
        if (actionType == ActionType.EndTurn)
        {
            PlayerEndsPlanning(); // 現在這個呼叫是合法的
            return;
        }

        validTargets = BattleRules.GetValidTargets(actor, actionType, playerUnits, enemyUnits);

        if (validTargets != null && validTargets.Count > 0)
        {
            SetState(TurnState.PlayerTargeting);
            if (BattleUIManager.Instance != null)
            {
                BattleUIManager.Instance.HighlightTargetableUnits(validTargets, true);
            }
        }
        else
        {
            // 如果行動不需要目標 (如休息) 或沒有合法目標
            if (actionPlanner != null)
            {
                actionPlanner.AddPlan(new ActionPlan(actor, actionType, null, 0)); 
            }
            SetState(TurnState.PlayerPlanning); // 返回規劃
            if (BattleUIManager.Instance != null)
            {
                BattleUIManager.Instance.ShowActionPanelFor(actor); // 重新顯示行動面板
            }
        }
    }

    // 由 BattleUIManager 透過單位點擊調用
    public void PlayerSelectsTarget(BattleUnit target)
    {
        if (currentState != TurnState.PlayerTargeting) return;

        if (validTargets != null && validTargets.Contains(target))
        {
            if (BattleUIManager.Instance != null)
            {
                BattleUIManager.Instance.HighlightTargetableUnits(null, false); // 清除高亮
            }
            if (actionPlanner != null)
            {
                actionPlanner.AddPlan(new ActionPlan(currentActor, currentActionType, target, 0));
            }
            if (BattleLog.Instance != null)
            {
                BattleLog.Instance.AddEntry($"{currentActor.name} 規劃 {currentActionType} 目標為 {target.name}");
            }
            
            // 規劃成功後，返回規劃階段
            SetState(TurnState.PlayerPlanning);
            // 這裡可以加入邏輯，決定下一個由誰來規劃
        }
    }
    
    public void CancelTargetSelection()
    {
        if (currentState == TurnState.PlayerTargeting)
        {
            if (BattleUIManager.Instance != null)
            {
                BattleUIManager.Instance.HighlightTargetableUnits(null, false);
            }
            SetState(TurnState.PlayerPlanning);
            // 重新顯示行動面板，讓玩家可以重新選擇
            if (BattleUIManager.Instance != null)
            {
                BattleUIManager.Instance.ShowActionPanelFor(currentActor);
            }
        }
    }

    private IEnumerator ActionExecutionRoutine()
    {
        var actions = actionPlanner?.GetExecutionOrder() ?? new List<ActionPlan>();
        foreach (var plan in actions)
        {
            if (plan.Actor != null && plan.Actor.CurrentHP > 0) // 行動前檢查是否存活
            {
                BattleActions.Execute(plan);
                yield return new WaitForSeconds(1.0f); // 每個行動之間的延遲
                
                if (BattleRules.CheckVictory(enemyUnits))
                {
                    SetState(TurnState.BattleVictory);
                    yield break;
                }
            }
        }
        SetState(TurnState.EnemyTurn);
    }
    
    private IEnumerator EnemyTurnRoutine()
    {
        foreach (var enemy in enemyUnits)
        {
            if(enemy.CurrentHP > 0)
            {
                var plan = EnemyBattleAI.ChooseAction(enemy, playerUnits);
                BattleActions.Execute(plan);
                yield return new WaitForSeconds(1.0f);
                
                if (BattleRules.CheckDefeat(playerUnits))
                {
                    SetState(TurnState.BattleDefeat);
                    yield break;
                }
            }
        }
        // 敵人回合結束，回到玩家規劃階段
        SetState(TurnState.PlayerPlanning);
    }

    public void PlayerEndsPlanning()
    {
        // 只有在玩家規劃階段才能結束回合
        if (currentState == TurnState.PlayerPlanning)
        {
            Debug.Log("玩家結束規劃，進入行動執行階段。");
            SetState(TurnState.ActionExecution);
        }
    }
}
```

---

### **戰鬥邏輯 (邏輯層)**
這些通常是靜態類別或普通的C#類別。

#### **1. BattleRules.cs (戰鬥法典)**
一個靜態類，包含所有硬性規定。

```csharp
using System.Collections.Generic;
using System.Linq;

public static class BattleRules
{
    // 獲取指定職責可用的行動列表
    public static List<ActionType> GetAvailableActionsForRole(BattleRole role)
    {
        switch (role)
        {
            case BattleRole.Vanguard:
                return new List<ActionType> { ActionType.Attack, ActionType.Defend, ActionType.Rest, ActionType.Skill, ActionType.Item, ActionType.SwapPosition };
            case BattleRole.Ranged1:
            case BattleRole.Ranged2:
                return new List<ActionType> { ActionType.Attack, ActionType.Rest, ActionType.Skill, ActionType.Item, ActionType.SwapPosition };
            case BattleRole.Support:
                return new List<ActionType> { ActionType.CommanderSkill };
            default:
                return new List<ActionType>();
        }
    }
    
    // 獲取合法的攻擊目標
    public static List<BattleUnit> GetValidTargets(BattleUnit actor, ActionType action, List<BattleUnit> allPlayers, List<BattleUnit> allEnemies)
    {
        var validTargets = new List<BattleUnit>();
        
        switch(action)
        {
            case ActionType.Attack:
                // 假設玩家只能攻擊敵人，反之亦然
                var potentialTargets = allPlayers.Contains(actor) ? allEnemies : allPlayers;
                
                // 篩選存活的單位
                var aliveTargets = potentialTargets.Where(u => u.CurrentHP > 0).ToList();
                
                // 規則: 只能攻擊敵方前衛 (如果存在)
                var enemyVanguard = aliveTargets.FirstOrDefault(u => u.Role == BattleRole.Vanguard);
                if (enemyVanguard != null)
                {
                    validTargets.Add(enemyVanguard);
                }
                else
                {
                    // 如果沒有前衛，可以攻擊任何人
                    validTargets.AddRange(aliveTargets);
                }
                return validTargets;
                
            case ActionType.SwapPosition:
                // ... 實作交換位置的邏輯
                break;
        }
        return validTargets;
    }
    
    public static bool CheckVictory(List<BattleUnit> enemies)
    {
        return enemies.All(e => e.CurrentHP <= 0);
    }

    public static bool CheckDefeat(List<BattleUnit> players)
    {
        return players.All(p => p.CurrentHP <= 0);
    }
}
```

#### **2. BattleActions.cs (行動邏輯)**
實際執行行動的靜態類。

```csharp
public static class BattleActions
{
    public static void Execute(ActionPlan plan)
    {
        if (plan == null || plan.Actor == null) return;
        
        string logMessage = $"{plan.Actor.name} 使用了 {plan.ActionType}";
        if (plan.Target != null) logMessage += $"，目標是 {plan.Target.name}";
        
        BattleLog.Instance.AddEntry(logMessage);

        switch (plan.ActionType)
        {
            case ActionType.Attack:
                int damage = plan.Actor.MemberData?.CurrentAttack ?? plan.Actor.EnemyData.baseAttack;
                plan.Target.TakeDamage(damage);
                break;
            case ActionType.Defend:
                // 在 BattleUnit 上設置一個 "isDefending" 狀態
                // 在 TakeDamage 中檢查此狀態來減傷
                break;
            case ActionType.Rest:
                // 回復體力或其他
                break;
        }
    }
}
```

#### **3. TurnActionPlanner.cs (回合行動規劃器)**

```csharp
using UnityEngine;
using System.Collections.Generic;

public class TurnActionPlanner : MonoBehaviour
{
    private List<ActionPlan> plannedActions = new List<ActionPlan>();

    public void StartNewTurn()
    {
        plannedActions.Clear();
    }

    public void AddPlan(ActionPlan plan)
    {
        plannedActions.Add(plan);
        // 通知UI更新規劃面板
    }

    public List<ActionPlan> GetExecutionOrder()
    {
        // 可以在這裡根據速度或其他屬性排序
        return plannedActions;
    }
}
```

#### **4. CharacterStateRule.cs (角色狀態規則)**

```csharp
public static class CharacterStateRule
{
    public static void RestoreToFull(BattleUnit unit)
    {
        if (unit.MemberData != null)
        {
            unit.CurrentStamina = unit.MemberData.BaseData.baseStamina;
        }
        else if (unit.EnemyData != null)
        {
            unit.CurrentStamina = unit.EnemyData.baseStamina;
        }
    }
}
```

#### **5. EnemyBattleAI.cs (敵人AI)**

```csharp
using System.Collections.Generic;
using System.Linq;

public static class EnemyBattleAI
{
    public static ActionPlan ChooseAction(BattleUnit enemy, List<BattleUnit> players)
    {
        // 簡單AI：只會攻擊存活的玩家
        var alivePlayers = players.Where(p => p.CurrentHP > 0).ToList();
        if (alivePlayers.Count == 0) return null;

        // 優先攻擊前衛
        var target = alivePlayers.FirstOrDefault(p => p.Role == BattleRole.Vanguard) 
                  ?? alivePlayers.FirstOrDefault(); // 如果沒有前衛，攻擊第一個

        if (target != null)
        {
            return new ActionPlan(enemy, ActionType.Attack, target, 0);
        }

        return null;
    }
}
```

---

### **總結與整合建議**

1.  **場景設置**:
    *   創建一個名為 `GameManager` 的空物件，掛上 `GameManager` 腳本，並將其設為 Prefab 放入場景，確保它在遊戲開始時存在。
    *   創建一個名為 `BattleScene` 的場景。
    *   在 `BattleScene` 中，創建 `BattleManager`, `TurnManager`, `BattleUIManager` 等單例物件，並掛上對應腳本。
    *   將所有 UI 面板（`ActionPanelUI`, `BattleEndUI` 等）在 `BattleScene` 中創建好，並在 `BattleUIManager` 中連結對應的參考。
    *   在 `TurnManager` 物件上，它會自動添加 `TurnActionPlanner`。

2.  **腳本執行順序**:
    *   使用 `Edit -> Project Settings -> Script Execution Order` 來確保管理器的初始化順序正確。例如，`GameManager` 應最早，其次是 `PartyManager`，然後是戰鬥場景中的各個 Manager。

3.  **Prefab 製作**:
    *   製作 `BattleUnit` Prefab，掛上 `BattleUnit` 腳本和一個 Collider 用於點擊檢測。
    *   製作 `ActionButtonUI` Prefab。

這個框架非常龐大但結構清晰。在實際開發中，您可以分塊實現和測試，例如先完成戰鬥單位的生成和顯示，再實現行動規劃，最後完成行動執行和AI邏輯。

您可以按照以下順序和建議數值來設定，這會建立一個非常穩定的執行流程。

| 腳本名稱          | 建議數值 | 職責與原因                                             |
| ----------------- | -------- | ------------------------------------------------------ |
| `GameManager`     | `-100`   | **萬物之源**。必須是第一個，以掌管遊戲狀態和場景載入。 |
| `PartyManager`    | `-90`    | **核心資料**。緊隨 GameManager，確保玩家資料在任何時候都已準備好。 |
| *(其他全域管理器)*| `-80`~   | 如果未來有其他全域管理器（如音效、存檔），放在這個區間。 |
| `BattleManager`   | `-50`    | **戰鬥場景的基礎**。在戰鬥場景中，它需要先準備好，以便生成單位。 |
| `BattleUIManager` | `-40`    | **戰鬥UI的準備者**。它需要在 TurnManager 開始發號施令前準備好。 |
| `TurnManager`     | `-30`    | **戰鬥邏輯核心**。在其他戰鬥管理器都準備好後，它才開始運作。 |
| **Default Time**  | `0`      | 所有未設定的腳本都在這裡執行。`Player.cs` 等腳本在此執行即可。 |

**設定完後，看起來會像這樣：**

```
+------------------------------------+
| Script Execution Order             |
+------------------------------------+
| GameManager               [-100] |
| PartyManager              [ -90] |
| BattleManager             [ -50] |
| BattleUIManager           [ -40] |
| TurnManager               [ -30] |
| Default Time              [   0] |
+------------------------------------+
```