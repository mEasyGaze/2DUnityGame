好的，這是一個非常詳盡且結構清晰的戰鬥系統設計。基於您的需求，我將為您編寫所有相關的 C# 腳本。

這些腳本將嚴格遵循您設計的邏輯分離原則：資料、邏輯、UI 各司其職，並透過管理器進行協調。

---

### **1. 戰鬥系統核心資料結構**

#### **BattleEnums.cs**
這個腳本不需要是 `MonoBehaviour`，它只是一個定義，方便全局使用。

```csharp
using System;

// 戰鬥角色職責
public enum BattleRole
{
    Vanguard, // 前衛
    Ranged1,  // 遠1
    Ranged2,  // 遠2
    Support   // 後勤
}

// 單位可以執行的行動類型
public enum ActionType
{
    Attack,         // 攻擊
    Defend,         // 防禦
    Rest,           // 休息
    Skill,          // 技能
    Item,           // 道具
    Exchange,       // 交換位置
    Skip            // 跳過
}

// UI按鈕觸發的指令類型
public enum UICommandType
{
    CommanderSkill,     // 指揮官技能
    Back,               // 返回上一步
    EndTurn,            // 回合結束
    ResetAll,           // 清空規劃
    CancelSingleAction  // 取消單一行動
}

// 回合管理器的宏觀狀態
public enum BattleState
{
    Setup,              // 戰鬥準備階段
    PlayerPlanning,     // 玩家規劃階段
    EnemyTurn,          // 敵人回合
    ActionExecution,    // 行動執行階段
    Won,                // 戰鬥勝利
    Lost                // 戰鬥失敗
}

// 玩家規劃階段的微觀子狀態
public enum PlanningSubState
{
    None,                   // 無操作，等待流程推進
    SelectingRangedUnit,    // 正在等待玩家選擇行動的遠程單位
    SelectingAction,        // 正在等待玩家為已選單位選擇行動
    SelectingTarget,        // 正在等待玩家為已選行動選擇目標
    SelectingExchangeTarget // 正在等待玩家選擇交換位置的目標
}

// 數值代表了距離，方便計算
[Serializable]
public enum GridPosition
{
    PlayerSupport = 0,
    PlayerRanged2 = 1,
    PlayerRanged1 = 2,
    PlayerVanguard = 3,
    EnemyVanguard = 4,
    EnemyRanged1 = 5,
    EnemyRanged2 = 6,
    EnemySupport = 7,
    None = -1
}

public static class ActionTypeExtensions
{
    // "this ActionType type" 表示我們正在為 ActionType 這個枚舉擴充一個新方法
    public static string ToActionName(this ActionType type)
    {
        switch (type)
        {
            case ActionType.Attack:   return "攻擊";
            case ActionType.Defend:   return "防禦";
            case ActionType.Rest:     return "休息";
            case ActionType.Skill:    return "技能";
            case ActionType.Item:     return "道具";
            case ActionType.Exchange: return "交換";
            case ActionType.Skip:     return "跳過";
            default:                  return type.ToString(); // 作為備用選項
        }
    }
}
```

#### **EnemyDataSO.cs (ScriptableObject)**
敵人的靜態資料模板。

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewEnemyData", menuName = "Battle System/Enemy Data")]
public class EnemyDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string enemyID;
    public string enemyName;
    public Sprite enemyIcon;
    public GameObject enemyPrefab; // 戰鬥中使用的模型Prefab

    [Header("基礎屬性")]
    public int baseHealth;
    public int baseAttack;
    public int baseStamina;
    public int attackRange;

    [Header("技能槽位")]
    [Tooltip("輸入對應 SkillData 的技能ID")]
    public List<string> skillIDs;

    [Header("物品掉落")]
    public int goldDrop;
    // public List<ItemDropInfo> itemDrops; // 未來可擴充為物品掉落
}
```

#### **BattleEncounterSO.cs (ScriptableObject)**
定義一場戰鬥遭遇的配置。

```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class EnemyPositioning
{
    public EnemyDataSO enemyData;
    public BattleRole role; // 指定這個敵人在戰鬥中的職責
}

[CreateAssetMenu(fileName = "NewBattleEncounter", menuName = "Battle System/Battle Encounter")]
public class BattleEncounterSO : ScriptableObject
{
    [Header("敵人隊伍配置")]
    public List<EnemyPositioning> enemyTeam;

    [Header("戰鬥獎勵")]
    public int totalGoldReward;
    // public List<ItemReward> itemRewards; // 預計的物品獎勵

    // 這個方法可以在編輯器中自動計算總獎勵
    private void OnValidate()
    {
        int calculatedGold = 0;
        if (enemyTeam != null)
        {
            foreach (var enemyPos in enemyTeam)
            {
                if (enemyPos.enemyData != null)
                {
                    calculatedGold += enemyPos.enemyData.goldDrop;
                }
            }
        }
        totalGoldReward = calculatedGold;
    }
}
```

#### **ActionPlan.cs**
儲存單一行動的數據結構，不是 `MonoBehaviour`。

```csharp
using System;

public class ActionPlan
{
    // 將類型從 BattleUnit 改為 IBattleUnit_ReadOnly
    public IBattleUnit_ReadOnly Source { get; }    // 行動發起者
    public IBattleUnit_ReadOnly Target { get; }    // 行動目標
    public ActionType Type { get; }      // 行動類型
    public int PhaseIndex { get; }       // 歸屬的行動階段 (1-4)
    public BattleRole PlannedForRole { get; } // 這個計畫是為哪個職位格準備的
    public Guid TransactionID { get; }   // 關聯行動ID
    // 目標的預計位置，用於處理目標移動或陣亡的情況
    public GridPosition TargetPosition { get; } 
    // 主要構造函數
    public ActionPlan(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly target, ActionType type, int phaseIndex, BattleRole plannedForRole, Guid transactionID = default)
    {
        Source = source;
        Target = target;
        Type = type;
        PhaseIndex = phaseIndex;
        PlannedForRole = plannedForRole;
        TransactionID = (transactionID == default) ? Guid.Empty : transactionID;
        // 如果目標不為空，記錄下它當前的位置
        TargetPosition = (target != null) ? target.CurrentPosition : GridPosition.None;
    }
}
```

---

### **2. Prefab 相關腳本**

#### **BattleUnit.cs**
附加在角色/敵人 Prefab 上的核心組件。

```csharp
using UnityEngine;
using UnityEngine.Events;
using TMPro;

public interface IBattleUnit_ReadOnly
{
    // 核心數據
    string UnitName { get; }
    int CurrentHP { get; }
    int MaxHP { get; }
    int CurrentStamina { get; }
    int MaxStamina { get; }
    int CurrentAttack { get; }
    int AttackRange { get; }
    bool IsDead { get; }
    bool IsPlayerTeam { get; }

    // 位置與職責
    GridPosition CurrentPosition { get; }
    BattleRole Role { get; }
    
    // 引用數據
    MemberDataSO MemberData { get; }
    EnemyDataSO EnemyData { get; }

    // 實例數據
    MemberInstance MemberInstance { get; }
    
    // 用於獲取底層的 MonoBehaviour 實例，方便進行比較等操作
    BattleUnit GetMonoBehaviour();
}

public class BattleUnit : MonoBehaviour, IBattleUnit_ReadOnly
{
    // 靜態資料
    public MemberDataSO MemberData { get; private set; }
    public EnemyDataSO EnemyData { get; private set; }

    // 實例資料
    public MemberInstance MemberInstance { get; private set; }

    // 戰鬥相關屬性
    public BattleRole Role { get; private set; }
    public GridPosition CurrentPosition { get; private set; }
    public int AttackRange { get; private set; }
    public bool IsPlayerTeam { get; private set; }
    public string UnitName { get; private set; }
    public int MaxHP { get; private set; }
    public int CurrentHP { get; private set; }
    public int CurrentAttack { get; private set; }
    public int MaxStamina { get; private set; }
    public int CurrentStamina { get; private set; }
    public bool IsDead { get; private set; } = false;

    private bool isDefending = false;

    [Header("元件連結")]
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private HealthUI healthUI;
    
    [Header("狀態反饋")]
    [SerializeField] private GameObject selectionHighlight; // 用於顯示可選/不可選
    [SerializeField] private GameObject planningHighlight;  // 用於顯示「當前規劃單位」

    [Header("戰術預演UI")]
    [SerializeField] private TextMeshProUGUI previewStaminaText; // 預覽體力文字

    public UnityAction<BattleUnit> OnUnitClicked;

    // 實現接口要求的方法
    public BattleUnit GetMonoBehaviour() => this;

    public void Setup(MemberInstance instance, BattleRole role, GridPosition initialPosition)
    {
        MemberInstance = instance;
        MemberData = instance.BaseData;
        UnitName = MemberData.memberName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = MemberData.attackRange;
        IsPlayerTeam = true;
        
        MaxHP = instance.MaxHP;
        CurrentHP = instance.currentHP;
        CurrentAttack = instance.CurrentAttack;
        MaxStamina = instance.MaxStamina;
        CurrentStamina = instance.MaxStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = MemberData.memberIcon;

        ResetVisualsToCoreState();
    }

    public void Setup(EnemyDataSO data, BattleRole role, GridPosition initialPosition)
    {
        EnemyData = data;
        UnitName = EnemyData.enemyName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = data.attackRange;
        IsPlayerTeam = false;
        
        MaxHP = data.baseHealth;
        CurrentHP = data.baseHealth;
        CurrentAttack = data.baseAttack;
        MaxStamina = data.baseStamina;
        CurrentStamina = data.baseStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = EnemyData.enemyIcon;

        ResetVisualsToCoreState();
    }
    
    public void TakeDamage(int damage)
    {
        if (IsDead) return;
        if (isDefending) damage /= 2;
        CurrentHP -= damage;
        BattleLog.Instance.AddLog($"{UnitName} 受到 {damage} 點傷害。");
        if (CurrentHP <= 0)
        {
            CurrentHP = 0;
            Die();
        }
    }

    private void Die()
    {
        IsDead = true;
        gameObject.SetActive(false);
        BattleLog.Instance.AddLog($"{UnitName} 已陣亡！");
    }

    public void ConsumeStamina(int amount)
    {
        CurrentStamina = Mathf.Max(0, CurrentStamina - amount);
    }

    public void RestoreStamina(int amount)
    {
        CurrentStamina = Mathf.Min(MaxStamina, CurrentStamina + amount);
    }

    public void SetStamina(int value)
    {
        CurrentStamina = Mathf.Clamp(value, 0, MaxStamina);
    }

    public void SetNewPosition(GridPosition newPosition)
    {
        this.CurrentPosition = newPosition;
    }

    public void SetRole(BattleRole newRole)
    {
        this.Role = newRole;
    }

    // 戰術沙盤預演接口
    public void UpdatePreviewVisuals(GridPosition previewPosition, int previewStamina, BattleRole previewRole)
    {
        // 1. 平滑移動到預覽位置 (這裡用瞬移代替，平滑移動可用 Lerp 或 DoTween)
        if (BattleManager.Instance != null && BattleManager.Instance.GridSpawns[(int)previewPosition] != null)
        {
            transform.position = BattleManager.Instance.GridSpawns[(int)previewPosition].position;
        }

        // 2. 更新預覽體力UI
        if (previewStaminaText != null)
        {
            // 注意：這裡的 CurrentStamina 是核心數據，用於計算差值
            // 這是一個特例，因為它只用於UI顯示，沒有影響邏輯
            int staminaChange = previewStamina - this.CurrentStamina;
            previewStaminaText.text = staminaChange != 0 ? staminaChange.ToString() : "";
            previewStaminaText.color = staminaChange < 0 ? Color.red : Color.green;
            previewStaminaText.gameObject.SetActive(staminaChange != 0);
        }
    }

    public void ResetVisualsToCoreState()
    {
        // 1. 將模型位置重置到核心數據 CurrentPosition 的位置
        if (BattleManager.Instance != null && BattleManager.Instance.GridSpawns[(int)this.CurrentPosition] != null)
        {
            transform.position = BattleManager.Instance.GridSpawns[(int)this.CurrentPosition].position;
        }

        // 2. 隱藏預覽UI
        if (previewStaminaText != null)
        {
            previewStaminaText.gameObject.SetActive(false);
        }
    }

    private void OnMouseDown()
    {
        OnUnitClicked?.Invoke(this);
    }
    
    public void SetHighlight(bool state)
    {
        if (selectionHighlight != null) selectionHighlight.SetActive(state);
    }
    
    public void SetPlanningHighlight(bool state)
    {
        if (planningHighlight != null) planningHighlight.SetActive(state);
    }
    
    public void SetDefenseState(bool defending)
    {
        isDefending = defending;
    }
}
```

#### **ActionButtonUI.cs**
萬用按鈕的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionButtonUI : MonoBehaviour
{
    [SerializeField] private Button button;
    [SerializeField] private TextMeshProUGUI buttonText;
    
    private ActionType actionType;
    
    public void Setup(ActionType type, System.Action<ActionType> onClickCallback)
    {
        buttonText.text = type.ToActionName();
        
        button.onClick.RemoveAllListeners();
        button.onClick.AddListener(() => onClickCallback(type));
    }
    
    public void SetInteractable(bool interactable)
    {
        button.interactable = interactable;
    }
}
```

#### **ActionSlotUI.cs**
單一行動格的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionSlotUI : MonoBehaviour
{
    [Header("內容UI")]
    [SerializeField] private Image icon;
    [SerializeField] private TextMeshProUGUI actionText;

    [Header("狀態物件")]
    [SerializeField] private GameObject emptyStateObject;
    [SerializeField] private GameObject filledStateObject;

    [Header("互動元件")]
    [SerializeField] private Button cancelButton;

    private ActionPlan currentPlan;

    public void Setup(System.Action<ActionPlan> onCancelClicked)
    {
        cancelButton.onClick.RemoveAllListeners();
        cancelButton.onClick.AddListener(() =>
        {
            if (currentPlan != null)
            {
                onCancelClicked(currentPlan);
            }
        });
    }

    public void UpdateView(ActionPlan plan)
    {
        currentPlan = plan;
        if (plan == null)
        {
            emptyStateObject.SetActive(true);
            filledStateObject.SetActive(false);
        }
        else
        {
            emptyStateObject.SetActive(false);
            filledStateObject.SetActive(true);
            
            if (plan.Source != null)
            {
                if (plan.Source.MemberData != null) icon.sprite = plan.Source.MemberData.memberIcon;
                else if (plan.Source.EnemyData != null) icon.sprite = plan.Source.EnemyData.enemyIcon;
                
                actionText.text = $"{plan.Source.UnitName[0]} > {plan.Type.ToActionName()}";
            }
            else
            {
                actionText.text = "錯誤";
            }
        }
    }

    public void SetCancelButtonInteractable(bool isInteractable)
    {
        cancelButton.interactable = isInteractable;
    }
}
```

#### **HealthUI.cs**
掛在 `BattleUnit` 上的血條 UI。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HealthUI : MonoBehaviour
{
    [SerializeField] private BattleUnit targetUnit;
    [SerializeField] private Slider healthSlider;
    [SerializeField] private TextMeshProUGUI healthText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if(targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (healthSlider != null)
        {
            healthSlider.minValue = 0;
            healthSlider.maxValue = 1;
        }
    }

    void Update()
    {
        if (targetUnit != null && !targetUnit.IsDead)
        {
            // 更新 Slider 的值 (0 到 1 之間)
            healthSlider.value = (float)targetUnit.CurrentHP / targetUnit.MaxHP;
            
            // 更新文字顯示
            if (healthText != null)
            {
                healthText.text = $"{targetUnit.CurrentHP} / {targetUnit.MaxHP}";
            }
            
            // 使血條始終面向攝影機
            transform.rotation = mainCamera.transform.rotation; 
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}
```

#### **BattleTrigger.cs**
戰鬥觸發器。

```csharp
using UnityEngine;

public class BattleTrigger : MonoBehaviour
{
    [SerializeField] private BattleEncounterSO battleEncounter;

    private void OnTriggerEnter(Collider other)
    {
        // 假設玩家物件帶有 "Player" 標籤
        if (other.CompareTag("Player"))
        {
            // 禁用觸發器避免重複觸發
            GetComponent<Collider>().enabled = false;
            
            // 通知 GameManager 啟動戰鬥
            GameManager.Instance.StartBattle(battleEncounter);
        }
    }
}
```

---

### **3. UI 管理腳本**

#### **ActionPanelUI.cs**
行動按鈕面板。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionPanelUI : MonoBehaviour
{
    [SerializeField] private GameObject panel;
    [SerializeField] private Transform buttonContainer;
    [SerializeField] private ActionButtonUI buttonPrefab;
    
    private List<ActionButtonUI> spawnedButtons = new List<ActionButtonUI>();
    private Dictionary<ActionType, ActionButtonUI> buttonMap = new Dictionary<ActionType, ActionButtonUI>();

    public void ShowPanel(BattleUnit unit, System.Action<ActionType> onActionSelected)
    {
        ClearButtons();
        
        // 根據角色職責決定可用的行動列表
        List<ActionType> availableActions = GetActionsForRole(unit.Role);

        foreach (var actionType in availableActions)
        {
            ActionButtonUI newButton = Instantiate(buttonPrefab, buttonContainer);
            newButton.Setup(actionType, onActionSelected);
            spawnedButtons.Add(newButton);
            buttonMap.Add(actionType, newButton);
        }
        
        panel.SetActive(true);
    }

    public void UpdateButtonStates(Dictionary<ActionType, bool> feasibility)
    {
        foreach (var pair in feasibility)
        {
            if (buttonMap.ContainsKey(pair.Key))
            {
                buttonMap[pair.Key].SetInteractable(pair.Value);
            }
        }
    }
    
    // 根據角色職責返回一個行動列表
    private List<ActionType> GetActionsForRole(BattleRole role)
    {
        switch (role)
        {
            case BattleRole.Vanguard:
            case BattleRole.Ranged1:
            case BattleRole.Ranged2:
                // 假設所有戰鬥單位都有這些基礎行動
                return new List<ActionType>
                {
                    ActionType.Attack,
                    ActionType.Defend,
                    ActionType.Rest,
                    ActionType.Exchange,
                    ActionType.Skip
                };
            // case BattleRole.Support: // 後勤的行動可以在這裡定義
            default:
                return new List<ActionType>();
        }
    }

    public void UpdateButtonStates(BattleUnit unit, BattleRules rules)
    {
        foreach (var btnUI in spawnedButtons)
        {
            // 簡化：這裡可以加入更複雜的規則，例如體力檢查
            // bool isInteractable = rules.CanPerformAction(unit, btnUI.ActionType);
            // btnUI.SetInteractable(isInteractable);
        }
    }

    public void HidePanel()
    {
        panel.SetActive(false);
        ClearButtons();
    }
    
    private void ClearButtons()
    {
        foreach (var btn in spawnedButtons)
        {
            Destroy(btn.gameObject);
        }
        spawnedButtons.Clear();
        buttonMap.Clear();
    }
}
```

#### **ActionSlotPanelUI.cs**
戰術規劃板。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System;

public class ActionSlotPanelUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject panel;
    [SerializeField] private List<ActionSlotUI> vanguardSlots;
    [SerializeField] private List<ActionSlotUI> rangedSlots;
    [SerializeField] private List<GameObject> highlightObjects; // 8個高亮物件

    private Dictionary<int, ActionSlotUI> allSlots = new Dictionary<int, ActionSlotUI>();

    public void Initialize(System.Action<UICommandType, ActionPlan> onCommand)
    {
        // 初始化時，建立 stepIndex 到 ActionSlotUI 的映射
        for (int i = 0; i < vanguardSlots.Count; i++)
        {
            int stepIndex = i * 2;
            allSlots[stepIndex] = vanguardSlots[i];
            vanguardSlots[i].Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
        for (int i = 0; i < rangedSlots.Count; i++)
        {
            int stepIndex = i * 2 + 1;
            allSlots[stepIndex] = rangedSlots[i];
            rangedSlots[i].Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
    }
    
    public void UpdatePanel(TurnActionPlanner planner)
    {
        // 1. 獲取最後一個已規劃行動的步驟索引
        int lastPlannedStep = planner.GetLastPlanStepIndex();
        
        // 2. 遍歷所有行動格
        for(int i = 0; i < 8; i++)
        {
            if (allSlots.TryGetValue(i, out ActionSlotUI slot))
            {
                ActionPlan plan = planner.GetPlanAtStep(i);
                
                slot.UpdateView(plan);
                
                bool isCancellable = (plan != null && i == lastPlannedStep);
                
                if (plan != null && plan.TransactionID != Guid.Empty)
                {
                    var lastPlan = planner.GetPlanAtStep(lastPlannedStep);
                    if (lastPlan != null && lastPlan.TransactionID == plan.TransactionID)
                    {
                        isCancellable = true;
                    }
                }
                slot.SetCancelButtonInteractable(isCancellable);
            }
        }
        
        panel.SetActive(true);
    }

    public void SetPlanningHighlight(int stepIndex)
    {
        for (int i = 0; i < highlightObjects.Count; i++)
        {
            if (highlightObjects[i] != null)
            {
                highlightObjects[i].SetActive(i == stepIndex);
            }
        }
    }
    
    public void HidePanel()
    {
        panel.SetActive(false);
    }
}
```

#### **BattleEndUI.cs**
戰鬥結算畫面。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BattleEndUI : MonoBehaviour
{
    [SerializeField] private GameObject victoryPanel;
    [SerializeField] private GameObject defeatPanel;
    [SerializeField] private TextMeshProUGUI rewardText;
    [SerializeField] private Button exitButton;

    private void Start()
    {
        exitButton.onClick.AddListener(OnExitButtonClicked);
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(false);
    }

    public void ShowVictory(int goldReward)
    {
        victoryPanel.SetActive(true);
        defeatPanel.SetActive(false);
        rewardText.text = $"獲得金幣: {goldReward}";
    }

    public void ShowDefeat()
    {
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(true);
    }

    private void OnExitButtonClicked()
    {
        // 通知 GameManager 返回主場景
        GameManager.Instance.EndBattle();
    }
}
```

#### **BattleLog.cs**
戰鬥日誌。

```csharp
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class BattleLog : MonoBehaviour
{
    public static BattleLog Instance { get; private set; }
    
    [SerializeField] private TextMeshProUGUI logText;
    [SerializeField] private ScrollRect scrollRect;
    private Queue<string> logMessages = new Queue<string>();
    private int maxMessages = 20;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public void AddLog(string message)
    {
        if (logMessages.Count >= maxMessages)
        {
            logMessages.Dequeue();
        }
        logMessages.Enqueue($"[{System.DateTime.Now:HH:mm:ss}] {message}");
        
        UpdateLogText();
    }

    private void UpdateLogText()
    {
        logText.text = string.Join("\n", logMessages);
        
        // 自動滾動到底部
        Canvas.ForceUpdateCanvases();
        scrollRect.verticalNormalizedPosition = 0f;
    }
}
```

#### **BattleUI.cs**
戰鬥場景 UI 總集。

```csharp
using UnityEngine;
using UnityEngine.UI;

public class BattleUI : MonoBehaviour
{
    [SerializeField] private Button endTurnButton;
    [SerializeField] private Button resetButton;
    [SerializeField] private Button backButton;

    // 將回調統一為一個，使用 UICommandType 來區分
    public void Setup(System.Action<UICommandType> onCommand)
    {
        endTurnButton.onClick.RemoveAllListeners();
        endTurnButton.onClick.AddListener(() => onCommand(UICommandType.EndTurn));
        
        resetButton.onClick.RemoveAllListeners();
        resetButton.onClick.AddListener(() => onCommand(UICommandType.ResetAll));
        
        backButton.onClick.RemoveAllListeners();
        backButton.onClick.AddListener(() => onCommand(UICommandType.Back));
    }
    
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        endTurnButton.interactable = interactable;
    }
    
    public void SetBackButtonVisible(bool visible)
    {
        backButton.gameObject.SetActive(visible);
    }

    public void SetResetButtonVisible(bool visible)
    {
        resetButton.gameObject.SetActive(visible);
    }
}
```

---

### **4. 管理器 (Managers)**

#### **TurnManager.cs**
回合與邏輯管理器，戰鬥的核心。

```csharp
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    #region 屬性與狀態變數 (Properties & State Variables)

    public BattleState CurrentState { get; private set; }

    // --- 核心模組依賴 (Core Module Dependencies) ---
    private BattleManager battleManager;
    private BattleUIManager uiManager;
    private TurnActionPlanner actionPlanner;
    private BattleRules battleRules;
    private BattleActions battleActions;
    private EnemyBattleAI enemyAI;
    private CharacterStateRule characterStateRule;
    private BattlefieldStateSimulator stateSimulator;

    // --- 玩家規劃階段的微觀狀態 (Planning Phase Micro-States) ---
    private int currentPlanningStepIndex;
    private PlanningSubState currentSubState;
    private BattleUnit selectedUnitForAction;
    private ActionType selectedActionType;
    private List<IBattleUnit_ReadOnly> currentEligibleActors;
    // 用於實現微觀步驟回溯的狀態堆疊
    private Stack<PlanningSubState> planningHistory = new Stack<PlanningSubState>();

    #endregion

    #region 初始化與啟動 (Initialization & Startup)
    public void Initialize(BattleManager bm, BattleUIManager uim, TurnActionPlanner ap, BattleRules br, BattleActions ba, EnemyBattleAI eai, CharacterStateRule csr, BattlefieldStateSimulator sim)
    {
        // 模組賦值
        battleManager = bm;
        uiManager = uim;
        actionPlanner = ap;
        battleRules = br;
        battleActions = ba;
        enemyAI = eai;
        characterStateRule = csr;
        stateSimulator = sim;

        // 狀態變數初始化
        currentEligibleActors = new List<IBattleUnit_ReadOnly>();
    }

    public void StartBattle()
    {
        BattleLog.Instance.AddLog("戰鬥開始！");
        SetState(BattleState.PlayerPlanning);
    }
    #endregion

    #region 宏觀狀態機管理 (Macro State Machine Management)
    private void SetState(BattleState newState)
    {
        if (CurrentState == newState) return;     
        CurrentState = newState;
        StartCoroutine(OnEnterState(newState));
    }
    
    private IEnumerator OnEnterState(BattleState state)
    {
        switch (state)
        {
            case BattleState.PlayerPlanning:
                HandleEnterPlayerPlanning();
                break;
            case BattleState.EnemyTurn:
                yield return StartCoroutine(HandleEnterEnemyTurn());
                break;
            case BattleState.ActionExecution:
                HandleEnterActionExecution();
                break;
            case BattleState.Won:
                HandleEnterWon();
                break;
            case BattleState.Lost:
                HandleEnterLost();
                break;
        }
    }
    private void HandleEnterPlayerPlanning()
    {
        BattleLog.Instance.AddLog("==== 新回合：玩家規劃階段 ====");
        if (uiManager != null)
        {
            uiManager.SetResetButtonVisible(true);      // 確保重置按鈕可見
            uiManager.SetEndTurnButtonInteractable(false); // 規劃完成前不能結束回合
            uiManager.SetBackButtonVisible(false);      // 回合開始時沒有歷史記錄可返回
        }
        actionPlanner.PrepareForNewTurn();
        characterStateRule.RestoreAllUnitStamina(battleManager.GetAllUnits());
        // 進入規劃階段時，直接重置所有規劃
        CommitResetAllPlans();
    }
    private IEnumerator HandleEnterEnemyTurn()
    {
        BattleLog.Instance.AddLog("==== 敵人回合 ====");
        uiManager.EnterEnemyTurnState();
        var currentSnapshotForAI = characterStateRule.GetLatestSnapshot();
        enemyAI.PlanActions(battleManager.EnemyUnits, battleManager.PlayerUnits, actionPlanner, battleRules, battleActions.GetAttackStaminaCost());
        yield return new WaitForSeconds(1f); // 等待AI思考動畫（如果有的話）
        SetState(BattleState.ActionExecution);
    }

    private void HandleEnterActionExecution()
    {
        BattleLog.Instance.AddLog("==== 行動執行階段 ====");
        uiManager.EnterActionExecutionState();
        StartCoroutine(ExecuteActions());
    }

    private void HandleEnterWon()
    {
        BattleLog.Instance.AddLog("★★ 戰鬥勝利 ★★");
        uiManager.ShowVictoryScreen(battleManager.EncounterData.totalGoldReward);
    }

    private void HandleEnterLost()
    {
        BattleLog.Instance.AddLog("戰鬥失敗...");
        uiManager.ShowDefeatScreen();
    }
    #endregion

    #region 玩家輸入處理 (Player Input Handling)
    // OnUnitClicked 和 OnActionSelected 收集完資訊後，應該調用事務性方法
    public void OnUnitClicked(BattleUnit unit)
    {
        if (CurrentState != BattleState.PlayerPlanning) return;

        switch(currentSubState)
        {
            case PlanningSubState.SelectingRangedUnit:
                if (currentEligibleActors.Any(u => u.GetMonoBehaviour() == unit))
                {
                    selectedUnitForAction = unit;
                    GoToPlanningSubState(PlanningSubState.SelectingAction); // 前進到選擇行動
                }
                break;
                
            case PlanningSubState.SelectingTarget:
                var validTargets = battleRules.GetValidTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot());
                if (validTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewPlan(selectedUnitForAction, selectedActionType, unit);
                }
                break;

            case PlanningSubState.SelectingExchangeTarget:
                var validExchangeTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot());
                if (validExchangeTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewExchangePlan(selectedUnitForAction, unit);
                }
                break;
        }
    }
    
    public void OnActionSelected(ActionType type)
    {
        if (CurrentState != BattleState.PlayerPlanning || currentSubState != PlanningSubState.SelectingAction) return;
        
        selectedActionType = type;
        
        if (type == ActionType.Attack)
        {
            GoToPlanningSubState(PlanningSubState.SelectingTarget);
        }
        else if (type == ActionType.Exchange)
        {
            GoToPlanningSubState(PlanningSubState.SelectingExchangeTarget);
        }
        else
        {
            CommitNewPlan(selectedUnitForAction, type, null);
        }
    }

    // OnUICommand 現在是調用事務性方法的完美入口
    public void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        if (CurrentState != BattleState.PlayerPlanning)
        {
            if (command == UICommandType.EndTurn) SetState(BattleState.EnemyTurn);
            return;
        }

        switch (command)
        {
            case UICommandType.EndTurn: SetState(BattleState.EnemyTurn); break;
            case UICommandType.ResetAll: CommitResetAllPlans(); break;
            case UICommandType.CancelSingleAction: CommitCancelLastPlan(); break;
            case UICommandType.Back: CommitGoBack(); break;
        }
    }
    #endregion

    #region 事務性操作 (Transactional Operations)
    // 事務一：提交一個新的普通行動
    private void CommitNewPlan(IBattleUnit_ReadOnly actor, ActionType type, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();
        // 1. 創建計畫
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        ActionPlan newPlan = new ActionPlan(actor, target, type, phaseIndex, stepRole);
        
        // 2. 更新系統狀態 (捆綁操作)
        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        
        // 3. 刷新視覺並推進流程
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot());
        AdvancePlanningStep();
    }
    
    /// 事務二：提交一個新的交換行動
    private void CommitNewExchangePlan(IBattleUnit_ReadOnly actor, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();
        // 1. 資源預檢查
        var actorSnap = characterStateRule.GetLatestSnapshot().First(s => s.Unit == actor);
        if (actorSnap.Stamina < battleActions.GetExchangeStaminaCost())
        {
            BattleLog.Instance.AddLog($"交換失敗：{actor.UnitName} 體力不足！");
            // 可以通過 UIManager 顯示更正式的提示
            return;
        }
        
        // 2. 行動格調度
        int actorStepIndex = currentPlanningStepIndex;
        // 為被動方查找行動格時，需要把主動方即將佔用的格子排除掉
        var excludeList = new List<int> { actorStepIndex };
        int targetStepIndex = actionPlanner.FindNextAvailableStep(target.Role, 0, excludeList);

        if (targetStepIndex == -1)
        {
            BattleLog.Instance.AddLog($"交換失敗：沒有可用的行動格給 {target.UnitName}！");
            // 可以通過 UIManager 顯示更正式的提示
            return;
        }

        // 3. 創建與提交計畫
        int phaseIndex = (actorStepIndex / 2) + 1; // 交換發生在同一個大階段
        BattleRole actorStepRole = GetRoleForStep(actorStepIndex);
        BattleRole targetStepRole = GetRoleForStep(targetStepIndex);
        Guid transactionID = Guid.NewGuid();
        
        var planA = new ActionPlan(actor, target, ActionType.Exchange, phaseIndex, actorStepRole, transactionID);
        // 注意：planB 的目標是 A，發起者是 B，但它仍然是被動的
        var planB = new ActionPlan(target, actor, ActionType.Exchange, phaseIndex, targetStepRole, transactionID); 

        // 捆綁更新狀態
        actionPlanner.AddPlan(planA, actorStepIndex);
        actionPlanner.AddPlan(planB, targetStepIndex);
        // 快照只計算一次，以主動方為準
        characterStateRule.GenerateAndStoreNextSnapshot(planA, battleActions);
        
        // 4. 刷新視覺並推進流程
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot());
        AdvancePlanningStep();
    }
    
    // 事務三：取消指定的行動
    private void CommitCancelLastPlan()
    {
        planningHistory.Clear();
        // 找到計畫所在的步驟，如果找不到則直接返回
        int lastPlanStep = actionPlanner.GetLastPlanStepIndex();
        if (lastPlanStep == -1)
        {
            Debug.Log("沒有任何已規劃的行動可以取消。");
            return;
        }
        
        ActionPlan lastPlan = actionPlanner.GetPlanAtStep(lastPlanStep);
        BattleLog.Instance.AddLog($"正在撤銷行動: {lastPlan.Source.UnitName} -> {lastPlan.Type.ToActionName()}");

        // 捆綁操作
        // 1. 移除計畫 (RemovePlansFromStep 已被強化，可以處理關聯ID)
        actionPlanner.RemovePlansFromStep(lastPlanStep);
        // 2. 修剪快照鏈 (回滾歷史)
        characterStateRule.PruneSnapshotsToCount(actionPlanner.GetPlayerPlanCount());
        
        // 刷新視覺並回滾流程
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot());
        // 將規劃流程設定到第一個未規劃的步驟
        planningHistory.Clear();
        currentPlanningStepIndex = actionPlanner.GetNextPlanningStepIndex();
        AdvancePlanningStep();
    }
    
    // 事務五：重置所有規劃
    private void CommitResetAllPlans()
    {
        planningHistory.Clear();
        actionPlanner.ClearPlayerPlans();
        characterStateRule.InitializeSnapshots(battleManager.GetAllUnits());
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot());
        StartCoroutine(StartGuidedPlanning());
        BattleLog.Instance.AddLog("已重置所有規劃。");
    }

    // 事務四：智能返回的核心
    private void CommitGoBack()
    {
        if (planningHistory.Count > 0)
        {
            // 從歷史堆疊中彈出上一個狀態
            PlanningSubState previousState = planningHistory.Pop();
            
            BattleLog.Instance.AddLog("返回上一步操作。");
            
            // 直接跳轉到該子狀態，恢復UI和內部變數
            // 第二個參數 false 表示這是一個回退操作，不需要再將狀態壓入堆疊
            GoToPlanningSubState(previousState, false); 
        }
        else
        {
            Debug.LogWarning("沒有可返回的微觀操作歷史。");
        }
    }
    #endregion
    
    #region 規劃階段核心邏輯 (Planning Phase Core Logic)
    private IEnumerator StartGuidedPlanning()
    {
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;
        
        currentPlanningStepIndex = 0;
        AdvancePlanningStep();
        yield return null;
    }

    private void AdvancePlanningStep()
    {
        uiManager.UpdateActionSlots(actionPlanner);
        planningHistory.Clear();
        if (actionPlanner.IsPlanningFinished())
        {
            // 如果所有格子都滿了，進入規劃完成狀態
            GoToPlanningSubState(PlanningSubState.None);
            return;
        }

        // 循環尋找下一個可規劃的步驟
        while (currentPlanningStepIndex < 8)
        {
            currentPlanningStepIndex = actionPlanner.GetNextPlanningStepIndex();
            if (currentPlanningStepIndex >= 8) // 所有格子都已规划
            {
                GoToPlanningSubState(PlanningSubState.None);
                return;
            }
            
            var latestSnapshot = characterStateRule.GetLatestSnapshot();
            currentEligibleActors = battleRules.GetEligibleActorsForStep(currentPlanningStepIndex, latestSnapshot, actionPlanner);

            if (currentEligibleActors.Count > 0)
            {
                // 找到了可以操作的步驟，跳出循環，進入對應的微觀狀態
                if (currentEligibleActors.Count == 1)
                {
                    selectedUnitForAction = currentEligibleActors[0].GetMonoBehaviour();
                    planningHistory.Push(PlanningSubState.None);
                    GoToPlanningSubState(PlanningSubState.SelectingAction);
                }
                else
                {
                    GoToPlanningSubState(PlanningSubState.SelectingRangedUnit);
                }
                return; // 停止尋找
            }
            else
            {
                // 當前步驟無人可動，自動填充Skip計畫並繼續尋找下一個可用步驟
                BattleLog.Instance.AddLog($"在階段 {currentPlanningStepIndex + 1} 沒有可行動的單位，自動跳過。");
                
                int phaseIndex = (currentPlanningStepIndex / 2) + 1;
                BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
                ActionPlan skipPlan = new ActionPlan(null, null, ActionType.Skip, phaseIndex, stepRole);

                actionPlanner.AddPlan(skipPlan, currentPlanningStepIndex);
                characterStateRule.GenerateAndStoreNextSnapshot(skipPlan, battleActions);
                uiManager.UpdateActionSlots(actionPlanner); // 立刻更新UI顯示這個跳過
            }
        }
    }
    
    private void GoToNextStep()
    {
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;
        
        AdvancePlanningStep();
    }
    #endregion

    #region 規劃階段輔助方法 (Planning Phase Helper Methods)
    private void GoToPlanningSubState(PlanningSubState nextState, bool isForwardStep = true)
    {
        if (isForwardStep && currentSubState != nextState)
        {
            planningHistory.Push(currentSubState);
        }

        currentSubState = nextState;
        
        uiManager.SetBackButtonVisible(planningHistory.Count > 0);

        switch (nextState)
        {
            case PlanningSubState.None:
                if (!isForwardStep) // 只有在“回退”到None時才觸發
                {
                    BattleLog.Instance.AddLog("已返回至行動格規劃起點。");
                    // 清理掉當前步驟可能留下的所有臨時變數
                    selectedUnitForAction = null;
                    selectedActionType = default;
                    // 重新調用AdvancePlanningStep會找到同一個行動格並重新開始
                    AdvancePlanningStep();
                }
                else // 如果是“前進”到None，說明規劃已結束
                {
                    uiManager.ShowPlanningFinishedState();
                }
                break;
                
            case PlanningSubState.SelectingRangedUnit:
                selectedUnitForAction = null;
                selectedActionType = default;
                uiManager.ShowRangedUnitSelection(ConvertFromReadOnlyList(currentEligibleActors), currentPlanningStepIndex);
                break;

            case PlanningSubState.SelectingAction:
                selectedActionType = default;
                var feasibility = battleRules.GetActionFeasibility(selectedUnitForAction, characterStateRule.GetLatestSnapshot(), actionPlanner);
                uiManager.ShowActionSelectionFor(selectedUnitForAction, currentPlanningStepIndex, feasibility);
                break;

            case PlanningSubState.SelectingTarget:
                var validTargets = battleRules.GetValidTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot());
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validTargets));
                break;
                
            case PlanningSubState.SelectingExchangeTarget:
                var validExchangeTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot());
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validExchangeTargets));
                break;
        }
    }

    private List<BattleUnit> ConvertFromReadOnlyList(List<IBattleUnit_ReadOnly> readOnlyList)
    {
        return readOnlyList.Select(u => u.GetMonoBehaviour()).ToList();
    }

    private void ShowActionPanelForUnit(BattleUnit unit)
    {
        var feasibility = battleRules.GetActionFeasibility(unit, characterStateRule.GetLatestSnapshot(), actionPlanner);
        uiManager.ShowActionSelectionFor(unit, currentPlanningStepIndex, feasibility);
    }
    
    private BattleRole GetRoleForStep(int stepIndex)
    {
        return (stepIndex % 2 == 0) ? BattleRole.Vanguard : BattleRole.Ranged1;
    }
    #endregion
    
    #region 行動執行階段 (Action Execution Phase)
    private IEnumerator ExecuteActions()
    {
        foreach(var unit in battleManager.GetAllUnits())
        {
            unit.ResetVisualsToCoreState();
        }

        var processedTransactions = new HashSet<Guid>();
        for (int phase = 1; phase <= 4; phase++)
        {
            // 定義執行順序
            var executionOrder = new[]
            {
                new { IsPlayer = true, Role = BattleRole.Vanguard },
                new { IsPlayer = false, Role = BattleRole.Vanguard },
                new { IsPlayer = true, Role = BattleRole.Ranged1 }, // 代表遠程格
                new { IsPlayer = false, Role = BattleRole.Ranged1 } // 代表遠程格
            };
            
            foreach(var step in executionOrder)
            {
                yield return StartCoroutine(ExecuteStep(phase, step.IsPlayer, step.Role, processedTransactions));
                if (CheckBattleEnd()) yield break; // 如果戰鬥結束，立刻跳出所有迴圈
            }
        }
        
        // 如果迴圈正常結束且戰鬥未結束，則進入下一個規劃回合
        if (CurrentState == BattleState.ActionExecution)
        {
            SetState(BattleState.PlayerPlanning);
        }
    }
    
    private IEnumerator ExecuteStep(int phase, bool isPlayer, BattleRole role, HashSet<Guid> processedTransactions)
    {
        ActionPlan plan = actionPlanner.GetActionForRole(phase, isPlayer, role);
        if (plan != null && plan.Type != ActionType.Skip)
        {
            if (plan.Source != null && !plan.Source.IsDead)
            {
                battleActions.Execute(plan, actionPlanner, processedTransactions, battleManager);
                yield return new WaitForSeconds(1.0f);
            }
        }
    }

    private bool CheckBattleEnd()
    {
        // 戰鬥結束檢查與後續處理
        actionPlanner.RemovePlansFromDeadUnits(battleManager.GetAllUnits());
        battleManager.HandleTeamPromotions();
        uiManager.UpdateActionSlots(actionPlanner);
        
        if (battleRules.IsVictory(battleManager.EnemyUnits))
        {
            SetState(BattleState.Won);
            return true;
        }
        if (battleRules.IsDefeat(battleManager.PlayerUnits))
        {
            SetState(BattleState.Lost);
            return true;
        }
        return false;
    }
    #endregion
}
```

#### **BattleManager.cs**
戰鬥場景總控制器。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattleManager : MonoBehaviour
{
    public static BattleManager Instance { get; private set; }
    public BattleEncounterSO EncounterData { get; private set; }
    public List<BattleUnit> PlayerUnits { get; private set; }
    public List<BattleUnit> EnemyUnits { get; private set; }
    
    public Transform[] GridSpawns => gridSpawns;
    [SerializeField] private Transform[] gridSpawns = new Transform[8];

    [Header("系統模組")]
    [SerializeField] private TurnManager turnManager;
    [SerializeField] private BattleUIManager uiManager;
    [SerializeField] private BattleRules battleRules;
    [SerializeField] private BattleActions battleActions;
    [SerializeField] private EnemyBattleAI enemyAI;
    [SerializeField] private CharacterStateRule characterStateRule;
    [SerializeField] private BattlefieldStateSimulator stateSimulator; // 在編輯器中拖入
    
    private TurnActionPlanner actionPlanner;

    private void Awake() 
    { 
        Instance = this; 
        // 如果沒有在編輯器中指定，就嘗試在場景中尋找
        if (stateSimulator == null)
        {
            stateSimulator = FindObjectOfType<BattlefieldStateSimulator>();
        }
    }
    
    void Start()
    {
        EncounterData = GameManager.Instance.CurrentEncounter;
        if (EncounterData == null) { Debug.LogError("沒有傳入戰鬥遭遇數據！"); return; }
        
        // 先生成單位，再初始化系統，這樣系統才能獲取到單位列表
        SpawnUnits();
        InitializeSystems();
        
        turnManager.StartBattle();
    }

    private void InitializeSystems()
    {
        actionPlanner = new TurnActionPlanner();
        turnManager.Initialize(this, uiManager, actionPlanner, battleRules, battleActions, enemyAI, characterStateRule, stateSimulator);
        uiManager.Initialize(turnManager);
        stateSimulator.Initialize(GetAllUnits());
    }
    
    private void SpawnUnits()
    {
        PlayerUnits = new List<BattleUnit>();
        EnemyUnits = new List<BattleUnit>();
    
        var battleParty = PartyManager.Instance.BattleParty;
        for (int i = 0; i < battleParty.Count; i++)
        {
            var role = (BattleRole)i;
            var position = GetInitialPositionForRole(role, true);
            var spawnTransform = gridSpawns[(int)position];
            
            GameObject unitGO = Instantiate(battleParty[i].BaseData.unitPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(battleParty[i], role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            PlayerUnits.Add(unit);
        }
        foreach (var enemyPos in EncounterData.enemyTeam)
        {
            var role = enemyPos.role;
            var position = GetInitialPositionForRole(role, false);
            var spawnTransform = gridSpawns[(int)position];
            GameObject unitGO = Instantiate(enemyPos.enemyData.enemyPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(enemyPos.enemyData, role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            EnemyUnits.Add(unit);
        }
    }
    
    private GridPosition GetInitialPositionForRole(BattleRole role, bool isPlayer)
    {
        if (isPlayer)
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.PlayerVanguard;
                case BattleRole.Ranged1:  return GridPosition.PlayerRanged1;
                case BattleRole.Ranged2:  return GridPosition.PlayerRanged2;
                case BattleRole.Support:  return GridPosition.PlayerSupport;
            }
        }
        else
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.EnemyVanguard;
                case BattleRole.Ranged1:  return GridPosition.EnemyRanged1;
                case BattleRole.Ranged2:  return GridPosition.EnemyRanged2;
                case BattleRole.Support:  return GridPosition.EnemySupport;
            }
        }
        throw new System.Exception("無效的角色或隊伍");
    }
    
    public void HandleTeamPromotions()
    {
        CheckAndPromoteForTeam(PlayerUnits);
        CheckAndPromoteForTeam(EnemyUnits);
    }

    private void CheckAndPromoteForTeam(List<BattleUnit> team)
    {
        var promotionOrder = new List<GridPosition> { GridPosition.PlayerVanguard, GridPosition.PlayerRanged1, GridPosition.PlayerRanged2, GridPosition.PlayerSupport };
        if (team.Any() && !team.First().IsPlayerTeam)
        {
            promotionOrder = new List<GridPosition> { GridPosition.EnemyVanguard, GridPosition.EnemyRanged1, GridPosition.EnemyRanged2, GridPosition.EnemySupport };
        }
        
        for (int i = 0; i < promotionOrder.Count - 1; i++)
        {
            GridPosition currentPos = promotionOrder[i];
            BattleUnit unitAtCurrentPos = GetUnitAtPosition(currentPos, team);
            if (unitAtCurrentPos == null || unitAtCurrentPos.IsDead)
            {
                for (int j = i + 1; j < promotionOrder.Count; j++)
                {
                    GridPosition substitutePos = promotionOrder[j];
                    BattleUnit substituteUnit = GetUnitAtPosition(substitutePos, team);
                    if (substituteUnit != null && !substituteUnit.IsDead)
                    {
                        BattleLog.Instance.AddLog($"{substituteUnit.UnitName} 自動替補到 {currentPos} 位置！");
                        substituteUnit.SetNewPosition(currentPos);
                        substituteUnit.transform.position = gridSpawns[(int)currentPos].position;
                        break;
                    }
                }
            }
        }
    }

    public BattleUnit GetUnitAtPosition(GridPosition pos, List<BattleUnit> team) => team.FirstOrDefault(u => u.CurrentPosition == pos && !u.IsDead);
    public List<BattleUnit> GetAllUnits() => PlayerUnits.Concat(EnemyUnits).ToList();
    public List<BattleUnit> GetOpposingTeam(BattleUnit unit) => unit.IsPlayerTeam ? EnemyUnits : PlayerUnits;
    public List<BattleUnit> GetSameTeam(BattleUnit unit) => unit.IsPlayerTeam ? PlayerUnits : EnemyUnits;
    public BattleUnit GetUnitAtPosition(GridPosition pos)
    {
        if (pos == GridPosition.None) return null;
        return GetAllUnits().FirstOrDefault(u => !u.IsDead && u.CurrentPosition == pos);
    }
    public bool IsBattleWon()
    {
        return turnManager != null && turnManager.CurrentState == BattleState.Won;
    }
}
```

#### **BattleUIManager.cs**
UI 系統協調者。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class BattleUIManager : MonoBehaviour
{
    private TurnManager turnManager;

    [Header("UI 面板")]
    [SerializeField] private ActionPanelUI actionPanel;
    [SerializeField] private ActionSlotPanelUI actionSlotPanel;
    [SerializeField] private BattleUI battleUI;
    [SerializeField] private BattleEndUI battleEndUI;
    
    public void Initialize(TurnManager tm)
    {
        turnManager = tm;
        // 使用 Lambda 表達式來匹配 Setup 的參數需求
        battleUI.Setup(cmd => OnUICommand(cmd, null));
        actionSlotPanel.Initialize((cmd, plan) => OnUICommand(cmd, plan));
    }

    // --- 狀態進入時的 UI 設置 ---
    public void EnterPlayerPlanningState(TurnActionPlanner planner)
    {
        HideAllActionPanels();
        actionSlotPanel.UpdatePanel(planner);
        actionSlotPanel.gameObject.SetActive(true);
        battleUI.SetEndTurnButtonInteractable(false); // 規劃完成前不可結束
        battleUI.SetResetButtonVisible(true);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterEnemyTurnState()
    {
        HideAllActionPanels();
        battleUI.SetEndTurnButtonInteractable(false);
        battleUI.SetResetButtonVisible(false);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterActionExecutionState()
    {
        HideAllActionPanels();
    }
    
    // --- 引導式規劃的 UI 顯示 ---
    public void ShowRangedUnitSelection(List<BattleUnit> units, int stepIndex)
    {
        HideAllActionPanels();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        units.ForEach(u => u.SetHighlight(true));
        battleUI.SetBackButtonVisible(false); // 選擇單位是第一步，不能返回
        BattleLog.Instance.AddLog("請選擇一位遠程單位來規劃行動。");
    }

    public void ShowActionSelectionFor(BattleUnit unit, int stepIndex, Dictionary<ActionType, bool> feasibility)
    {
        DeselectAllHighlights();
        unit.SetHighlight(true);
        
        actionPanel.ShowPanel(unit, turnManager.OnActionSelected);
        actionPanel.UpdateButtonStates(feasibility); // 更新按鈕狀態
        
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        battleUI.SetBackButtonVisible(true);
    }
    
    public void ShowTargetSelection(List<BattleUnit> validTargets)
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        validTargets.ForEach(t => t.SetHighlight(true));
        BattleLog.Instance.AddLog("請選擇一個目標。");
    }

    public void ShowPlanningFinishedState()
    {
        HideAllActionPanels();
        actionSlotPanel.SetPlanningHighlight(-1); // 關閉所有高亮
        battleUI.SetEndTurnButtonInteractable(true);
        battleUI.SetBackButtonVisible(false);
    }
    
    public void UpdateActionSlots(TurnActionPlanner planner)
    {
        actionSlotPanel.UpdatePanel(planner);
    }

    // --- 其他 UI 控制 ---
    public void ShowVictoryScreen(int gold) { battleEndUI.ShowVictory(gold); }
    public void ShowDefeatScreen() { battleEndUI.ShowDefeat(); }
    public void SetResetButtonVisible(bool visible)
    {
        if (battleUI != null)
        {
            battleUI.SetResetButtonVisible(visible);
        }
    }
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        if (battleUI != null)
        {
            battleUI.SetEndTurnButtonInteractable(interactable);
        }
    }
    public void SetBackButtonVisible(bool visible)
    {
        if (battleUI != null)
        {
            battleUI.SetBackButtonVisible(visible);
        }
    }
    
    private void HideAllActionPanels()
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(-1);
    }

    private void DeselectAllHighlights()
    {
        if (BattleManager.Instance == null) return;
        foreach(var unit in BattleManager.Instance.PlayerUnits) unit.SetHighlight(false);
        foreach(var unit in BattleManager.Instance.EnemyUnits) unit.SetHighlight(false);
    }

    // --- 輸入中繼 ---
    private void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        turnManager.OnUICommand(command, planData);
    }
}
```

#### **GameManager.cs**
遊戲狀態管理器。

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Linq;
using System.Collections.Generic;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    
    public BattleEncounterSO CurrentEncounter { get; private set; }
    
    private string mainSceneName = "Title"; // 假設您的非戰鬥場景名
    private string battleSceneName = "BattleScene"; // 假設您的戰鬥場景名

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    public void StartBattle(BattleEncounterSO encounter)
    {
        CurrentEncounter = encounter;
        SceneManager.LoadScene(battleSceneName);
    }

    public void EndBattle()
    {
        ProcessBattleResults();
        UpdatePartyStatusAfterBattle();
        // 可以在這裡處理獎勵發放等邏輯
        CurrentEncounter = null;
        SceneManager.LoadScene(mainSceneName);
    }

    private void UpdatePartyStatusAfterBattle()
    {
        // 檢查 BattleManager 和 PartyManager 是否存在，避免在編輯器中單獨運行場景時出錯
        if (BattleManager.Instance == null || PartyManager.Instance == null)
        {
            Debug.LogWarning("無法更新隊伍狀態，因為 BattleManager 或 PartyManager 不存在。");
            return;
        }

        // 遍歷所有參與戰鬥的玩家單位
        foreach (var unit in BattleManager.Instance.PlayerUnits)
        {
            // 在 PartyManager 的總成員列表中，找到與之對應的那個實例
            // 我們使用獨一無二的 instanceID 來進行匹配
            MemberInstance instanceToUpdate = PartyManager.Instance.AllMembers.FirstOrDefault(
                m => m.instanceID == unit.MemberInstance.instanceID
            );

            if (instanceToUpdate != null)
            {
                // 將戰鬥結束時的血量寫回實例
                instanceToUpdate.currentHP = unit.CurrentHP;
                Debug.Log($"已更新成員 [{instanceToUpdate.BaseData.memberName}] 的血量為: {instanceToUpdate.currentHP}");
            }
        }
        // (可選) 在這裡也可以觸發一次存檔
        // PartyManager.Instance.SaveParty();
    }

    private void ProcessBattleResults()
    {
        if (BattleManager.Instance == null) return;
        
        // 檢查戰鬥是否勝利 (失敗則不處理獎勵和進度)
        if (BattleManager.Instance.IsBattleWon())
        {
            // 處理金錢和經驗值獎勵
            var encounterData = BattleManager.Instance.EncounterData;
            int totalGold = 0;
            // int totalExp = 0; // 暫時註解掉未使用的變數

            foreach(var enemyUnit in BattleManager.Instance.EnemyUnits)
            {
                if(enemyUnit.EnemyData != null)
                {
                    totalGold += enemyUnit.EnemyData.goldDrop;
                    // totalExp += enemyUnit.EnemyData.expDrop; // 這行也保持註解
                }
            }

            if(PlayerState.Instance != null)
            {
                PlayerState.Instance.AddMoney(totalGold);
                // PlayerState.Instance.GainExperience(totalExp); // 這行也保持註解
                Debug.Log($"戰鬥勝利！獲得金幣: {totalGold}");
            }

            // 處理擊殺任務進度
            if (QuestManager.Instance != null)
            {
                foreach (var enemyUnit in BattleManager.Instance.EnemyUnits)
                {
                    // 確保只計算被擊殺的敵人
                    if (enemyUnit.IsDead && enemyUnit.EnemyData != null)
                    {
                        string enemyID = enemyUnit.EnemyData.enemyID;
                        QuestManager.Instance.AdvanceObjective(enemyID, QuestObjectiveType.Kill, 1);
                        Debug.Log($"向任務系統報告擊殺: {enemyID}");
                    }
                }
            }
        }
    }
}
```

---

### **5. 戰鬥邏輯**

#### **BattleRules.cs**
戰鬥法典。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "BattleRules", menuName = "Battle System/Battle Rules")]
public class BattleRules : ScriptableObject
{
    // --- 查詢行動資格 ---
    public List<IBattleUnit_ReadOnly> GetEligibleActorsForStep(int stepIndex, List<CharacterStateRule.UnitStateSnapshot> currentState, TurnActionPlanner planner)
    {
        var eligibleActors = new List<IBattleUnit_ReadOnly>();
        bool isVanguardStep = (stepIndex % 2 == 0);
        
        // 獲取所有存活的玩家單位快照
        var potentialActorSnaps = currentState.Where(s => s.Unit.IsPlayerTeam && !s.Unit.IsDead).ToList();

        foreach (var snap in potentialActorSnaps)
        {
            // 檢查單位的【快照職責】是否與【步驟類型】匹配
            bool isUnitVanguardInSnapshot = (snap.Role == BattleRole.Vanguard);
            if ((isVanguardStep && !isUnitVanguardInSnapshot) || (!isVanguardStep && isUnitVanguardInSnapshot)) continue;

            // 根據【快照職責】決定最大行動次數
            int maxActions = (snap.Role == BattleRole.Vanguard) ? 4 : 2;

            // 判斷該單位的已規劃行動次數是否已達上限
            if (planner.GetActionCountForUnit(snap.Unit) < maxActions)
            {
                eligibleActors.Add(snap.Unit);
            }
        }
        return eligibleActors;
    }

    private bool CanUnitAct(IBattleUnit_ReadOnly unit, TurnActionPlanner planner, int maxActions)
    {
        if (unit == null || unit.IsDead) return false;
        return planner.GetActionCountForUnit(unit) < maxActions;
    }
    
    // --- 查詢行動可行性 (給UI按鈕用) ---
    public Dictionary<ActionType, bool> GetActionFeasibility(IBattleUnit_ReadOnly actor, List<CharacterStateRule.UnitStateSnapshot> currentState, TurnActionPlanner planner)
    {
        var feasibility = new Dictionary<ActionType, bool>();
        
        // 攻擊
        feasibility[ActionType.Attack] = GetValidTargets(actor, currentState).Any();
        // 交換
        feasibility[ActionType.Exchange] = GetValidExchangeTargets(actor, currentState).Any();
        
        // 體力檢查
        var actorSnap = currentState.First(s => s.Unit == actor);
        if (actorSnap.Stamina < 3) feasibility[ActionType.Attack] = false;
        if (actorSnap.Stamina < 2) feasibility[ActionType.Exchange] = false;

        // 其他行動總是可行
        feasibility[ActionType.Defend] = true;
        feasibility[ActionType.Rest] = true;
        feasibility[ActionType.Skip] = true;
        
        return feasibility;
    }

    public List<IBattleUnit_ReadOnly> GetValidTargets(IBattleUnit_ReadOnly attacker, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (attacker == null || attacker.IsDead) return validTargets;

        var attackerSnap = currentState.First(s => s.Unit == attacker);
        var opponentSnaps = currentState.Where(s => s.Unit.IsPlayerTeam != attacker.IsPlayerTeam && !s.Unit.IsDead);

        var enemyVanguardSnap = opponentSnaps.FirstOrDefault(s => s.Role == BattleRole.Vanguard);

        IEnumerable<CharacterStateRule.UnitStateSnapshot> potentialTargets = (enemyVanguardSnap != null) 
            ? new List<CharacterStateRule.UnitStateSnapshot> { enemyVanguardSnap } 
            : opponentSnaps;

        foreach (var targetSnap in potentialTargets)
        {
            int distance = Mathf.Abs((int)attackerSnap.Position - (int)targetSnap.Position);
            if (distance <= attacker.AttackRange)
            {
                validTargets.Add(targetSnap.Unit);
            }
        }
        return validTargets;
    }
    
    public List<IBattleUnit_ReadOnly> GetValidExchangeTargets(IBattleUnit_ReadOnly actor, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (actor == null || actor.IsDead || actor.Role == BattleRole.Support) return validTargets;
        
        var actorSnap = currentState.First(s => s.Unit == actor);
        var teammateSnaps = currentState.Where(s => s.Unit.IsPlayerTeam == actor.IsPlayerTeam && s.Unit != actor && !s.Unit.IsDead);

        foreach (var mateSnap in teammateSnaps)
        {
            bool canSwap = false;
            switch (actorSnap.Role)
            {
                case BattleRole.Vanguard: canSwap = (mateSnap.Role == BattleRole.Ranged1); break;
                case BattleRole.Ranged1: canSwap = (mateSnap.Role == BattleRole.Vanguard || mateSnap.Role == BattleRole.Ranged2); break;
                case BattleRole.Ranged2: canSwap = (mateSnap.Role == BattleRole.Ranged1); break;
            }
            if(canSwap) validTargets.Add(mateSnap.Unit);
        }
        return validTargets;
    }

    public bool IsVictory(List<BattleUnit> enemyUnits) => enemyUnits.All(u => u.IsDead);
    public bool IsDefeat(List<BattleUnit> playerUnits) => playerUnits.All(u => u.IsDead);
}
```

#### **BattleActions.cs**
行動邏輯的執行者。

```csharp
using UnityEngine;
using System;
using System.Linq;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "BattleActions", menuName = "Battle System/Battle Actions")]
public class BattleActions : ScriptableObject
{
    [Header("行動數值")]
    [SerializeField] private int attackStaminaCost = 3;
    [SerializeField] private int exchangeStaminaCost = 2;
    [SerializeField] private int restStaminaRecovery = 5;

    public int GetAttackStaminaCost() => attackStaminaCost;
    public int GetExchangeStaminaCost() => exchangeStaminaCost;

    public void Execute(ActionPlan plan, TurnActionPlanner planner, HashSet<Guid> processedTransactions, BattleManager battleManager)
    {
        // 1. 驗證甲方 (Source)
        BattleUnit sourceUnit = plan.Source?.GetMonoBehaviour();
        if (sourceUnit == null || sourceUnit.IsDead) return;
        // 2. 處理關聯行動的唯一性 (交換位置)
        if (plan.Type == ActionType.Exchange && plan.TransactionID != Guid.Empty)
        {
            if (processedTransactions.Contains(plan.TransactionID)) return;
            processedTransactions.Add(plan.TransactionID);
        }
        // 指令失效規則的重新定義
        ActionType finalActionType = plan.Type;
        BattleUnit finalTargetUnit = null; // 最終要被操作的對象

        // 根據行動類型，決定採用哪種鎖定策略
        switch (plan.Type)
        {
            // === 地域契約 (Position-based) ===
            case ActionType.Attack:
                // 在執行前一刻，去目標位置上看到底是誰
                finalTargetUnit = battleManager.GetUnitAtPosition(plan.TargetPosition);
                
                // 指令失效判斷：如果目標位置上沒人，或者站著自己人
                if (finalTargetUnit == null || finalTargetUnit.IsPlayerTeam == sourceUnit.IsPlayerTeam)
                {
                    finalActionType = (sourceUnit.Role == BattleRole.Vanguard) ? ActionType.Defend : ActionType.Rest;
                    BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 的攻擊位置 [{plan.TargetPosition}] 已無有效目標，行動變更為 [{finalActionType.ToActionName()}]！");
                    finalTargetUnit = null; // 失效後沒有目標
                }
                break;

            // === 人事契約 (Person-based) ===
            case ActionType.Exchange:
                // 直接從契約獲取乙方本人
                finalTargetUnit = plan.Target?.GetMonoBehaviour();

                // 指令失效判斷：如果契約乙方不存在或已陣亡
                if (finalTargetUnit == null || finalTargetUnit.IsDead)
                {
                    finalActionType = ActionType.Rest;
                    BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 的交換目標 [{plan.Target.UnitName}] 已消失，行動變更為 [{finalActionType.ToActionName()}]！");
                    finalTargetUnit = null; // 失效後沒有目標
                }
                break;

            // === 無目標行動 ===
            case ActionType.Defend:
            case ActionType.Rest:
            case ActionType.Skip:
                finalTargetUnit = null; // 這些行動沒有目標
                break;
        }
        
        // 3. 根據最終決定的行動和目標來執行
        switch (finalActionType)
        {
            case ActionType.Attack:
                ExecuteAttack(sourceUnit, finalTargetUnit); // 傳入最終確認的目標
                break;
            case ActionType.Defend:
                ExecuteDefend(sourceUnit);
                break;
            case ActionType.Rest:
                ExecuteRest(sourceUnit);
                break;
            case ActionType.Exchange:
                ExecuteExchange(sourceUnit, finalTargetUnit, battleManager); // 傳入最終確認的目標
                break;
            case ActionType.Skip:
                BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 選擇跳過行動。");
                break;
        }
    }

    private void ExecuteAttack(BattleUnit source, BattleUnit target)
    {
        // 消耗發起者的體力
        source.ConsumeStamina(attackStaminaCost);
        BattleLog.Instance.AddLog($"{source.UnitName} 對 {target.UnitName} 發動攻擊！");
        target.TakeDamage(source.CurrentAttack);
    }
    
    private void ExecuteDefend(BattleUnit source)
    {
        source.SetDefenseState(true);
        BattleLog.Instance.AddLog($"{source.UnitName} 進入防禦姿態。");
    }

    private void ExecuteRest(BattleUnit source)
    {
        source.RestoreStamina(restStaminaRecovery);
        BattleLog.Instance.AddLog($"{source.UnitName} 休息，恢復 {restStaminaRecovery} 體力。");
    }

    private void ExecuteExchange(BattleUnit source, BattleUnit target, BattleManager battleManager)
    {
        // 消耗發起者的體力 (注意：被動交換方不消耗體力)
        source.ConsumeStamina(exchangeStaminaCost);
        BattleLog.Instance.AddLog($"{source.UnitName} 與 {target.UnitName} 進行位置交換！");

        // 獲取雙方【當前】的核心數據
        GridPosition posA = source.CurrentPosition;
        GridPosition posB = target.CurrentPosition;
        BattleRole roleA = source.Role;
        BattleRole roleB = target.Role;

        // --- 執行核心數據交換 ---
        source.SetNewPosition(posB);
        target.SetNewPosition(posA);
        source.SetRole(roleB);
        target.SetRole(roleA);

        // --- 執行視覺交換 ---(可以考慮未來將這部分移到動畫控制器中)
        if (battleManager.GridSpawns[(int)posB] != null)
        {
            source.transform.position = battleManager.GridSpawns[(int)posB].position;
        }
        if (battleManager.GridSpawns[(int)posA] != null)
        {
            target.transform.position = battleManager.GridSpawns[(int)posA].position;
        }
    }
}
```

#### **TurnActionPlanner.cs**
回合行動規劃器。

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class TurnActionPlanner
{
    private const int TOTAL_PLAYER_STEPS = 8;
    
    private Dictionary<int, ActionPlan> playerPlansByStep = new Dictionary<int, ActionPlan>();
    private List<ActionPlan> enemyPlans = new List<ActionPlan>();

    public int GetPlayerPlanCount() => playerPlansByStep.Count;
    public bool IsPlanningFinished() => playerPlansByStep.Count >= TOTAL_PLAYER_STEPS;
    public bool IsStepPlanned(int stepIndex) => playerPlansByStep.ContainsKey(stepIndex);

    public int GetNextPlanningStepIndex()
    {
        for (int i = 0; i < TOTAL_PLAYER_STEPS; i++)
        {
            if (!playerPlansByStep.ContainsKey(i))
            {
                return i;
            }
        }
        return TOTAL_PLAYER_STEPS;
    }
    
    public int FindNextAvailableStep(BattleRole role, int startIndex = 0, List<int> excludeIndices = null)
    {
        bool isLookingForVanguard = (role == BattleRole.Vanguard);
        excludeIndices = excludeIndices ?? new List<int>();

        for (int i = startIndex; i < TOTAL_PLAYER_STEPS; i++)
        {
            // 檢查是否已被佔用或在排除列表內
            if (playerPlansByStep.ContainsKey(i) || excludeIndices.Contains(i)) continue;

            bool isVanguardStep = (i % 2 == 0);
            
            // 判斷格子類型是否匹配
            if ((isLookingForVanguard && isVanguardStep) || (!isLookingForVanguard && !isVanguardStep)) return i;
        }
        return -1; // 遍歷完都沒找到
    }

    public void AddPlan(ActionPlan plan, int stepIndex)
    {
        if (plan.Type == ActionType.Skip || plan.Source == null)
        {
            if (stepIndex >= 0 && stepIndex < TOTAL_PLAYER_STEPS)
            {
                playerPlansByStep[stepIndex] = plan;
            }
            return;
        }

        if (plan.Source.IsPlayerTeam)
        {
            if (stepIndex >= 0 && stepIndex < TOTAL_PLAYER_STEPS)
            {
                playerPlansByStep[stepIndex] = plan;
            }
            else
            {
                Debug.LogError($"嘗試為玩家計畫添加無效的步驟索引: {stepIndex}");
            }
        }
        else
        {
            enemyPlans.Add(plan);
        }
    }

    public ActionPlan GetPlanAtStep(int stepIndex)
    {
        playerPlansByStep.TryGetValue(stepIndex, out ActionPlan plan);
        return plan;
    }

    public int GetStepIndexOfPlan(ActionPlan plan)
    {
        if (plan == null) return -1;
        foreach (var pair in playerPlansByStep)
        {
            if (pair.Value == plan)
            {
                return pair.Key;
            }
        }
        return -1;
    }
    
    public int GetLastPlanStepIndex()
    {
        if (playerPlansByStep.Count == 0) return -1;
        return playerPlansByStep.Keys.Max();
    }
    
    // 從指定步驟開始，移除之後的所有行動計畫
    public void RemovePlansFromStep(int stepIndex)
    {
        if (playerPlansByStep.TryGetValue(stepIndex, out ActionPlan planToRemove))
        {
            // 如果是關聯行動，找到所有相關計畫並移除
            if (planToRemove.TransactionID != Guid.Empty)
            {
                var keysToRemove = playerPlansByStep
                    .Where(pair => pair.Value.TransactionID == planToRemove.TransactionID)
                    .Select(pair => pair.Key)
                    .ToList();
                
                foreach (var key in keysToRemove)
                {
                    playerPlansByStep.Remove(key);
                }
            }
            else
            {
                // 只移除單個計畫
                playerPlansByStep.Remove(stepIndex);
            }
        }
    }
    
    public void ClearPlayerPlans()
    {
        playerPlansByStep.Clear();
    }
    
    public void PrepareForNewTurn()
    {
        var allUnitsWithDefense = new HashSet<IBattleUnit_ReadOnly>();
        foreach(var plan in playerPlansByStep.Values)
        {
            if (plan.Type == ActionType.Defend) allUnitsWithDefense.Add(plan.Source);
        }
        foreach(var plan in enemyPlans)
        {
            if (plan.Type == ActionType.Defend) allUnitsWithDefense.Add(plan.Source);
        }

        foreach(var unit in allUnitsWithDefense)
        {
            unit.GetMonoBehaviour().SetDefenseState(false);
        }
        playerPlansByStep.Clear();
        enemyPlans.Clear();
    }

    public ActionPlan GetActionForRole(int phase, bool isPlayer, BattleRole role)
    {
        if (isPlayer)
        {
            for (int i = 0; i < 8; i++)
            {
                if (playerPlansByStep.TryGetValue(i, out ActionPlan plan))
                {
                    bool isVanguardStep = (plan.PlannedForRole == BattleRole.Vanguard);
                    bool roleMatch = (role == BattleRole.Vanguard) ? isVanguardStep : !isVanguardStep;

                    if (plan.PhaseIndex == phase && roleMatch) return plan;
                }
            }
            return null;
        }
        else
        {
            return enemyPlans.FirstOrDefault(p =>
                p.PhaseIndex == phase &&
                (p.Source == null || !p.Source.IsPlayerTeam) && 
                (
                    (role == BattleRole.Vanguard && p.PlannedForRole == BattleRole.Vanguard) ||
                    (role != BattleRole.Vanguard && (p.PlannedForRole == BattleRole.Ranged1 || p.PlannedForRole == BattleRole.Ranged2))
                )
            );
        }
    }
    
    public int GetActionCountForUnit(IBattleUnit_ReadOnly unit)
    {
        return playerPlansByStep.Values.Count(p => p.Source == unit) + enemyPlans.Count(p => p.Source == unit);
    }
    
    public void RemovePlansFromDeadUnits(List<BattleUnit> allUnits)
    {
        var deadUnits = allUnits.Where(u => u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
        if (deadUnits.Any())
        {
            var playerKeysToRemove = playerPlansByStep
                .Where(pair => deadUnits.Contains(pair.Value.Source) || (pair.Value.Target != null && deadUnits.Contains(pair.Value.Target)))
                .Select(pair => pair.Key)
                .ToList();
                
            foreach (var key in playerKeysToRemove)
            {
                playerPlansByStep.Remove(key);
            }
            
            int removedEnemyCount = enemyPlans.RemoveAll(p => deadUnits.Contains(p.Source) || (p.Target != null && deadUnits.Contains(p.Target)));

            if (playerKeysToRemove.Count > 0 || removedEnemyCount > 0)
            {
                BattleLog.Instance.AddLog($"因單位陣亡，移除了 {playerKeysToRemove.Count + removedEnemyCount} 個無效的行動計畫。");
            }
        }
    }
}
```
**注意**: `TurnActionPlanner` 不適合做成 ScriptableObject，因為它需要儲存每一場戰鬥的即時數據。這裡我已將其改為一個普通的類，您需要在 `BattleManager` 中 `new TurnActionPlanner()` 來創建實例。

#### **CharacterStateRule.cs**
管理戰鬥中角色在特定時間點的狀態變化規則。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "CharacterStateRule", menuName = "Battle System/Character State Rule")]
public class CharacterStateRule : ScriptableObject
{
    public class UnitStateSnapshot
    {
        public IBattleUnit_ReadOnly Unit { get; }
        public int Stamina { get; }
        public GridPosition Position { get; }
        public BattleRole Role { get; }
        
        public UnitStateSnapshot(IBattleUnit_ReadOnly unit)
        {
            Unit = unit;
            Stamina = unit.CurrentStamina;
            Position = unit.CurrentPosition;
            Role = unit.Role;
        }

        public UnitStateSnapshot(UnitStateSnapshot source)
        {
            Unit = source.Unit;
            Stamina = source.Stamina;
            Position = source.Position;
            Role = source.Role;
        }
        
        public UnitStateSnapshot(UnitStateSnapshot source, int newStamina, GridPosition newPosition, BattleRole newRole)
        {
            Unit = source.Unit;
            Stamina = newStamina;
            Position = newPosition;
            Role = newRole;
        }
    }

    private List<List<UnitStateSnapshot>> planningStepSnapshots = new List<List<UnitStateSnapshot>>();

    public void InitializeSnapshots(List<BattleUnit> allUnits)
    {
        planningStepSnapshots.Clear();
        List<UnitStateSnapshot> initialSnapshot = new List<UnitStateSnapshot>();
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                initialSnapshot.Add(new UnitStateSnapshot(unit));
            }
        }

        if (planningStepSnapshots.Count == 0)
        {
             planningStepSnapshots.Add(initialSnapshot);
        }
        else
        {
            planningStepSnapshots[0] = initialSnapshot;
        }
        Debug.Assert(planningStepSnapshots.Count == 1, "初始化後，快照列表長度不為1！");
    }
    
    public List<UnitStateSnapshot> GetLatestSnapshot()
    {
        if (planningStepSnapshots.Count == 0)
        {
            Debug.LogError("嚴重錯誤：快照列表為空！無法獲取最新快照。");
            return new List<UnitStateSnapshot>();
        }
        return planningStepSnapshots.Last();
    }
    
    public void PruneSnapshotsToCount(int targetCount)
    {
        if (targetCount < 1) targetCount = 1;

        if (planningStepSnapshots.Count > targetCount)
        {
            int removeCount = planningStepSnapshots.Count - targetCount;
            planningStepSnapshots.RemoveRange(targetCount, removeCount);
        }
    }

    public void GenerateAndStoreNextSnapshot(ActionPlan plan, BattleActions actionCosts)
    {
        List<UnitStateSnapshot> previousState = GetLatestSnapshot();
        List<UnitStateSnapshot> nextState = previousState.Select(s => new UnitStateSnapshot(s)).ToList();

        if (plan.Type == ActionType.Skip || plan.Source == null)
        {
            planningStepSnapshots.Add(nextState);
            return;
        }

        var sourceSnap = nextState.FirstOrDefault(s => s.Unit == plan.Source);
        if (sourceSnap == null)
        {
            Debug.LogWarning($"在快照中找不到計畫發起者 {plan.Source.UnitName}，跳過快照生成。");
            planningStepSnapshots.Add(nextState);
            return;
        }
        
        int sourceIndex = nextState.IndexOf(sourceSnap);
        int newStamina = sourceSnap.Stamina;
        GridPosition newSourcePos = sourceSnap.Position;
        BattleRole newSourceRole = sourceSnap.Role;

        switch (plan.Type)
        {
            case ActionType.Attack:
                newStamina -= actionCosts.GetAttackStaminaCost();
                break;
            case ActionType.Defend:
            case ActionType.Rest:
                // 根據未來設計，可以在此處修改體力或添加狀態
                break;
            case ActionType.Exchange:
                newStamina -= actionCosts.GetExchangeStaminaCost();
                var targetSnap = nextState.FirstOrDefault(s => s.Unit == plan.Target);
                if (targetSnap != null)
                {
                    int targetIndex = nextState.IndexOf(targetSnap);
                    newSourcePos = targetSnap.Position;
                    GridPosition newTargetPos = sourceSnap.Position;
                    newSourceRole = targetSnap.Role;
                    BattleRole newTargetRole = sourceSnap.Role;
                    nextState[targetIndex] = new UnitStateSnapshot(targetSnap, targetSnap.Stamina, newTargetPos, newTargetRole);
                }
                break;
        }
        nextState[sourceIndex] = new UnitStateSnapshot(sourceSnap, newStamina, newSourcePos, newSourceRole);
        
        planningStepSnapshots.Add(nextState);
    }
    
    public void RestoreAllUnitStamina(List<BattleUnit> allUnits)
    {
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                unit.SetStamina(unit.MaxStamina);
            }
        }
    }
}
```

#### **EnemyBattleAI.cs**
敵人進攻邏輯。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "EnemyBattleAI", menuName = "Battle System/Enemy AI")]
public class EnemyBattleAI : ScriptableObject
{
    public void PlanActions(List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules, int attackCost)
    {
        // 敵人AI不需要模擬，它直接基於當前核心數據規劃
        // 為了讓 GetValidTargets 能工作，我們需要創建一個臨時的當前狀態快照
        var allUnits = selfUnits.Concat(opponentUnits).ToList();
        var currentStateSnapshot = allUnits.Where(u => !u.IsDead).Select(u => new CharacterStateRule.UnitStateSnapshot(u)).ToList();
        
        PlanForRole(BattleRole.Vanguard, 4, selfUnits, planner, rules, attackCost, currentStateSnapshot);
        PlanForRole(BattleRole.Ranged1, 2, selfUnits, planner, rules, attackCost, currentStateSnapshot);
        PlanForRole(BattleRole.Ranged2, 2, selfUnits, planner, rules, attackCost, currentStateSnapshot);
        
        BattleLog.Instance.AddLog("敵人已完成行動規劃。");
    }

    private void PlanForRole(BattleRole planningForRole, int maxActions, List<BattleUnit> self, TurnActionPlanner planner, BattleRules rules, int attackCost, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        GridPosition targetPosition = GetGridPositionForRole(planningForRole, false);
        BattleUnit unit = self.FirstOrDefault(u => u.CurrentPosition == targetPosition && !u.IsDead);
        
        if (unit == null) return;

        int actionsToPlan = maxActions - planner.GetActionCountForUnit(unit);

        for (int i = 0; i < actionsToPlan; i++)
        {
            // 尋找可用階段的邏輯現在不需要了，因為敵人的計畫是用一個簡單的列表管理的
            // 簡化：敵人總是從 phase 1 開始規劃
            int phaseIndex = (planner.GetActionCountForUnit(unit) / 2) + 1; // 粗略計算
            if (phaseIndex > 4) break;

            ActionType action = ActionType.Attack;
            if (unit.CurrentStamina < attackCost)
            {
                action = ActionType.Defend;
            }

            // 調用 GetValidTargets 時傳入快照
            var targets = rules.GetValidTargets(unit, currentState);
            IBattleUnit_ReadOnly readOnlyTarget = targets.FirstOrDefault();
            BattleUnit target = readOnlyTarget?.GetMonoBehaviour();

            if (target != null && action == ActionType.Attack)
            {
                // 使用 AddPlan 的單參數版本
                planner.AddPlan(new ActionPlan(unit, target, action, phaseIndex, planningForRole), -1); // 敵人計畫不需要 step index
                unit.ConsumeStamina(attackCost); // 敵人的體力是即時扣除的
            }
            else
            {
                planner.AddPlan(new ActionPlan(unit, null, ActionType.Defend, phaseIndex, planningForRole), -1);
            }
        }
    }
    
    // GetGridPositionForRole 方法保持不變
    private GridPosition GetGridPositionForRole(BattleRole role, bool isPlayer)
    {
        if (isPlayer)
        {
            switch(role)
            {
                case BattleRole.Vanguard: return GridPosition.PlayerVanguard;
                case BattleRole.Ranged1: return GridPosition.PlayerRanged1;
                case BattleRole.Ranged2: return GridPosition.PlayerRanged2;
                case BattleRole.Support: return GridPosition.PlayerSupport;
            }
        }
        else
        {
            switch(role)
            {
                case BattleRole.Vanguard: return GridPosition.EnemyVanguard;
                case BattleRole.Ranged1: return GridPosition.EnemyRanged1;
                case BattleRole.Ranged2: return GridPosition.EnemyRanged2;
                case BattleRole.Support: return GridPosition.EnemySupport;
            }
        }
        return GridPosition.None;
    }
}
```

### **BattlefieldStateSimulator.cs**
戰場狀態模擬器。
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattlefieldStateSimulator : MonoBehaviour
{
    private List<BattleUnit> allUnits;

    // 初始化模擬器，讓它知道場上有哪些單位
    public void Initialize(List<BattleUnit> units)
    {
        allUnits = units;
    }

    // 根據傳入的快照，命令所有單位更新其視覺表現
    public void ShowStateFromSnapshot(List<CharacterStateRule.UnitStateSnapshot> snapshot)
    {
        if (snapshot == null)
        {
            Debug.LogError("傳入的快照為空，無法更新視覺！");
            return;
        }

        // 步驟一：【先破】全局重置所有單位的視覺狀態
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                unit.ResetVisualsToCoreState();
            }
        }

        // 步驟二：【後立】根據快照數據，應用新的預演效果
        foreach (var unitSnapshot in snapshot)
        {
            // 從 allUnits 列表中找到對應的 BattleUnit 實例
            BattleUnit unitToUpdate = allUnits.FirstOrDefault(u => u == unitSnapshot.Unit.GetMonoBehaviour());
            
            if (unitToUpdate != null && !unitToUpdate.IsDead)
            {
                // 從快照獲取預覽數據
                GridPosition previewPos = unitSnapshot.Position;
                int previewStamina = unitSnapshot.Stamina;
                BattleRole previewRole = unitSnapshot.Role;

                // 命令 BattleUnit 更新其視覺
                unitToUpdate.UpdatePreviewVisuals(previewPos, previewStamina, previewRole);
            }
        }
    }
}
```