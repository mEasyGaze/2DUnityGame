好的，這是一個非常詳盡且結構清晰的戰鬥系統設計。基於您的需求，我將為您編寫所有相關的 C# 腳本。

這些腳本將嚴格遵循您設計的邏輯分離原則：資料、邏輯、UI 各司其職，並透過管理器進行協調。
這邊優先處理 Data、Prefabs、UI、Manager。

---

### **1. 戰鬥系統核心資料結構**

#### **BattleEnums.cs**
這個腳本不需要是 `MonoBehaviour`，它只是一個定義，方便全局使用。

```csharp
using System;

// 戰鬥角色職責
public enum BattleRole
{
    Vanguard, // 前衛
    Ranged1,  // 遠1
    Ranged2,  // 遠2
    Support   // 後勤
}

// 單位可以執行的行動類型
public enum ActionType
{
    Attack,         // 攻擊
    Defend,         // 防禦
    Rest,           // 休息
    Skill,          // 技能
    Item,           // 道具
    Exchange,       // 交換位置
    Skip            // 跳過
}

// UI按鈕觸發的指令類型
public enum UICommandType
{
    CommanderSkill,     // 指揮官技能
    Back,               // 返回上一步
    EndTurn,            // 回合結束
    ResetAll,           // 清空規劃
    CancelSingleAction  // 取消單一行動
}

// 回合管理器的宏觀狀態
public enum BattleState
{
    Setup,              // 戰鬥準備階段
    PlayerPlanning,     // 玩家規劃階段
    EnemyTurn,          // 敵人回合
    ActionExecution,    // 行動執行階段
    Won,                // 戰鬥勝利
    Lost                // 戰鬥失敗
}

// 玩家規劃階段的微觀子狀態
public enum PlanningSubState
{
    None,                   // 無操作，等待流程推進
    SelectingRangedUnit,    // 正在等待玩家選擇行動的遠程單位
    SelectingAction,        // 正在等待玩家為已選單位選擇行動
    SelectingTarget,        // 正在等待玩家為已選行動選擇目標
    SelectingExchangeTarget,// 正在等待玩家選擇交換位置的目標
    SelectingItem,          // 正在等待玩家選擇使用道具的目標
    SelectingItemTarget,    // 正在等待玩家選擇使用道具的目標
    SelectingSkill,         // 正在等待玩家選擇要使用的技能
    SelectingSkillTarget    // 正在等待玩家為已選技能選擇目標
}

// 數值代表了距離，方便計算
[Serializable]
public enum GridPosition
{
    PlayerSupport = 0,
    PlayerRanged2 = 1,
    PlayerRanged1 = 2,
    PlayerVanguard = 3,
    EnemyVanguard = 4,
    EnemyRanged1 = 5,
    EnemyRanged2 = 6,
    EnemySupport = 7,
    None = -1
}

public static class ActionTypeExtensions
{
    public static string ToActionName(this ActionType type)
    {
        switch (type)
        {
            case ActionType.Attack:   return "攻擊";
            case ActionType.Defend:   return "防禦";
            case ActionType.Rest:     return "休息";
            case ActionType.Skill:    return "技能";
            case ActionType.Item:     return "道具";
            case ActionType.Exchange: return "交換";
            case ActionType.Skip:     return "跳過";
            default:                  return type.ToString();
        }
    }
}
```

#### **EnemyDataSO.cs (ScriptableObject)**
敵人的靜態資料模板。

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewEnemyData", menuName = "Battle System/Enemy Data")]
public class EnemyDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string enemyID;
    public string enemyName;
    public Sprite enemyIcon;
    public GameObject enemyPrefab;

    [Header("基礎屬性")]
    public int baseHealth;
    public int baseAttack;
    public int baseStamina;
    public int attackRange;

    [Header("技能槽位")]
    [Tooltip("輸入對應 SkillData 的技能ID")]
    public List<string> skillIDs;

    [Header("物品掉落")]
    public int goldDrop;
    // public List<ItemDropInfo> itemDrops; // 未來可擴充為物品掉落
}
```

#### **BattleEncounterSO.cs (ScriptableObject)**
定義一場戰鬥遭遇的配置。

```csharp
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class EnemyPositioning
{
    public EnemyDataSO enemyData;
    public BattleRole role;
}

[CreateAssetMenu(fileName = "NewBattleEncounter", menuName = "Battle System/Battle Encounter")]
public class BattleEncounterSO : ScriptableObject
{
    [Header("敵人隊伍配置")]
    public List<EnemyPositioning> enemyTeam;

    [Header("戰鬥獎勵")]
    public int totalGoldReward;
    // public List<ItemReward> itemRewards;

    private void OnValidate()
    {
        int calculatedGold = 0;
        if (enemyTeam != null)
        {
            foreach (var enemyPos in enemyTeam)
            {
                if (enemyPos.enemyData != null)
                {
                    calculatedGold += enemyPos.enemyData.goldDrop;
                }
            }
        }
        totalGoldReward = calculatedGold;
    }
}
```

#### **ActionPlan.cs**
儲存單一行動的數據結構，不是 `MonoBehaviour`。

```csharp
using System;

public class ActionPlan
{
    public IBattleUnit_ReadOnly Source { get; }
    public IBattleUnit_ReadOnly Target { get; }
    public ActionType Type { get; }
    public int PhaseIndex { get; }
    public BattleRole PlannedForRole { get; }
    public Guid TransactionID { get; }
    public GridPosition TargetPosition { get; }
    public Item ItemUsed { get; }
    public SkillData SkillUsed { get; }

    private ActionPlan(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly target, ActionType type, int phaseIndex, BattleRole plannedForRole, Guid transactionID, Item item, GridPosition targetPosition, SkillData skill)
    {
        Source = source;
        Target = target;
        Type = type;
        PhaseIndex = phaseIndex;
        PlannedForRole = plannedForRole;
        TransactionID = transactionID;
        ItemUsed = item;
        TargetPosition = targetPosition;
        SkillUsed = skill;
    }

    #region 靜態工廠方法
    // 工廠方法 1: 用於玩家操作 (人事契約)
    public static ActionPlan CreatePlayerAction(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly target, ActionType type, int phaseIndex, BattleRole plannedForRole, Guid transactionID = default, Item item = null)
    {
        GridPosition position = (target != null) ? target.CurrentPosition : GridPosition.None;
        return new ActionPlan(source, target, type, phaseIndex, plannedForRole, transactionID, item, position, null);
    }

    // 工廠方法 2: 用於 AI 操作 (地域契約)
    public static ActionPlan CreateAIAction(IBattleUnit_ReadOnly source, GridPosition targetPosition, ActionType type, int phaseIndex, BattleRole plannedForRole)
    {
        return new ActionPlan(source, null, type, phaseIndex, plannedForRole, default, null, targetPosition, null);
    }

    // 工廠方法 3: 用於無目標的行動 (如休息、防禦、跳過)
    public static ActionPlan CreateNoTargetAction(IBattleUnit_ReadOnly source, ActionType type, int phaseIndex, BattleRole plannedForRole)
    {
        return new ActionPlan(source, null, type, phaseIndex, plannedForRole, default, null, GridPosition.None, null);
    }
    
    // 工廠方法 4: 用於完全空的行動 (如自動跳過)
    public static ActionPlan CreateEmptyAction(int phaseIndex, BattleRole plannedForRole)
    {
        return new ActionPlan(null, null, ActionType.Skip, phaseIndex, plannedForRole, default, null, GridPosition.None, null);
    }

    // 工廠方法 5: 用於技能行動
    public static ActionPlan CreateSkillAction(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly target, SkillData skill, int phaseIndex, BattleRole plannedForRole)
    {
        GridPosition position = (target != null) ? target.CurrentPosition : GridPosition.None;
        return new ActionPlan(source, target, ActionType.Skill, phaseIndex, plannedForRole, default, null, position, skill);
    }
    #endregion
}
```

---

### **2. Prefab 相關腳本**

#### **BattleUnit.cs**
附加在角色/敵人 Prefab 上的核心組件。

```csharp
using UnityEngine;
using UnityEngine.Events;
using TMPro;
using System.Collections.Generic;

public interface IBattleUnit_ReadOnly
{
    // 核心數據
    string UnitName { get; }
    int CurrentHP { get; }
    int MaxHP { get; }
    int CurrentStamina { get; }
    int MaxStamina { get; }
    int CurrentAttack { get; }
    int AttackRange { get; }
    bool IsDead { get; }
    bool IsPlayerTeam { get; }

    // 位置與職責
    GridPosition CurrentPosition { get; }
    BattleRole Role { get; }
    
    // 引用數據
    MemberDataSO MemberData { get; }
    EnemyDataSO EnemyData { get; }

    // 實例數據
    MemberInstance MemberInstance { get; }
    
    // 用於獲取底層的 MonoBehaviour 實例，方便進行比較等操作
    BattleUnit GetMonoBehaviour();
}

public class BattleUnit : MonoBehaviour, IBattleUnit_ReadOnly
{   
    #region 核心數據與屬性 (Core Data & Properties)
    // 靜態資料
    public MemberDataSO MemberData { get; private set; }
    public EnemyDataSO EnemyData { get; private set; }

    // 實例資料
    public MemberInstance MemberInstance { get; private set; }

    // 戰鬥相關屬性
    public BattleRole Role { get; private set; }
    public GridPosition CurrentPosition { get; private set; }
    public int AttackRange { get; private set; }
    public string UnitName { get; private set; }
    public int MaxHP { get; private set; }
    public int CurrentHP { get; private set; }
    public int CurrentAttack
    {
        get
        {
            // 獲取基礎攻擊力
            int baseAttack = (MemberInstance != null) ? MemberInstance.CurrentAttack : EnemyData.baseAttack;

            if (buffController == null) return baseAttack;

            // 計算固定值加成/減成
            float flatBonus = buffController.GetBuffValue(BuffType.IncreaseAttack_Value);
            float flatPenalty = buffController.GetBuffValue(BuffType.DecreaseAttack_Value);
            float finalAttack = baseAttack + flatBonus - flatPenalty;

            // 計算百分比加成/減成
            float percentBonus = buffController.GetBuffValue(BuffType.IncreaseAttack_Percent);
            float percentPenalty = buffController.GetBuffValue(BuffType.DecreaseAttack_Percent);
            finalAttack *= (1.0f + percentBonus - percentPenalty);

            return Mathf.Max(0, Mathf.RoundToInt(finalAttack));
        }
    }
    public int MaxStamina { get; private set; }
    public int CurrentStamina { get; private set; }
    public List<SkillData> Skills { get; private set; }
    public bool IsPlayerTeam { get; private set; }
    public bool IsDead { get; private set; } = false;
    private bool isDefending = false;
    #endregion

    #region 元件與事件連結
    [Header("元件連結")]
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private HealthUI healthUI;
    [SerializeField] private StaminaUI staminaUI;
    
    [Header("狀態反饋")]
    [SerializeField] private GameObject selectionHighlight;
    [SerializeField] private GameObject planningHighlight; 

    [Header("戰術預演UI")]
    [SerializeField] private TextMeshProUGUI previewStaminaText;

    private BuffController buffController;
    public UnityAction<BattleUnit> OnUnitClicked;
    #endregion
    
    #region 初始化
    public void Setup(MemberInstance instance, BattleRole role, GridPosition initialPosition)
    {
        MemberInstance = instance;
        MemberData = instance.BaseData;
        UnitName = MemberData.memberName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = MemberData.attackRange;
        IsPlayerTeam = true;
        
        MaxHP = instance.MaxHP;
        CurrentHP = instance.currentHP;
        MaxStamina = instance.MaxStamina;
        CurrentStamina = instance.MaxStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = MemberData.memberIcon;

        Skills = new List<SkillData>();
        if (MemberData.skillIDs != null)
        {
            foreach (var id in MemberData.skillIDs)
            {
                SkillData skill = SkillManager.Instance.Database.GetSkillDataByID(id);
                if (skill != null)
                {
                    Skills.Add(skill);
                }
            }
        }
        buffController = GetComponent<BuffController>();
        ResetVisualsToCoreState();
    }

    public void Setup(EnemyDataSO data, BattleRole role, GridPosition initialPosition)
    {
        EnemyData = data;
        UnitName = EnemyData.enemyName;
        Role = role;
        CurrentPosition = initialPosition;
        AttackRange = data.attackRange;
        IsPlayerTeam = false;
        
        MaxHP = data.baseHealth;
        CurrentHP = data.baseHealth;
        MaxStamina = data.baseStamina;
        CurrentStamina = data.baseStamina;
        if (spriteRenderer != null) spriteRenderer.sprite = EnemyData.enemyIcon;

        Skills = new List<SkillData>();
        if (EnemyData.skillIDs != null)
        {
            foreach (var id in EnemyData.skillIDs)
            {
                SkillData skill = SkillManager.Instance.Database.GetSkillDataByID(id);
                if (skill != null)
                {
                    Skills.Add(skill);
                }
            }
        }
        buffController = GetComponent<BuffController>();
        ResetVisualsToCoreState();
    }
    #endregion

    #region 狀態變更方法
    public void TakeDamage(int damage)
    {
        if (IsDead) return;

        int absorbedByShield = buffController.AbsorbDamage(damage);
        int remainingDamage = damage - absorbedByShield;

        if (remainingDamage <= 0) return;

        float finalDamage = remainingDamage;
        float defensePercent = buffController.GetBuffValue(BuffType.IncreaseDefense_Percent);
        finalDamage *= (1.0f - defensePercent);

        float defenseFlat = buffController.GetBuffValue(BuffType.IncreaseDefense_Value);
        finalDamage -= defenseFlat;
        
        if (isDefending) finalDamage /= 2;
        
        finalDamage = Mathf.Max(0, finalDamage);
        
        int damageToApply = Mathf.RoundToInt(finalDamage);
        
        CurrentHP -= damageToApply;

        if (CurrentHP <= 0)
        {
            CurrentHP = 0;
            Die();
        }
    }

    public void Heal(int amount)
    {
        if (IsDead) return;
        CurrentHP += amount;
        CurrentHP = Mathf.Min(CurrentHP, MaxHP);
        BattleLog.Instance.AddLog($"{UnitName} 恢復了 {amount} 點生命值。");
    }

    private void Die()
    {
        IsDead = true;
        gameObject.SetActive(false);
        BattleLog.Instance.AddLog($"{UnitName} 已陣亡！");
    }

    public void ConsumeStamina(int amount)
    {
        CurrentStamina = Mathf.Max(0, CurrentStamina - amount);
    }

    public void RestoreStamina(int amount)
    {
        CurrentStamina = Mathf.Min(MaxStamina, CurrentStamina + amount);
    }

    public void SetStamina(int value)
    {
        CurrentStamina = Mathf.Clamp(value, 0, MaxStamina);
    }

    public void SetNewPosition(GridPosition newPosition)
    {
        this.CurrentPosition = newPosition;
    }

    public void SetRole(BattleRole newRole)
    {
        this.Role = newRole;
    }

    public void SetDefenseState(bool defending)
    {
        isDefending = defending;
    }
    #endregion

    #region 視覺與互動 (Visual & Interaction)
    public void UpdatePreviewVisuals(GridPosition previewPosition, int previewStamina, BattleRole previewRole)
    {
        if (BattleManager.Instance != null && BattleManager.Instance.GridSpawns[(int)previewPosition] != null)
        {
            transform.position = BattleManager.Instance.GridSpawns[(int)previewPosition].position;
        }

        if (previewStaminaText != null)
        {
            int staminaChange = previewStamina - this.CurrentStamina;
            if (staminaChange != 0)
            {
                previewStaminaText.text = staminaChange > 0 ? $"+{staminaChange}" : staminaChange.ToString();
                previewStaminaText.color = staminaChange < 0 ? Color.red : Color.green;
                previewStaminaText.gameObject.SetActive(true);
            }
            else
            {
                previewStaminaText.gameObject.SetActive(false);
            }
        }
    }

    public void ResetVisualsToCoreState()
    {
        if (BattleManager.Instance != null && BattleManager.Instance.GridSpawns[(int)this.CurrentPosition] != null)
        {
            transform.position = BattleManager.Instance.GridSpawns[(int)this.CurrentPosition].position;
        }

        if (previewStaminaText != null)
        {
            previewStaminaText.gameObject.SetActive(false);
        }
    }

    private void OnMouseDown()
    {
        OnUnitClicked?.Invoke(this);
    }
    
    public void SetHighlight(bool state)
    {
        if (selectionHighlight != null) selectionHighlight.SetActive(state);
    }
    
    public void SetPlanningHighlight(bool state)
    {
        if (planningHighlight != null) planningHighlight.SetActive(state);
    }
    #endregion
    public BattleUnit GetMonoBehaviour() => this;
}
```

#### **ActionSlotUI.cs**
單一行動格的腳本。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ActionSlotUI : MonoBehaviour
{
    [Header("內容UI")]
    [SerializeField] private Image icon;
    [SerializeField] private TextMeshProUGUI actionText;

    [Header("狀態物件")]
    [SerializeField] private GameObject emptyStateObject;
    [SerializeField] private GameObject filledStateObject;

    [Header("互動元件")]
    [SerializeField] private Button cancelButton;

    private ActionPlan currentPlan;

    public void Setup(System.Action<ActionPlan> onCancelClicked)
    {
        cancelButton.onClick.RemoveAllListeners();
        cancelButton.onClick.AddListener(() =>
        {
            if (currentPlan != null)
            {
                onCancelClicked(currentPlan);
            }
        });
    }

    public void UpdateView(ActionPlan plan)
    {
        currentPlan = plan;
        if (plan == null)
        {
            emptyStateObject.SetActive(true);
            filledStateObject.SetActive(false);
        }
        else
        {
            emptyStateObject.SetActive(false);
            filledStateObject.SetActive(true);
            
            if (plan.Source != null)
            {
                if (plan.Source.MemberData != null) icon.sprite = plan.Source.MemberData.memberIcon;
                else if (plan.Source.EnemyData != null) icon.sprite = plan.Source.EnemyData.enemyIcon;
                
                actionText.text = $"{plan.Source.UnitName[0]} > {plan.Type.ToActionName()}";
            }
            else
            {
                actionText.text = "錯誤";
            }
        }
    }

    public void SetCancelButtonInteractable(bool isInteractable)
    {
        cancelButton.interactable = isInteractable;
    }
}
```

#### **HealthUI.cs**
掛在 `BattleUnit` 上的血條 UI。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HealthUI : MonoBehaviour
{
    [Header("核心單位")]
    [SerializeField] private BattleUnit targetUnit;
    private BuffController buffController;

    [Header("UI 連結")]
    [SerializeField] private Slider healthSlider;
    [SerializeField] private Slider shieldSlider;
    [SerializeField] private TextMeshProUGUI healthText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if (targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (targetUnit != null)
        {
            buffController = targetUnit.GetComponent<BuffController>();
        }
        else
        {
            Debug.LogError("HealthUI 找不到目標 BattleUnit！", gameObject);
            this.enabled = false;
            return;
        }
        
        if (shieldSlider == null)
        {
            Debug.LogError("HealthUI 未指定 Shield Slider！護盾將無法正確顯示。", gameObject);
        }
    }

    void LateUpdate()
    {
        if (targetUnit == null || targetUnit.IsDead)
        {
            if (gameObject.activeSelf)
            {
                gameObject.SetActive(false);
            }
            return;
        }
        
        float currentHP = targetUnit.CurrentHP;
        float maxHP = targetUnit.MaxHP;
        float currentShield = (buffController != null) ? buffController.CurrentShield : 0;
        
        if (shieldSlider != null && shieldSlider.gameObject.activeSelf != (currentShield > 0))
        {
            shieldSlider.gameObject.SetActive(currentShield > 0);
        }

        float totalCombined = currentHP + currentShield;
        float displayMaxValue;

        if (totalCombined > maxHP)
        {
            displayMaxValue = totalCombined;
        }
        else
        {
            displayMaxValue = maxHP;
        }

        if (healthSlider != null) healthSlider.maxValue = displayMaxValue;
        if (shieldSlider != null) shieldSlider.maxValue = displayMaxValue;
        
        if (shieldSlider != null) shieldSlider.value = totalCombined;
        if (healthSlider != null) healthSlider.value = currentHP;
        if (healthText != null)
        {
            int displayHP = Mathf.RoundToInt(currentHP);
            int displayMaxHP = Mathf.RoundToInt(maxHP);
            int displayShield = Mathf.RoundToInt(currentShield);

            if (currentShield > 0)
            {
                healthText.text = $"{displayHP}+({displayShield}) / {displayMaxHP}";
            }
            else
            {
                healthText.text = $"{displayHP} / {displayMaxHP}";
            }
        }
        
        if (mainCamera != null)
        {
            transform.rotation = mainCamera.transform.rotation;
        }
    }
}
```

#### **StaminaUI.cs**
掛在 `BattleUnit` 上的體力條 UI。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class StaminaUI : MonoBehaviour
{
    [SerializeField] private BattleUnit targetUnit;
    [SerializeField] private Slider staminaSlider;
    [SerializeField] private TextMeshProUGUI staminaText;

    private Camera mainCamera;

    void Start()
    {
        mainCamera = Camera.main;
        if(targetUnit == null)
        {
            targetUnit = GetComponentInParent<BattleUnit>();
        }

        if (staminaSlider != null)
        {
            staminaSlider.minValue = 0;
            staminaSlider.maxValue = 1;
        }
    }

    void Update()
    {
        if (targetUnit != null && !targetUnit.IsDead)
        {
            staminaSlider.value = (float)targetUnit.CurrentStamina / targetUnit.MaxStamina;
            
            if (staminaText != null)
            {
                staminaText.text = $"{targetUnit.CurrentStamina} / {targetUnit.MaxStamina}";
            }            
            transform.rotation = mainCamera.transform.rotation;            
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}
```

#### **BattleTrigger.cs**
戰鬥觸發器。

```csharp
using UnityEngine;

[RequireComponent(typeof(Collider2D))]
public class BattleTrigger : MonoBehaviour
{
    [SerializeField] private BattleEncounterSO battleEncounter;

    private void Awake()
    {
        Collider2D col = GetComponent<Collider2D>();
        if (!col.isTrigger)
        {
            Debug.LogWarning($"物件 '{gameObject.name}' 上的 BattleTrigger2D 腳本需要其 Collider2D 設置為 'Is Trigger'，已自動為您設定。");
            col.isTrigger = true;
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            Debug.Log($"[BattleTrigger2D] 偵測到 Player '{other.name}' 進入範圍，準備觸發戰鬥！");
            
            GetComponent<Collider2D>().enabled = false;

            if (GameManager.Instance != null && battleEncounter != null)
            {
                GameManager.Instance.StartBattle(battleEncounter);
            }
            else
            {
                Debug.LogError("[BattleTrigger2D] 無法觸發戰鬥！GameManager 或 BattleEncounterSO 未設定！");
            }
        }
    }
}
```

---

### **3. UI 管理腳本**

#### **ActionPanelUI.cs**
行動按鈕面板。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class ActionPanelUI : MonoBehaviour
{
    [SerializeField] private GameObject panel;
    [SerializeField] private Transform buttonContainer;
    [SerializeField] private ActionButtonUI buttonPrefab;
    
    private List<ActionButtonUI> spawnedButtons = new List<ActionButtonUI>();
    private Dictionary<ActionType, ActionButtonUI> buttonMap = new Dictionary<ActionType, ActionButtonUI>();

    public void ShowPanel(BattleUnit unit, System.Action<ActionType> onActionSelected)
    {
        ClearButtons();
        
        // 根據角色職責決定可用的行動列表
        List<ActionType> availableActions = GetActionsForRole(unit.Role);

        foreach (var actionType in availableActions)
        {
            ActionButtonUI newButton = Instantiate(buttonPrefab, buttonContainer);
            newButton.Setup(actionType, onActionSelected);
            spawnedButtons.Add(newButton);
            buttonMap.Add(actionType, newButton);
        }
        panel.SetActive(true);
    }

    public void UpdateButtonStates(Dictionary<ActionType, bool> feasibility)
    {
        foreach (var pair in feasibility)
        {
            if (buttonMap.TryGetValue(pair.Key, out ActionButtonUI button))
            {
                button.SetInteractable(pair.Value);
            }
        }
    }
    
    // 根據角色職責返回一個行動列表
    private List<ActionType> GetActionsForRole(BattleRole role)
    {
        switch (role)
        {
            case BattleRole.Vanguard:
            case BattleRole.Ranged1:
            case BattleRole.Ranged2:
                // 假設所有戰鬥單位都有這些基礎行動
                return new List<ActionType>
                {
                    ActionType.Attack,
                    ActionType.Defend,
                    ActionType.Skill,
                    ActionType.Rest,
                    ActionType.Item,
                    ActionType.Exchange,
                    ActionType.Skip
                };
            // case BattleRole.Support: // 後勤的行動可以在這裡定義
            default:
                return new List<ActionType>();
        }
    }

    public void UpdateButtonStates(BattleUnit unit, BattleRules rules)
    {
        foreach (var btnUI in spawnedButtons)
        {
            // 簡化：這裡可以加入更複雜的規則，例如體力檢查
            // bool isInteractable = rules.CanPerformAction(unit, btnUI.ActionType);
            // btnUI.SetInteractable(isInteractable);
        }
    }

    public void HidePanel()
    {
        panel.SetActive(false);
        ClearButtons();
    }
    
    private void ClearButtons()
    {
        foreach (var btn in spawnedButtons)
        {
            Destroy(btn.gameObject);
        }
        spawnedButtons.Clear();
        buttonMap.Clear();
    }
}
```

#### **ActionSlotPanelUI.cs**
戰術規劃板。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System;

public class ActionSlotPanelUI : MonoBehaviour
{
    [Header("UI 連結")]
    [SerializeField] private GameObject panel;
    [SerializeField] private List<ActionSlotUI> vanguardSlots;
    [SerializeField] private List<ActionSlotUI> rangedSlots;
    [SerializeField] private List<GameObject> highlightObjects; // 8個高亮物件

    private Dictionary<int, ActionSlotUI> allSlots = new Dictionary<int, ActionSlotUI>();

    public void Initialize(System.Action<UICommandType, ActionPlan> onCommand)
    {
        // 初始化時，建立 stepIndex 到 ActionSlotUI 的映射
        for (int i = 0; i < vanguardSlots.Count; i++)
        {
            int stepIndex = i * 2;
            allSlots[stepIndex] = vanguardSlots[i];
            vanguardSlots[i].Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
        for (int i = 0; i < rangedSlots.Count; i++)
        {
            int stepIndex = i * 2 + 1;
            allSlots[stepIndex] = rangedSlots[i];
            rangedSlots[i].Setup(plan => onCommand(UICommandType.CancelSingleAction, plan));
        }
    }
    
    public void UpdatePanel(TurnActionPlanner planner)
    {
        // 1. 獲取最後一個已規劃行動的步驟索引
        int lastPlannedStep = planner.GetLastPlanStepIndex();
        
        // 2. 遍歷所有行動格
        for(int i = 0; i < 8; i++)
        {
            if (allSlots.TryGetValue(i, out ActionSlotUI slot))
            {
                ActionPlan plan = planner.GetPlanAtStep(i);
                
                slot.UpdateView(plan);
                
                bool isCancellable = (plan != null && i == lastPlannedStep);
                
                if (plan != null && plan.TransactionID != Guid.Empty)
                {
                    var lastPlan = planner.GetPlanAtStep(lastPlannedStep);
                    if (lastPlan != null && lastPlan.TransactionID == plan.TransactionID)
                    {
                        isCancellable = true;
                    }
                }
                slot.SetCancelButtonInteractable(isCancellable);
            }
        }
        
        panel.SetActive(true);
    }

    public void SetPlanningHighlight(int stepIndex)
    {
        for (int i = 0; i < highlightObjects.Count; i++)
        {
            if (highlightObjects[i] != null)
            {
                highlightObjects[i].SetActive(i == stepIndex);
            }
        }
    }
    
    public void HidePanel()
    {
        panel.SetActive(false);
    }
}
```

#### **BattleEndUI.cs**
戰鬥結算畫面。

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class BattleEndUI : MonoBehaviour
{
    [SerializeField] private GameObject victoryPanel;
    [SerializeField] private GameObject defeatPanel;
    [SerializeField] private TextMeshProUGUI rewardText;
    [SerializeField] private Button exitButton;

    private void Start()
    {
        exitButton.onClick.AddListener(OnExitButtonClicked);
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(false);
        if (exitButton != null)
        {
            exitButton.gameObject.SetActive(false);
        }
    }

    public void ShowVictory(int goldReward)
    {
        victoryPanel.SetActive(true);
        defeatPanel.SetActive(false);
        rewardText.text = $"獲得金幣: {goldReward}";
        if (exitButton != null)
        {
            exitButton.gameObject.SetActive(true);
        }
    }

    public void ShowDefeat()
    {
        victoryPanel.SetActive(false);
        defeatPanel.SetActive(true);
        if (exitButton != null)
        {
            exitButton.gameObject.SetActive(true);
        }
    }

    private void OnExitButtonClicked()
    {
        exitButton.interactable = false;
        GameManager.Instance.EndBattle();
    }
}
```

#### **BattleLog.cs**
戰鬥日誌。

```csharp
using UnityEngine;
using TMPro;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;

public class BattleLog : MonoBehaviour
{
    public static BattleLog Instance { get; private set; }
    
    [SerializeField] private TextMeshProUGUI logText;
    [SerializeField] private ScrollRect scrollRect;
    private Queue<string> logMessages = new Queue<string>();
    private int maxMessages = 20;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public void AddLog(string message)
    {
        if (logMessages.Count >= maxMessages)
        {
            logMessages.Dequeue();
        }
        logMessages.Enqueue($"[{System.DateTime.Now:HH:mm:ss}] {message}");
        UpdateLogText();
    }

    private void UpdateLogText()
    {
        logText.text = string.Join("\n", logMessages);

        StopAllCoroutines(); 
        StartCoroutine(ScrollToBottomCoroutine());
    }

    private IEnumerator ScrollToBottomCoroutine()
    {
        yield return new WaitForEndOfFrame();
        scrollRect.verticalNormalizedPosition = 0f;
    }
}
```

#### **BattleUI.cs**
戰鬥場景 UI 總集。

```csharp
using UnityEngine;
using UnityEngine.UI;

public class BattleUI : MonoBehaviour
{
    [SerializeField] private Button endTurnButton;
    [SerializeField] private Button resetButton;
    [SerializeField] private Button backButton;

    [Header("指揮官技能按鈕")]
    [SerializeField] private Button commanderSkillButton;
    [SerializeField] private Button cancelCommanderSkillButton;

    public void Setup(System.Action<UICommandType> onCommand)
    {
        endTurnButton.onClick.RemoveAllListeners();
        endTurnButton.onClick.AddListener(() => onCommand(UICommandType.EndTurn));
        
        resetButton.onClick.RemoveAllListeners();
        resetButton.onClick.AddListener(() => onCommand(UICommandType.ResetAll));
        
        backButton.onClick.RemoveAllListeners();
        backButton.onClick.AddListener(() => onCommand(UICommandType.Back));

        if (commanderSkillButton != null)
        {
            commanderSkillButton.onClick.RemoveAllListeners();
            commanderSkillButton.onClick.AddListener(() => onCommand(UICommandType.UseCommanderSkill));
        }
        if (cancelCommanderSkillButton != null)
        {
            cancelCommanderSkillButton.onClick.RemoveAllListeners();
            cancelCommanderSkillButton.onClick.AddListener(() => onCommand(UICommandType.CancelCommanderSkill));
        }
    }
    
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        endTurnButton.interactable = interactable;
    }
    
    public void SetBackButtonVisible(bool visible)
    {
        backButton.gameObject.SetActive(visible);
    }

    public void SetResetButtonVisible(bool visible)
    {
        resetButton.gameObject.SetActive(visible);
    }

    public void SetCommanderSkillButtons(bool showUseButton, bool showCancelButton, bool isInteractable)
    {
        if (commanderSkillButton != null)
        {
            commanderSkillButton.gameObject.SetActive(showUseButton);
            commanderSkillButton.interactable = isInteractable;
        }
        if (cancelCommanderSkillButton != null)
        {
            cancelCommanderSkillButton.gameObject.SetActive(showCancelButton);
        }
    }
}
```

#### **BattleItemUI.cs**
戰鬥場景中使用道具的UI介面。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.UI;

public class BattleItemUI : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private GameObject itemPanel;
    [SerializeField] private Transform slotContainer;
    [SerializeField] private GameObject slotPrefab;

    private List<InventorySlotUI> slotUIs = new List<InventorySlotUI>();
    private System.Action<Item> onItemClickedCallback;
    private Inventory targetInventory;

    void Awake()
    {
        if (itemPanel == null) itemPanel = this.gameObject;
        itemPanel.SetActive(false);
    }

    private void OnEnable()
    {
        if (InventoryManager.Instance != null)
        {
            this.targetInventory = InventoryManager.Instance.playerInventoryData;
            InventoryManager.Instance.OnInventoryChanged += RefreshPanel;
            RefreshPanel();
        }
    }

    private void OnDisable()
    {
        if (InventoryManager.Instance != null)
        {
            InventoryManager.Instance.OnInventoryChanged -= RefreshPanel;
        }
    }

    public void ShowPanel(System.Action<Item> onItemClicked)
    {
        this.onItemClickedCallback = onItemClicked;
        itemPanel.SetActive(true);
        RefreshPanel();
    }

    public void HidePanel()
    {
        itemPanel.SetActive(false);
    }

    private void RefreshPanel()
    {
        if (!itemPanel.activeSelf) return;

        if (targetInventory == null)
        {
            if (InventoryManager.Instance != null)
            {
                targetInventory = InventoryManager.Instance.playerInventoryData;
            }
            else
            {
                Debug.LogError("BattleItemUI 無法獲取 targetInventory！");
                return;
            }
        }

        foreach (Transform child in slotContainer)
        {
            Destroy(child.gameObject);
        }
        slotUIs.Clear();

        var consumableSlots = targetInventory.slots
            .Where(s => !s.IsEmpty() && s.item.itemType == ItemType.Consumable)
            .ToList();

        foreach (var slotData in consumableSlots)
        {
            GameObject slotGO = Instantiate(slotPrefab, slotContainer);
            InventorySlotUI slotUI = slotGO.GetComponent<InventorySlotUI>();

            if (slotUI != null)
            {
                slotUI.AssignSlot(slotData);

                var button = slotUI.GetComponentInChildren<Button>();
                if (button != null)
                {
                    button.onClick.RemoveAllListeners();
                    button.onClick.AddListener(() => OnSlotClicked(slotData.item));
                }
                slotUIs.Add(slotUI);
            }
        }
    }

    private void OnSlotClicked(Item clickedItem)
    {
        if (onItemClickedCallback != null)
        {
            onItemClickedCallback(clickedItem);
        }
    }
}
```

---

### **4. 管理器 (Managers)**

#### **TurnManager.cs**
回合與邏輯管理器，戰鬥的核心。

```csharp
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    #region 屬性與狀態變數 (Properties & State Variables)
    public BattleState CurrentState { get; private set; }
    // 核心模組依賴
    private BattleManager battleManager;
    private BattleUIManager uiManager;
    private TurnActionPlanner actionPlanner;
    private BattleRules battleRules;
    private BattleActions battleActions;
    private EnemyBattleAI enemyAI;
    private CharacterStateRule characterStateRule;
    private BattlefieldStateSimulator stateSimulator;
    private SkillData selectedSkill;

    // 玩家規劃階段的微觀狀態
    private int currentPlanningStepIndex;
    private PlanningSubState currentSubState;
    private BattleUnit selectedUnitForAction;
    private ActionType selectedActionType;
    private Item selectedItem;
    private List<IBattleUnit_ReadOnly> currentEligibleActors;
    // 用於實現微觀步驟回溯的狀態堆疊
    private Stack<PlanningSubState> planningHistory = new Stack<PlanningSubState>();
    // 指揮官技能狀態
    private ActionPlan plannedCommanderSkill = null;
    private bool hasCommanderSkillBeenUsedThisBattle = false;
    private BattleUnit supportUnit = null;

    #endregion

    #region 初始化與啟動 (Initialization & Startup)
    public void Initialize(BattleManager bm, BattleUIManager uim, TurnActionPlanner ap, BattleRules br, BattleActions ba, EnemyBattleAI eai, CharacterStateRule csr, BattlefieldStateSimulator sim)
    {
        // 模組賦值
        battleManager = bm;
        uiManager = uim;
        actionPlanner = ap;
        battleRules = br;
        battleActions = ba;
        enemyAI = eai;
        characterStateRule = csr;
        stateSimulator = sim;

        supportUnit = battleManager.PlayerUnits.FirstOrDefault(u => u.Role == BattleRole.Support);
        // 狀態變數初始化
        currentEligibleActors = new List<IBattleUnit_ReadOnly>();
    }

    public void StartBattle()
    {
        BattleLog.Instance.AddLog("戰鬥開始！");
        SetState(BattleState.PlayerPlanning);
    }
    #endregion

    #region 宏觀狀態機管理 (Macro State Machine Management)
    private void SetState(BattleState newState)
    {
        if (CurrentState == newState) return;     
        CurrentState = newState;
        StartCoroutine(OnEnterState(newState));
    }
    
    private IEnumerator OnEnterState(BattleState state)
    {
        switch (state)
        {
            case BattleState.PlayerPlanning:
                HandleEnterPlayerPlanning();
                break;
            case BattleState.EnemyTurn:
                yield return StartCoroutine(HandleEnterEnemyTurn());
                if (plannedCommanderSkill != null)
                {
                    yield return StartCoroutine(ExecuteCommanderSkill());
                }
                SetState(BattleState.ActionExecution);
                break;
            case BattleState.ActionExecution:
                HandleEnterActionExecution();
                break;
            case BattleState.Won:
                HandleEnterWon();
                break;
            case BattleState.Lost:
                HandleEnterLost();
                break;
        }
    }
    private void HandleEnterPlayerPlanning()
    {
        BattleLog.Instance.AddLog("==== 新回合：玩家規劃階段 ====");
        BuffManager.Instance.TickAllBuffsOnAllUnits(battleManager.GetAllUnits());
        UpdateAuraEffects();
        if (uiManager != null)
        {
            uiManager.SetResetButtonVisible(true);
            uiManager.SetEndTurnButtonInteractable(false);
            uiManager.SetBackButtonVisible(false);
            BuffManager.Instance.TickAllBuffsOnAllUnits(battleManager.GetAllUnits());
        }
        actionPlanner.PrepareForNewTurn();
        characterStateRule.RestoreAllUnitStamina(battleManager.GetAllUnits());
        UpdateCommanderSkillUI();
        // 進入規劃階段時，直接重置所有規劃
        CommitResetAllPlans();
    }
    private IEnumerator HandleEnterEnemyTurn()
    {
        BattleLog.Instance.AddLog("==== 敵人回合 ====");
        uiManager.EnterEnemyTurnState();
        var currentSnapshotForAI = characterStateRule.GetLatestSnapshot();
        enemyAI.PlanActions(battleManager.EnemyUnits, battleManager.PlayerUnits, actionPlanner, battleRules, battleActions.GetAttackStaminaCost());
        yield return new WaitForSeconds(1f);
        SetState(BattleState.ActionExecution);
    }

    private void HandleEnterActionExecution()
    {
        BattleLog.Instance.AddLog("==== 行動執行階段 ====");
        uiManager.EnterActionExecutionState();
        StartCoroutine(ExecuteActions());
    }

    private void HandleEnterWon()
    {
        BattleLog.Instance.AddLog("★★ 戰鬥勝利 ★★");
        uiManager.ShowVictoryScreen(battleManager.EncounterData.totalGoldReward);
    }

    private void HandleEnterLost()
    {
        BattleLog.Instance.AddLog("戰鬥失敗...");
        uiManager.ShowDefeatScreen();
    }
    #endregion

    #region 玩家輸入處理 (Player Input Handling)
    public void OnUnitClicked(BattleUnit unit)
    {
        if (CurrentState != BattleState.PlayerPlanning) return;

        switch(currentSubState)
        {
            case PlanningSubState.SelectingRangedUnit:
                if (currentEligibleActors.Any(u => u.GetMonoBehaviour() == unit))
                {
                    selectedUnitForAction = unit;
                    GoToPlanningSubState(PlanningSubState.SelectingAction);
                }
                break;
                
            case PlanningSubState.SelectingTarget:
                var validTargets = battleRules.GetValidTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                if (validTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewPlan(selectedUnitForAction, selectedActionType, unit);
                }
                break;

            case PlanningSubState.SelectingExchangeTarget:
                var validExchangeTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                if (validExchangeTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewExchangePlan(selectedUnitForAction, unit);
                }
                break;

            case PlanningSubState.SelectingItemTarget:
                var validItemTargets = battleRules.GetValidItemTargets(selectedUnitForAction);
                if (validItemTargets.Any(u => u.GetMonoBehaviour() == unit))
                {
                    CommitNewItemPlan(selectedUnitForAction, selectedItem, unit);
                }
                break;
            case PlanningSubState.SelectingSkillTarget:
                var validSkillTargets = battleRules.GetValidSkillTargets(selectedUnitForAction, selectedSkill, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                if (validSkillTargets.Any(t => t.GetMonoBehaviour() == unit))
                {
                    CommitNewSkillPlan(selectedUnitForAction, unit, selectedSkill);
                }
                break;
        }
    }
    
    public void OnActionSelected(ActionType type)
    {
        if (CurrentState != BattleState.PlayerPlanning || currentSubState != PlanningSubState.SelectingAction) return;
        
        selectedActionType = type;
        
        if (type == ActionType.Skill)
        {
            GoToPlanningSubState(PlanningSubState.SelectingSkill);
        }
        else if (type == ActionType.Attack)
        {
            GoToPlanningSubState(PlanningSubState.SelectingTarget);
        }
        else if (type == ActionType.Exchange)
        {
            GoToPlanningSubState(PlanningSubState.SelectingExchangeTarget);
        }
        else if (type == ActionType.Item)
        {
            GoToPlanningSubState(PlanningSubState.SelectingItem);
        }
        else
        {
            CommitNewPlan(selectedUnitForAction, type, null);
        }
    }

    public void OnItemSelected(Item item)
    {
        if (CurrentState != BattleState.PlayerPlanning || currentSubState != PlanningSubState.SelectingItem) return;
        selectedItem = item;        
        GoToPlanningSubState(PlanningSubState.SelectingItemTarget);
    }

    public void OnSkillSelected(SkillData skill)
    {
        if (CurrentState != BattleState.PlayerPlanning || currentSubState != PlanningSubState.SelectingSkill) return;

        selectedSkill = skill;
        stateSimulator.ShowTemporaryStaminaPreview(selectedUnitForAction, skill.staminaCost);

        switch (skill.targetType)
        {
            case SkillTargetType.None:
            case SkillTargetType.Self:
            case SkillTargetType.Ally_All:
            case SkillTargetType.Enemy_All:
            case SkillTargetType.Enemy_Penetrate:
                CommitNewSkillPlan(selectedUnitForAction, null, selectedSkill);
                break;
            case SkillTargetType.Enemy_Single:
            case SkillTargetType.Ally_Single:
                GoToPlanningSubState(PlanningSubState.SelectingSkillTarget);
                break;
        }
    }

    public void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        if (CurrentState != BattleState.PlayerPlanning)
        {
            if (command == UICommandType.EndTurn) SetState(BattleState.EnemyTurn);
            return;
        }

        if (currentSubState == PlanningSubState.SelectingItem)
        {
            if (command == UICommandType.Back || command == UICommandType.ResetAll)
            {
                BattleLog.Instance.AddLog("從道具選擇返回。");
                uiManager.HideItemSelectionPanel();
                GoToPlanningSubState(PlanningSubState.SelectingAction);
                return;
            }
        }

        switch (command)
        {
            case UICommandType.EndTurn: SetState(BattleState.EnemyTurn); break;
            case UICommandType.ResetAll: CommitResetAllPlans(); break;
            case UICommandType.CancelSingleAction: CommitCancelLastPlan(); break;
            case UICommandType.Back: CommitGoBack(); break;
            case UICommandType.UseCommanderSkill: HandleUseCommanderSkill(); break;
            case UICommandType.CancelCommanderSkill: HandleCancelCommanderSkill(); break;
        }
    }
    #endregion

    #region 事務性操作 (Transactional Operations)
    private void CommitNewPlan(IBattleUnit_ReadOnly actor, ActionType type, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        
        ActionPlan newPlan = ActionPlan.CreatePlayerAction(actor, target, type, phaseIndex, stepRole);

        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }

    private void CommitNewNoTargetPlan(IBattleUnit_ReadOnly actor, ActionType type)
    {
        planningHistory.Clear();
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        
        ActionPlan newPlan = ActionPlan.CreateNoTargetAction(actor, type, phaseIndex, stepRole);

        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }
    
    private void CommitNewExchangePlan(IBattleUnit_ReadOnly actor, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();
        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        var actorSnap = latestSnapshot.UnitSnapshots.First(s => s.Unit == actor);
        var targetSnap = latestSnapshot.UnitSnapshots.First(s => s.Unit == target);
        // 資源預檢查
        if (actorSnap.Stamina < battleActions.GetExchangeStaminaCost())
        {
            BattleLog.Instance.AddLog($"交換失敗：{actor.UnitName} 體力不足！");
            return;
        }
        // 行動格調度
        int actorStepIndex = currentPlanningStepIndex;
        var excludeList = new List<int> { actorStepIndex };
        int targetStepIndex = actionPlanner.FindNextAvailableStep(targetSnap.Role, 0, excludeList);
        if (targetStepIndex == -1)
        {
            BattleLog.Instance.AddLog($"交換失敗：沒有可用的行動格給 {target.UnitName}！");
            return;
        }
        // 創建與提交計畫
        int phaseIndex = (actorStepIndex / 2) + 1; 
        Guid transactionID = Guid.NewGuid();

        BattleRole actorStepRole = GetRoleForStep(actorStepIndex);
        BattleRole targetStepRole = GetRoleForStep(targetStepIndex);

        var planA = ActionPlan.CreatePlayerAction(actor, target, ActionType.Exchange, phaseIndex, actorStepRole, transactionID);
        var planB = ActionPlan.CreatePlayerAction(target, actor, ActionType.Exchange, phaseIndex, targetStepRole, transactionID);
        
        actionPlanner.AddPlan(planA, actorStepIndex);
        actionPlanner.AddPlan(planB, targetStepIndex);
        
        characterStateRule.GenerateAndStoreNextSnapshot(planA, battleActions);
        // 刷新視覺並推進流程
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }
    
    private void CommitCancelLastPlan()
    {
        uiManager.HideSkillSelectionPanel();
        planningHistory.Clear();
        int lastPlanStep = actionPlanner.GetLastPlanStepIndex();
        if (lastPlanStep == -1)
        {
            Debug.Log("沒有任何已規劃的行動可以取消。");
            return;
        }
        
        ActionPlan lastPlan = actionPlanner.GetPlanAtStep(lastPlanStep);
        BattleLog.Instance.AddLog($"正在撤銷行動: {lastPlan.Source.UnitName} -> {lastPlan.Type.ToActionName()}");

        // 捆綁操作
        actionPlanner.RemovePlansFromStep(lastPlanStep);
        characterStateRule.PruneSnapshotsToCount(actionPlanner.GetPlayerPlanCount() + 1);
        
        // 刷新視覺並回滾流程
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        // 將規劃流程設定到第一個未規劃的步驟
        planningHistory.Clear();
        currentPlanningStepIndex = actionPlanner.GetNextPlanningStepIndex();
        AdvancePlanningStep();
    }

    private void CommitGoBack()
    {
        if (currentSubState == PlanningSubState.SelectingSkill)
        {
            uiManager.HideSkillSelectionPanel();
        }
        if (planningHistory.Count > 0)
        {
            PlanningSubState previousState = planningHistory.Pop();
            
            BattleLog.Instance.AddLog("返回上一步操作。");
            stateSimulator.ClearTemporaryPreviews();
            GoToPlanningSubState(previousState, false); 
        }
        else
        {
            Debug.LogWarning("沒有可返回的微觀操作歷史。");
        }
    }
    
    private void CommitResetAllPlans()
    {
        uiManager.HideSkillSelectionPanel();
        planningHistory.Clear();
        actionPlanner.ClearPlayerPlans();
        characterStateRule.InitializeSnapshots(battleManager.GetAllUnits());
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        StartCoroutine(StartGuidedPlanning());
        BattleLog.Instance.AddLog("已重置所有規劃。");
    }

    private void CommitNewItemPlan(IBattleUnit_ReadOnly actor, Item item, IBattleUnit_ReadOnly target)
    {
        planningHistory.Clear();

        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        if (latestSnapshot == null || !latestSnapshot.InventorySnapshot.HasItem(item.uniqueItemID))
        {
            BattleLog.Instance.AddLog($"預演失敗：模擬背包中已無 {item.itemName}，請選擇其他道具或行動。");
            GoToPlanningSubState(PlanningSubState.SelectingItem); 
            return;
        }

        // 創建計畫
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        ActionPlan newPlan = ActionPlan.CreatePlayerAction(actor, target, ActionType.Item, phaseIndex, stepRole, default, item);
        
        // 更新系統狀態
        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        
        // 刷新視覺並推進流程
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        AdvancePlanningStep();
    }

    private void CommitNewSkillPlan(IBattleUnit_ReadOnly actor, IBattleUnit_ReadOnly target, SkillData skill)
    {
        planningHistory.Clear();
        int phaseIndex = (currentPlanningStepIndex / 2) + 1;
        BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
        
        // 使用新的工廠方法創建計畫
        ActionPlan newPlan = ActionPlan.CreateSkillAction(actor, target, skill, phaseIndex, stepRole);

        actionPlanner.AddPlan(newPlan, currentPlanningStepIndex);
        characterStateRule.GenerateAndStoreNextSnapshot(newPlan, battleActions);
        stateSimulator.ShowStateFromSnapshot(characterStateRule.GetLatestSnapshot().UnitSnapshots);
        
        // 提交後推進流程
        AdvancePlanningStep();
    }

    private void HandleUseCommanderSkill()
    {
        if (supportUnit == null || hasCommanderSkillBeenUsedThisBattle) return;

        SkillData commanderSkill = supportUnit.Skills.FirstOrDefault(s => s.isCommanderSkill_OneTimeUse);
        if (commanderSkill == null)
        {
            BattleLog.Instance.AddLog(LogFormatter.System("錯誤：後勤單位沒有找到指揮官技能！"));
            return;
        }

        plannedCommanderSkill = ActionPlan.CreateSkillAction(supportUnit, null, commanderSkill, 0, BattleRole.Support);
        
        BattleLog.Instance.AddLog($"{LogFormatter.Unit(supportUnit)} 已準備施放指揮官技能 [{commanderSkill.skillName}]。");
        UpdateCommanderSkillUI();
    }
    
    private void HandleCancelCommanderSkill()
    {
        if (plannedCommanderSkill == null) return;
        
        string skillName = plannedCommanderSkill.SkillUsed.skillName;
        plannedCommanderSkill = null;
        
        BattleLog.Instance.AddLog($"取消了指揮官技能 [{skillName}] 的施放。");
        UpdateCommanderSkillUI();
    }

    #endregion
    
    #region 規劃階段核心邏輯 (Planning Phase Core Logic)
    private IEnumerator StartGuidedPlanning()
    {
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;
        
        currentPlanningStepIndex = 0;
        AdvancePlanningStep();
        yield return null;
    }

    private void AdvancePlanningStep()
    {
        uiManager.UpdateActionSlots(actionPlanner);
        planningHistory.Clear();
        if (actionPlanner.IsPlanningFinished())
        {
            GoToPlanningSubState(PlanningSubState.None);
            return;
        }

        while (currentPlanningStepIndex < 8)
        {
            currentPlanningStepIndex = actionPlanner.GetNextPlanningStepIndex();
            if (currentPlanningStepIndex >= 8)
            {
                GoToPlanningSubState(PlanningSubState.None);
                return;
            }
            
            var latestSnapshotUnits = characterStateRule.GetLatestSnapshot().UnitSnapshots;
            currentEligibleActors = battleRules.GetEligibleActorsForStep(currentPlanningStepIndex, latestSnapshotUnits, actionPlanner);

            if (currentEligibleActors.Count > 0)
            {
                if (currentEligibleActors.Count == 1)
                {
                    selectedUnitForAction = currentEligibleActors[0].GetMonoBehaviour();
                    planningHistory.Push(PlanningSubState.None);
                    GoToPlanningSubState(PlanningSubState.SelectingAction);
                }
                else
                {
                    GoToPlanningSubState(PlanningSubState.SelectingRangedUnit);
                }
                return;
            }
            else
            {
                BattleLog.Instance.AddLog($"在階段 {currentPlanningStepIndex + 1} 沒有可行動的單位，自動跳過。");
                
                int phaseIndex = (currentPlanningStepIndex / 2) + 1;
                BattleRole stepRole = GetRoleForStep(currentPlanningStepIndex);
                ActionPlan skipPlan = ActionPlan.CreateEmptyAction(phaseIndex, stepRole);

                actionPlanner.AddPlan(skipPlan, currentPlanningStepIndex);
                characterStateRule.GenerateAndStoreNextSnapshot(skipPlan, battleActions);
                uiManager.UpdateActionSlots(actionPlanner);
            }
        }
    }
    
    private void GoToNextStep()
    {
        selectedUnitForAction = null;
        selectedActionType = default;
        currentSubState = PlanningSubState.None;
        
        AdvancePlanningStep();
    }
    #endregion

    #region 規劃階段輔助方法 (Planning Phase Helper Methods)
    private void GoToPlanningSubState(PlanningSubState nextState, bool isForwardStep = true)
    {
        if (isForwardStep && currentSubState != nextState)
        {
            planningHistory.Push(currentSubState);
        }

        currentSubState = nextState;
        
        bool canGoBack = planningHistory.Count > 0 && nextState != PlanningSubState.SelectingRangedUnit && nextState != PlanningSubState.None;
        uiManager.SetBackButtonVisible(planningHistory.Count > 0);

        switch (nextState)
        {
            case PlanningSubState.None:
                if (!isForwardStep)
                {
                    BattleLog.Instance.AddLog("已返回至行動格規劃起點。");
                    selectedUnitForAction = null;
                    selectedActionType = default;
                    AdvancePlanningStep();
                }
                else
                {
                    uiManager.ShowPlanningFinishedState();
                }
                break;
                
            case PlanningSubState.SelectingRangedUnit:
                selectedUnitForAction = null;
                selectedActionType = default;
                uiManager.ShowRangedUnitSelection(ConvertFromReadOnlyList(currentEligibleActors), currentPlanningStepIndex);
                break;

            case PlanningSubState.SelectingAction:
                selectedActionType = default;
                var feasibility = battleRules.GetActionFeasibility(selectedUnitForAction, characterStateRule.GetLatestSnapshot(), actionPlanner);
                uiManager.ShowActionSelectionFor(selectedUnitForAction, currentPlanningStepIndex, feasibility);
                break;

            case PlanningSubState.SelectingTarget:
            {
                var validTargets = battleRules.GetValidTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validTargets));
                break;
            }

            case PlanningSubState.SelectingExchangeTarget:
                var validExchangeTargets = battleRules.GetValidExchangeTargets(selectedUnitForAction, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validExchangeTargets));
                break;
            
            case PlanningSubState.SelectingItem:
                selectedItem = null;
                uiManager.ShowItemSelection(OnItemSelected);
                break;

            case PlanningSubState.SelectingItemTarget:
                var validItemTargets = battleRules.GetValidItemTargets(selectedUnitForAction);
                uiManager.ShowItemTargetSelection(ConvertFromReadOnlyList(validItemTargets));
                break;

            case PlanningSubState.SelectingSkill:
                selectedSkill = null;
                var skillFeasibility = new Dictionary<SkillData, bool>();
                var latestSnapshot = characterStateRule.GetLatestSnapshot();
                
                foreach (var skill in selectedUnitForAction.Skills)
                {
                    bool isUsable = battleRules.IsSkillUsable(selectedUnitForAction, skill, latestSnapshot);
                    skillFeasibility.Add(skill, isUsable);
                }
                uiManager.ShowSkillSelection(skillFeasibility, OnSkillSelected);
                break;

            case PlanningSubState.SelectingSkillTarget:
            {
                var validTargets = battleRules.GetValidSkillTargets(selectedUnitForAction, selectedSkill, characterStateRule.GetLatestSnapshot().UnitSnapshots);
                uiManager.ShowTargetSelection(ConvertFromReadOnlyList(validTargets));
                break;
            }
        }
    }

    private List<BattleUnit> ConvertFromReadOnlyList(List<IBattleUnit_ReadOnly> readOnlyList)
    {
        return readOnlyList.Select(u => u.GetMonoBehaviour()).ToList();
    }

    private void ShowActionPanelForUnit(BattleUnit unit)
    {
        var feasibility = battleRules.GetActionFeasibility(unit, characterStateRule.GetLatestSnapshot(), actionPlanner);
        uiManager.ShowActionSelectionFor(unit, currentPlanningStepIndex, feasibility);
    }
    
    private BattleRole GetRoleForStep(int stepIndex)
    {
        return (stepIndex % 2 == 0) ? BattleRole.Vanguard : BattleRole.Ranged1;
    }

    private void UpdateCommanderSkillUI()
    {
        if (uiManager == null || supportUnit == null) return;
        if (supportUnit == null || !supportUnit.Skills.Any(s => s.isCommanderSkill_OneTimeUse))
        {
            uiManager.SetCommanderSkillButtons(false, false, false);
            return;
        }
        bool canUse = !hasCommanderSkillBeenUsedThisBattle;
        bool isPlanned = (plannedCommanderSkill != null);

        if (hasCommanderSkillBeenUsedThisBattle)
        {
            uiManager.SetCommanderSkillButtons(false, false, false);
        }
        else if (!isPlanned)
        {
            uiManager.SetCommanderSkillButtons(true, false, canUse);
        }
        else
        {
            uiManager.SetCommanderSkillButtons(false, true, true);
        }
    }
    #endregion
    
    #region 行動執行階段 (Action Execution Phase)
    private IEnumerator ExecuteActions()
    {
        foreach(var unit in battleManager.GetAllUnits())
        {
            unit.ResetVisualsToCoreState();
        }

        var processedTransactions = new HashSet<Guid>();
        for (int phase = 1; phase <= 4; phase++)
        {
            var executionOrder = new[]
            {
                new { IsPlayer = true, Role = BattleRole.Vanguard },
                new { IsPlayer = false, Role = BattleRole.Vanguard },
                new { IsPlayer = true, Role = BattleRole.Ranged1 },
                new { IsPlayer = false, Role = BattleRole.Ranged1 }
            };
            
            foreach(var step in executionOrder)
            {
                yield return StartCoroutine(ExecuteStep(phase, step.IsPlayer, step.Role, processedTransactions));
                if (CheckBattleEnd()) yield break;
            }
        }
        UpdateAuraEffects();

        if (CurrentState == BattleState.ActionExecution)
        {
            SetState(BattleState.PlayerPlanning);
        }
    }
    
    private IEnumerator ExecuteStep(int phase, bool isPlayer, BattleRole role, HashSet<Guid> processedTransactions)
    {
        ActionPlan plan = actionPlanner.GetActionForRole(phase, isPlayer, role);
        if (plan != null && plan.Type != ActionType.Skip)
        {
            if (plan.Source != null && !plan.Source.IsDead)
            {
                battleActions.Execute(plan, actionPlanner, processedTransactions, battleManager);
                yield return new WaitForSeconds(1.0f);
            }
        }
    }

    private IEnumerator ExecuteCommanderSkill()
    {
        if (plannedCommanderSkill == null) yield break;

        BattleLog.Instance.AddLog(LogFormatter.System("==== 指揮官技能發動！ ===="));
        battleActions.Execute(plannedCommanderSkill, null, null, battleManager);
        
        hasCommanderSkillBeenUsedThisBattle = true;
        plannedCommanderSkill = null;

        UpdateCommanderSkillUI();

        yield return new WaitForSeconds(1.5f);
    }

    private bool CheckBattleEnd()
    {
        actionPlanner.RemovePlansFromDeadUnits(battleManager.GetAllUnits());
        battleManager.HandleTeamPromotions();
        uiManager.UpdateActionSlots(actionPlanner);
        
        if (battleRules.IsVictory(battleManager.EnemyUnits))
        {
            SetState(BattleState.Won);
            return true;
        }
        if (battleRules.IsDefeat(battleManager.PlayerUnits))
        {
            SetState(BattleState.Lost);
            return true;
        }
        return false;
    }
    #endregion

    #region 光環效果管理 (Aura Effect Management)
    private void UpdateAuraEffects()
    {
        foreach (var unit in battleManager.GetAllUnits())
        {
            if (unit != null)
            {
                unit.GetComponent<BuffController>()?.ClearAllAuras();
            }
        }
        ApplyAurasForTeam(true);
        ApplyAurasForTeam(false);
    }

    private void ApplyAurasForTeam(bool isPlayerTeam)
    {
        GridPosition supportPos = isPlayerTeam ? GridPosition.PlayerSupport : GridPosition.EnemySupport;
        BattleUnit supportUnit = battleManager.GetUnitAtPosition(supportPos);

        if (supportUnit == null || supportUnit.IsDead) return;

        foreach (var skill in supportUnit.Skills)
        {
            if (skill.skillType == SkillType.CommanderPassive)
            {
                foreach (var effect in skill.effects)
                {
                    if (effect is SkillEffect_ApplyBuff buffEffect && buffEffect.isCommanderPassiveAura)
                    {
                        BattleLog.Instance.AddLog($"{supportUnit.UnitName} 的指揮官被動技能 [{skill.skillName}] 正在發動！");
                        
                        List<BattleUnit> targetTeam;
                        if (skill.targetType == SkillTargetType.Ally_All)
                        {
                            targetTeam = battleManager.GetSameTeam(supportUnit);
                        }
                        else if (skill.targetType == SkillTargetType.Enemy_All)
                        {
                            targetTeam = battleManager.GetOpposingTeam(supportUnit);
                        }
                        else continue;

                        foreach (var buffDef in buffEffect.BuffsToApply)
                        {
                            foreach (var targetUnit in targetTeam)
                            {
                                if (targetUnit != null && !targetUnit.IsDead)
                                {
                                    targetUnit.GetComponent<BuffController>()?.ApplyAura(buffDef, supportUnit);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #endregion
}
```

#### **BattleManager.cs**
戰鬥場景總控制器。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattleManager : MonoBehaviour
{
    #region 核心數據&模組引用
    public static BattleManager Instance { get; private set; }
    public BattleEncounterSO EncounterData { get; private set; }
    public List<BattleUnit> PlayerUnits { get; private set; }
    public List<BattleUnit> EnemyUnits { get; private set; }
    
    public Transform[] GridSpawns => gridSpawns;
    [SerializeField] private Transform[] gridSpawns = new Transform[8];

    [Header("系統模組")]
    [SerializeField] private TurnManager turnManager;
    [SerializeField] private BattleUIManager uiManager;
    [SerializeField] private BattleRules battleRules;
    [SerializeField] private BattleActions battleActions;
    [SerializeField] private EnemyBattleAI enemyAI;
    [SerializeField] private CharacterStateRule characterStateRule;
    [SerializeField] private BattlefieldStateSimulator stateSimulator;
    
    private TurnActionPlanner actionPlanner;
    #endregion

    #region Unity生命週期
    private void Awake() 
    { 
        Instance = this; 
        if (stateSimulator == null)
        {
            stateSimulator = FindObjectOfType<BattlefieldStateSimulator>();
        }
    }
    
    void Start()
    {
        EncounterData = GameManager.Instance.CurrentEncounter;
        if (EncounterData == null) { Debug.LogError("沒有傳入戰鬥遭遇數據！"); return; }

        SpawnUnits();
        InitializeSystems();
        
        turnManager.StartBattle();
    }
    #endregion

    #region 初始化與單位生成
    private void InitializeSystems()
    {
        actionPlanner = new TurnActionPlanner();
        turnManager.Initialize(this, uiManager, actionPlanner, battleRules, battleActions, enemyAI, characterStateRule, stateSimulator);
        uiManager.Initialize(turnManager);
        stateSimulator.Initialize(GetAllUnits(), characterStateRule);
    }
    
    private void SpawnUnits()
    {
        PlayerUnits = new List<BattleUnit>();
        EnemyUnits = new List<BattleUnit>();
    
        var battleParty = PartyManager.Instance.BattleParty;
        for (int i = 0; i < battleParty.Count; i++)
        {
            var role = (BattleRole)i;
            var position = GetInitialPositionForRole(role, true);
            var spawnTransform = gridSpawns[(int)position];
            
            GameObject unitGO = Instantiate(battleParty[i].BaseData.unitPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(battleParty[i], role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            PlayerUnits.Add(unit);
        }
        foreach (var enemyPos in EncounterData.enemyTeam)
        {
            var role = enemyPos.role;
            var position = GetInitialPositionForRole(role, false);
            var spawnTransform = gridSpawns[(int)position];
            GameObject unitGO = Instantiate(enemyPos.enemyData.enemyPrefab, spawnTransform.position, spawnTransform.rotation);
            BattleUnit unit = unitGO.GetComponent<BattleUnit>();
            unit.Setup(enemyPos.enemyData, role, position);
            unit.OnUnitClicked += turnManager.OnUnitClicked;
            EnemyUnits.Add(unit);
        }
    }
    #endregion

    #region 戰鬥邏輯輔助
    public void HandleTeamPromotions()
    {
        CheckAndPromoteForTeam(PlayerUnits);
        CheckAndPromoteForTeam(EnemyUnits);
    }

    private void CheckAndPromoteForTeam(List<BattleUnit> team)
    {
        var promotionOrder = new List<GridPosition> { GridPosition.PlayerVanguard, GridPosition.PlayerRanged1, GridPosition.PlayerRanged2, GridPosition.PlayerSupport };
        if (team.Any() && !team.First().IsPlayerTeam)
        {
            promotionOrder = new List<GridPosition> { GridPosition.EnemyVanguard, GridPosition.EnemyRanged1, GridPosition.EnemyRanged2, GridPosition.EnemySupport };
        }
        
        for (int i = 0; i < promotionOrder.Count - 1; i++)
        {
            GridPosition currentPos = promotionOrder[i];
            BattleUnit unitAtCurrentPos = GetUnitAtPosition(currentPos, team);
            if (unitAtCurrentPos == null || unitAtCurrentPos.IsDead)
            {
                for (int j = i + 1; j < promotionOrder.Count; j++)
                {
                    GridPosition substitutePos = promotionOrder[j];
                    BattleUnit substituteUnit = GetUnitAtPosition(substitutePos, team);
                    if (substituteUnit != null && !substituteUnit.IsDead)
                    {
                        BattleLog.Instance.AddLog($"{substituteUnit.UnitName} 自動替補到 {currentPos} 位置！");
                        substituteUnit.SetNewPosition(currentPos);
                        substituteUnit.transform.position = gridSpawns[(int)currentPos].position;
                        break;
                    }
                }
            }
        }
    }

    private GridPosition GetInitialPositionForRole(BattleRole role, bool isPlayer)
    {
        if (isPlayer)
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.PlayerVanguard;
                case BattleRole.Ranged1:  return GridPosition.PlayerRanged1;
                case BattleRole.Ranged2:  return GridPosition.PlayerRanged2;
                case BattleRole.Support:  return GridPosition.PlayerSupport;
            }
        }
        else
        {
            switch (role)
            {
                case BattleRole.Vanguard: return GridPosition.EnemyVanguard;
                case BattleRole.Ranged1:  return GridPosition.EnemyRanged1;
                case BattleRole.Ranged2:  return GridPosition.EnemyRanged2;
                case BattleRole.Support:  return GridPosition.EnemySupport;
            }
        }
        throw new System.Exception("無效的角色或隊伍");
    }
    #endregion

    #region 公共查詢方法
    public BattleUnit GetUnitAtPosition(GridPosition pos, List<BattleUnit> team) => team.FirstOrDefault(u => u.CurrentPosition == pos && !u.IsDead);
    public List<BattleUnit> GetAllUnits() => PlayerUnits.Concat(EnemyUnits).ToList();
    public List<BattleUnit> GetOpposingTeam(BattleUnit unit) => unit.IsPlayerTeam ? EnemyUnits : PlayerUnits;
    public List<BattleUnit> GetSameTeam(BattleUnit unit) => unit.IsPlayerTeam ? PlayerUnits : EnemyUnits;
    public BattleUnit GetUnitAtPosition(GridPosition pos)
    {
        if (pos == GridPosition.None) return null;
        return GetAllUnits().FirstOrDefault(u => !u.IsDead && u.CurrentPosition == pos);
    }
    public bool IsBattleWon()
    {
        return turnManager != null && turnManager.CurrentState == BattleState.Won;
    }
    #endregion
}
```

#### **BattleUIManager.cs**
UI 系統協調者。

```csharp
using UnityEngine;
using System.Collections.Generic;

public class BattleUIManager : MonoBehaviour
{
    #region 引用與初始化
    private TurnManager turnManager;

    [Header("UI 面板")]
    [SerializeField] private ActionPanelUI actionPanel;
    [SerializeField] private ActionSlotPanelUI actionSlotPanel;
    [SerializeField] private BattleUI battleUI;
    [SerializeField] private BattleEndUI battleEndUI;
    [SerializeField] private BattleItemUI battleItemPanel;
    [SerializeField] private SkillSelectionPanelUI skillSelectionPanel;
    
    public void Initialize(TurnManager tm)
    {
        turnManager = tm;
        battleUI.Setup(cmd => OnUICommand(cmd, null));
        actionSlotPanel.Initialize((cmd, plan) => OnUICommand(cmd, plan));
    }
    #endregion
    
    #region 主狀態UI控制
    public void EnterPlayerPlanningState(TurnActionPlanner planner)
    {
        HideAllActionPanels();
        actionSlotPanel.UpdatePanel(planner);
        actionSlotPanel.gameObject.SetActive(true);
        battleUI.SetEndTurnButtonInteractable(false);
        battleUI.SetResetButtonVisible(true);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterEnemyTurnState()
    {
        HideAllActionPanels();
        battleUI.SetEndTurnButtonInteractable(false);
        battleUI.SetResetButtonVisible(false);
        battleUI.SetBackButtonVisible(false);
    }

    public void EnterActionExecutionState()
    {
        HideAllActionPanels();
    }
    #endregion
    
    #region 引導式規劃UI
    public void ShowRangedUnitSelection(List<BattleUnit> units, int stepIndex)
    {
        HideAllActionPanels();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        units.ForEach(u => u.SetHighlight(true));
        battleUI.SetBackButtonVisible(false);
        BattleLog.Instance.AddLog("請選擇一位遠程單位來規劃行動。");
    }

    public void ShowActionSelectionFor(BattleUnit unit, int stepIndex, Dictionary<ActionType, bool> feasibility)
    {
        DeselectAllHighlights();
        unit.SetHighlight(true);
        
        actionPanel.ShowPanel(unit, turnManager.OnActionSelected);
        actionPanel.UpdateButtonStates(feasibility);
        
        actionSlotPanel.SetPlanningHighlight(stepIndex);
        battleUI.SetBackButtonVisible(true);
    }
    
    public void ShowTargetSelection(List<BattleUnit> validTargets)
    {
        actionPanel.HidePanel();
        DeselectAllHighlights();
        validTargets.ForEach(t => t.SetHighlight(true));
        BattleLog.Instance.AddLog("請選擇一個目標。");
    }

    public void ShowItemSelection(System.Action<Item> onItemSelected)
    {
        HideAllActionPanels();
        DeselectAllHighlights();
        battleItemPanel.ShowPanel(onItemSelected);
        BattleLog.Instance.AddLog("請選擇要使用的道具。");
    }

    public void ShowItemTargetSelection(List<BattleUnit> validTargets)
    {
        if (battleItemPanel != null) battleItemPanel.HidePanel();
        DeselectAllHighlights();
        validTargets.ForEach(t => t.SetHighlight(true));
        BattleLog.Instance.AddLog("請選擇使用對象。");
    }

    public void ShowPlanningFinishedState()
    {
        HideAllActionPanels();
        actionSlotPanel.SetPlanningHighlight(-1);
        battleUI.SetEndTurnButtonInteractable(true);
        battleUI.SetBackButtonVisible(false);
    }

    public void ShowSkillSelection(Dictionary<SkillData, bool> skillFeasibility, System.Action<SkillData> onSkillSelectedCallback)
    {
        HideAllActionPanels();
        DeselectAllHighlights();

        if (skillSelectionPanel != null)
        {
            skillSelectionPanel.ShowPanel(skillFeasibility, onSkillSelectedCallback);
        }
        else
        {
            Debug.LogError("BattleUIManager 未指定 SkillSelectionPanelUI！");
        }
    }
    
    public void UpdateActionSlots(TurnActionPlanner planner)
    {
        actionSlotPanel.UpdatePanel(planner);
    }
    #endregion

    #region 通用UI控制
    public void ShowVictoryScreen(int gold) { battleEndUI.ShowVictory(gold); }
    public void ShowDefeatScreen() { battleEndUI.ShowDefeat(); }
    public void SetResetButtonVisible(bool visible)
    {
        if (battleUI != null)
        {
            battleUI.SetResetButtonVisible(visible);
        }
    }
    public void SetEndTurnButtonInteractable(bool interactable)
    {
        if (battleUI != null)
        {
            battleUI.SetEndTurnButtonInteractable(interactable);
        }
    }
    public void SetBackButtonVisible(bool visible)
    {
        if (battleUI != null)
        {
            battleUI.SetBackButtonVisible(visible);
        }
    }

    public void SetCommanderSkillButtons(bool showUseButton, bool showCancelButton, bool isInteractable)
    {
        if (battleUI != null)
        {
            battleUI.SetCommanderSkillButtons(showUseButton, showCancelButton, isInteractable);
        }
        else
        {
            Debug.LogWarning("BattleUIManager 無法控制指揮官技能按鈕，因為 BattleUI 未指定！");
        }
    }
    
    private void HideAllActionPanels()
    {
        actionPanel.HidePanel();
        if (battleItemPanel != null) battleItemPanel.HidePanel();
        DeselectAllHighlights();
        actionSlotPanel.SetPlanningHighlight(-1);
    }

    public void HideItemSelectionPanel()
    {
        if (battleItemPanel != null)
        {
            battleItemPanel.HidePanel();
        }
    }
    
    public void HideSkillSelectionPanel()
    {
        if (skillSelectionPanel != null)
        {
            skillSelectionPanel.HidePanel();
        }
    }

    private void DeselectAllHighlights()
    {
        if (BattleManager.Instance == null) return;
        foreach(var unit in BattleManager.Instance.PlayerUnits) unit.SetHighlight(false);
        foreach(var unit in BattleManager.Instance.EnemyUnits) unit.SetHighlight(false);
    }
    #endregion
    
    #region 事件傳遞
    private void OnUICommand(UICommandType command, ActionPlan planData = null)
    {
        turnManager.OnUICommand(command, planData);
    }
    #endregion
}
```

#### **GameManager.cs**
遊戲狀態管理器。

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Linq;
using System.Collections.Generic;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    
    public BattleEncounterSO CurrentEncounter { get; private set; }
    
    [Header("場景名稱設定")]
    [SerializeField] private string mainSceneName = "Title";
    [SerializeField] private string battleSceneName = "BattleScene";

    [Header("場景管理UI")]
    [Tooltip("請將您場景中的讀取畫面 UI 物件拖曳至此")]
    [SerializeField] private GameObject loadingScreen; 

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
        else
        {
            Debug.LogError("[GameManager] 未在 Inspector 中指定 LoadingScreen 物件！非同步載入功能可能無法正確顯示讀取畫面。");
        }
    }

    public void StartBattle(BattleEncounterSO encounter)
    {
        if (encounter == null)
        {
            Debug.LogError("嘗試開始戰鬥，但傳入的 BattleEncounterSO 為空！");
            return;
        }
        StartCoroutine(LoadBattleSceneCoroutine(encounter));
    }

    public void EndBattle()
    {
        StartCoroutine(LoadMainSceneCoroutine());
    }

    private IEnumerator LoadBattleSceneCoroutine(BattleEncounterSO encounter)
    {
        CurrentEncounter = encounter;
        
        // 1. 顯示讀取畫面
        if (loadingScreen != null)
        {
            loadingScreen.SetActive(true);
        }

        // 2. 開始非同步載入目標場景
        // LoadSceneAsync 會在背景線程中載入場景，不會凍結主線程
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(battleSceneName);

        // 3. 迴圈等待，直到場景載入完成
        // asyncLoad.isDone 會在場景載入完成後變為 true
        while (!asyncLoad.isDone)
        {
            // 在此處可以更新進度條 UI
            // 例如: loadingProgressBar.value = asyncLoad.progress;
            yield return null;
        }

        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
    }
    
    private IEnumerator LoadMainSceneCoroutine()
    {
        ProcessBattleResults();
        UpdatePartyStatusAfterBattle();
        CurrentEncounter = null;

        if (loadingScreen != null)
        {
            loadingScreen.SetActive(true);
        }

        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(mainSceneName);

        while (!asyncLoad.isDone)
        {
            yield return null;
        }

        if (loadingScreen != null)
        {
            loadingScreen.SetActive(false);
        }
    }

    private void UpdatePartyStatusAfterBattle()
    {
        if (BattleManager.Instance == null || PartyManager.Instance == null) return;

        foreach (var unit in BattleManager.Instance.PlayerUnits)
        {
            MemberInstance instanceToUpdate = PartyManager.Instance.AllMembers.FirstOrDefault(
                m => m.instanceID == unit.MemberInstance.instanceID
            );

            if (instanceToUpdate != null)
            {
                instanceToUpdate.currentHP = unit.CurrentHP;
                Debug.Log($"已更新成員 [{instanceToUpdate.BaseData.memberName}] 的血量為: {instanceToUpdate.currentHP}");
            }
        }
    }

    private void ProcessBattleResults()
    {
        if (BattleManager.Instance == null) return;
        if (BattleManager.Instance.IsBattleWon())
        {
            var encounterData = BattleManager.Instance.EncounterData;
            int totalGold = 0;
            // int totalExp = 0;
            foreach(var enemyUnit in BattleManager.Instance.EnemyUnits)
            {
                if(enemyUnit.EnemyData != null)
                {
                    totalGold += enemyUnit.EnemyData.goldDrop;
                    // totalExp += enemyUnit.EnemyData.expDrop;
                }
            }
            if(PlayerState.Instance != null)
            {
                PlayerState.Instance.AddMoney(totalGold);
                // PlayerState.Instance.GainExperience(totalExp);
                Debug.Log($"戰鬥勝利！獲得金幣: {totalGold}");
            }
            if (QuestManager.Instance != null)
            {
                foreach (var enemyUnit in BattleManager.Instance.EnemyUnits)
                {
                    if (enemyUnit.IsDead && enemyUnit.EnemyData != null)
                    {
                        string enemyID = enemyUnit.EnemyData.enemyID;
                        QuestManager.Instance.AdvanceObjective(enemyID, QuestObjectiveType.Kill, 1);
                        Debug.Log($"向任務系統報告擊殺: {enemyID}");
                    }
                }
            }
        }
    }
}
```

---

### **5. 戰鬥邏輯**

#### **BattleRules.cs**
戰鬥法典。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "BattleRules", menuName = "Battle System/Battle Rules")]
public class BattleRules : ScriptableObject
{
    public List<IBattleUnit_ReadOnly> GetEligibleActorsForStep(int stepIndex, List<CharacterStateRule.UnitStateSnapshot> currentState, TurnActionPlanner planner)
    {
        var eligibleActors = new List<IBattleUnit_ReadOnly>();
        bool isVanguardStep = (stepIndex % 2 == 0);
        var potentialActorSnaps = currentState.Where(s => s.Unit.IsPlayerTeam && !s.Unit.IsDead && s.Role != BattleRole.Support).ToList();

        foreach (var snap in potentialActorSnaps)
        {
            bool isUnitVanguardInSnapshot = (snap.Role == BattleRole.Vanguard);
            if ((isVanguardStep && !isUnitVanguardInSnapshot) || (!isVanguardStep && isUnitVanguardInSnapshot)) continue;

            int maxActions = (snap.Role == BattleRole.Vanguard) ? 4 : 2;

            if (planner.GetActionCountForUnit(snap.Unit) < maxActions)
            {
                eligibleActors.Add(snap.Unit);
            }
        }
        return eligibleActors;
    }

    private bool CanUnitAct(IBattleUnit_ReadOnly unit, TurnActionPlanner planner, int maxActions)
    {
        if (unit == null || unit.IsDead) return false;
        return planner.GetActionCountForUnit(unit) < maxActions;
    }
    
    // --- 查詢行動可行性 (給UI按鈕用) ---
    public Dictionary<ActionType, bool> GetActionFeasibility(IBattleUnit_ReadOnly actor, CharacterStateRule.BattleStateSnapshot currentState, TurnActionPlanner planner)
    {
        var feasibility = new Dictionary<ActionType, bool>();
        var unitSnaps = currentState.UnitSnapshots;
        
        // 攻擊
        feasibility[ActionType.Attack] = GetValidTargets(actor, unitSnaps).Any();
        // 交換
        feasibility[ActionType.Exchange] = GetValidExchangeTargets(actor,unitSnaps).Any(); 
        // 道具
        feasibility[ActionType.Item] = currentState.InventorySnapshot.HasAnyConsumables();
        
        // 體力檢查
        var actorSnap = unitSnaps.First(s => s.Unit == actor);
        if (actorSnap.Stamina < 3) feasibility[ActionType.Attack] = false;
        if (actorSnap.Stamina < 2) feasibility[ActionType.Exchange] = false;

        // 其他行動總是可行
        feasibility[ActionType.Defend] = true;
        feasibility[ActionType.Rest] = true;
        feasibility[ActionType.Skip] = true;
        
        return feasibility;
    }

    public List<IBattleUnit_ReadOnly> GetValidTargets(IBattleUnit_ReadOnly attacker, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (attacker == null || attacker.IsDead) return validTargets;

        var attackerSnap = currentState.First(s => s.Unit == attacker);
        var opponentSnaps = currentState.Where(s => s.Unit.IsPlayerTeam != attacker.IsPlayerTeam && !s.Unit.IsDead && s.Role != BattleRole.Support);

        var enemyVanguardSnap = opponentSnaps.FirstOrDefault(s => s.Role == BattleRole.Vanguard);

        IEnumerable<CharacterStateRule.UnitStateSnapshot> potentialTargets = (enemyVanguardSnap != null) 
            ? new List<CharacterStateRule.UnitStateSnapshot> { enemyVanguardSnap } 
            : opponentSnaps;

        foreach (var targetSnap in potentialTargets)
        {
            int distance = Mathf.Abs((int)attackerSnap.Position - (int)targetSnap.Position);
            if (distance <= attacker.AttackRange)
            {
                validTargets.Add(targetSnap.Unit);
            }
        }
        return validTargets;
    }
    
    public List<IBattleUnit_ReadOnly> GetValidExchangeTargets(IBattleUnit_ReadOnly actor, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (actor == null || actor.IsDead || actor.Role == BattleRole.Support) return validTargets;
        
        var actorSnap = currentState.First(s => s.Unit == actor);
        var teammateSnaps = currentState.Where(s => s.Unit.IsPlayerTeam == actor.IsPlayerTeam && s.Unit != actor && !s.Unit.IsDead && s.Role != BattleRole.Support);

        foreach (var mateSnap in teammateSnaps)
        {
            bool canSwap = false;
            switch (actorSnap.Role)
            {
                case BattleRole.Vanguard: canSwap = (mateSnap.Role == BattleRole.Ranged1); break;
                case BattleRole.Ranged1: canSwap = (mateSnap.Role == BattleRole.Vanguard || mateSnap.Role == BattleRole.Ranged2); break;
                case BattleRole.Ranged2: canSwap = (mateSnap.Role == BattleRole.Ranged1); break;
            }
            if(canSwap) validTargets.Add(mateSnap.Unit);
        }
        return validTargets;
    }

    public List<IBattleUnit_ReadOnly> GetValidItemTargets(IBattleUnit_ReadOnly user)
    {
        if (user == null || user.IsDead) return new List<IBattleUnit_ReadOnly>();

        var teammates = user.IsPlayerTeam ? BattleManager.Instance.PlayerUnits : BattleManager.Instance.EnemyUnits;
        return teammates.Where(u => !u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
    }

    public List<IBattleUnit_ReadOnly> GetValidSkillTargets(IBattleUnit_ReadOnly source, SkillData skill, List<CharacterStateRule.UnitStateSnapshot> currentState)
    {
        var validTargets = new List<IBattleUnit_ReadOnly>();
        if (source == null || skill == null) return validTargets;

        var sourceSnap = currentState.First(s => s.Unit == source);

        switch (skill.targetType)
        {
            case SkillTargetType.Enemy_Single:
                var opponentSnaps = currentState.Where(s => s.Unit.IsPlayerTeam != source.IsPlayerTeam && !s.Unit.IsDead);
                foreach (var targetSnap in opponentSnaps)
                {
                    int distance = Mathf.Abs((int)sourceSnap.Position - (int)targetSnap.Position);
                    if (skill.range == 0 || distance <= skill.range)
                    {
                        validTargets.Add(targetSnap.Unit);
                    }
                }
                break;

            case SkillTargetType.Ally_Single:
                var allySnaps = currentState.Where(s => s.Unit.IsPlayerTeam == source.IsPlayerTeam && !s.Unit.IsDead && s.Unit != source);
                foreach (var targetSnap in allySnaps)
                {
                    int distance = Mathf.Abs((int)sourceSnap.Position - (int)targetSnap.Position);
                    if (skill.range == 0 || distance <= skill.range)
                    {
                        validTargets.Add(targetSnap.Unit);
                    }
                }
                break;
            case SkillTargetType.None:
            case SkillTargetType.Self:
            case SkillTargetType.Ally_All:
            case SkillTargetType.Enemy_All:
            case SkillTargetType.Enemy_Penetrate:
            default:
                break;
        }
        return validTargets;
    }
    
    private bool HasConsumableItems()
    {
        if (InventoryManager.Instance == null || InventoryManager.Instance.playerInventoryData == null)
        {
            return false;
        }
        return InventoryManager.Instance.playerInventoryData.slots.Any(s => !s.IsEmpty() && s.item.itemType == ItemType.Consumable);
    }

    public bool IsVictory(List<BattleUnit> enemyUnits) => enemyUnits.All(u => u.IsDead);
    public bool IsDefeat(List<BattleUnit> playerUnits) => playerUnits.All(u => u.IsDead);
    public bool IsSkillUsable(IBattleUnit_ReadOnly source, SkillData skill, CharacterStateRule.BattleStateSnapshot currentState)
    {
        if (source == null || skill == null || currentState == null) return false;

        // 1. 檢查體力是否足夠
        var sourceSnap = currentState.UnitSnapshots.FirstOrDefault(s => s.Unit == source);
        if (sourceSnap == null || sourceSnap.Stamina < skill.staminaCost)
        {
            return false;
        }
        
        // 2. 檢查指揮官技能的使用次數 (未來擴充點)
        // if (skill.isCommanderSkill_OneTimeUse && battleManager.HasCommanderSkillBeenUsed())
        // {
        //     return false;
        // }

        // (未來可擴充) 3. 檢查是否有沉默等特殊狀態
        // if (source.IsSilenced) return false;

        // 所有檢查都通過，技能可用
        return true;
    }
}
```

#### **BattleActions.cs**
行動邏輯的執行者。

```csharp
using UnityEngine;
using System;
using System.Linq;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "BattleActions", menuName = "Battle System/Battle Actions")]
public class BattleActions : ScriptableObject
{
    [Header("行動數值")]
    [SerializeField] private int attackStaminaCost = 3;
    [SerializeField] private int exchangeStaminaCost = 2;
    [SerializeField] private int restStaminaRecovery = 5;

    public int GetAttackStaminaCost() => attackStaminaCost;
    public int GetExchangeStaminaCost() => exchangeStaminaCost;
    public int GetRestStaminaRecovery() => restStaminaRecovery;

    public void Execute(ActionPlan plan, TurnActionPlanner planner, HashSet<Guid> processedTransactions, BattleManager battleManager)
    {
        // 1. 驗證甲方 (Source)
        BattleUnit sourceUnit = plan.Source?.GetMonoBehaviour();
        if (sourceUnit == null || sourceUnit.IsDead) return;
        // 2. 處理關聯行動的唯一性 (交換位置)
        if (plan.Type == ActionType.Exchange && plan.TransactionID != Guid.Empty)
        {
            if (processedTransactions.Contains(plan.TransactionID)) return;
            processedTransactions.Add(plan.TransactionID);
        }
        // 指令失效規則的重新定義
        ActionType finalActionType = plan.Type;
        BattleUnit finalTargetUnit = null; // 最終要被操作的對象

        // 根據行動類型，決定採用哪種鎖定策略
        switch (plan.Type)
        {
            // === 地域契約 ===
            case ActionType.Attack:
                // 在執行前一刻，去目標位置上看到底是誰
                finalTargetUnit = battleManager.GetUnitAtPosition(plan.TargetPosition);
                
                // 指令失效判斷：如果目標位置上沒人，或者站著自己人
                if (finalTargetUnit == null || finalTargetUnit.IsPlayerTeam == sourceUnit.IsPlayerTeam)
                {
                    finalActionType = (sourceUnit.Role == BattleRole.Vanguard) ? ActionType.Defend : ActionType.Rest;
                    BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 的攻擊位置 [{plan.TargetPosition}] 已無有效目標，行動變更為 [{finalActionType.ToActionName()}]！");
                    finalTargetUnit = null;
                }
                break;

            // === 人事契約 ===
            case ActionType.Exchange:
                // 直接從契約獲取乙方本人
                finalTargetUnit = plan.Target?.GetMonoBehaviour();

                // 指令失效判斷：如果契約乙方不存在或已陣亡
                if (finalTargetUnit == null || finalTargetUnit.IsDead)
                {
                    finalActionType = ActionType.Rest;
                    BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 的交換目標 [{plan.Target.UnitName}] 已消失，行動變更為 [{finalActionType.ToActionName()}]！");
                    finalTargetUnit = null;
                }
                break;
            
            // === 人事契約 ===
            case ActionType.Item:
                finalTargetUnit = plan.Target?.GetMonoBehaviour();
                // 指令失效判斷：如果目標已陣亡或道具沒了
                if (finalTargetUnit == null || finalTargetUnit.IsDead || plan.ItemUsed == null)
                {
                    finalActionType = ActionType.Rest;
                    finalTargetUnit = null;
                    BattleLog.Instance.AddLog($"{plan.Source.UnitName} 的道具目標已消失，行動變更為休息！");
                }
                break;

            // === 無目標行動 ===
            case ActionType.Defend:
            case ActionType.Rest:
            case ActionType.Skip:
                finalTargetUnit = null;
                break;
        }
        
        // 3. 根據最終決定的行動和目標來執行
        switch (finalActionType)
        {
            case ActionType.Attack:
                ExecuteAttack(sourceUnit, finalTargetUnit);
                break;
            case ActionType.Defend:
                ExecuteDefend(sourceUnit);
                break;
            case ActionType.Rest:
                ExecuteRest(sourceUnit);
                break;
            case ActionType.Exchange:
                ExecuteExchange(sourceUnit, finalTargetUnit, battleManager);
                break;
            case ActionType.Item:
                ExecuteItem(plan.Source.GetMonoBehaviour(), finalTargetUnit, plan.ItemUsed);
                break;
            case ActionType.Skip:
                BattleLog.Instance.AddLog($"{sourceUnit.UnitName} 選擇跳過行動。");
                break;
            case ActionType.Skill:
                ExecuteSkill(plan, battleManager);
                break;
        }
    }

    private void ExecuteAttack(BattleUnit source, BattleUnit target)
    {
        source.ConsumeStamina(attackStaminaCost);
        BattleLog.Instance.AddLog($"{source.UnitName} 對 {target.UnitName} 發動攻擊！");
        target.TakeDamage(source.CurrentAttack);
    }
    
    private void ExecuteDefend(BattleUnit source)
    {
        source.SetDefenseState(true);
        BattleLog.Instance.AddLog($"{source.UnitName} 進入防禦姿態。");
    }

    private void ExecuteRest(BattleUnit source)
    {
        source.RestoreStamina(restStaminaRecovery);
        BattleLog.Instance.AddLog($"{source.UnitName} 休息，恢復 {restStaminaRecovery} 體力。");
    }

    private void ExecuteExchange(BattleUnit source, BattleUnit target, BattleManager battleManager)
    {
        source.ConsumeStamina(exchangeStaminaCost);
        BattleLog.Instance.AddLog($"{source.UnitName} 與 {target.UnitName} 進行位置交換！");

        // 獲取雙方【當前】的核心數據
        GridPosition posA = source.CurrentPosition;
        GridPosition posB = target.CurrentPosition;
        BattleRole roleA = source.Role;
        BattleRole roleB = target.Role;

        // --- 執行核心數據交換 ---
        source.SetNewPosition(posB);
        target.SetNewPosition(posA);
        source.SetRole(roleB);
        target.SetRole(roleA);

        // --- 執行視覺交換 ---
        if (battleManager.GridSpawns[(int)posB] != null)
        {
            source.transform.position = battleManager.GridSpawns[(int)posB].position;
        }
        if (battleManager.GridSpawns[(int)posA] != null)
        {
            target.transform.position = battleManager.GridSpawns[(int)posA].position;
        }
    }

    private void ExecuteItem(BattleUnit source, BattleUnit target, Item item)
    {
        if (item.itemType != ItemType.Consumable) return;
        bool removed = InventoryManager.Instance.RemoveItem(item, 1);
        if (!removed)
        {
            BattleLog.Instance.AddLog($"行動失敗：背包中找不到 {item.itemName}！行動變更為休息。");
            ExecuteRest(source);
            return;
        }
        BattleLog.Instance.AddLog($"{source.UnitName} 對 {target.UnitName} 使用了 {item.itemName}！");

        // 根據道具效果修改目標狀態
        if (item.healAmount > 0)
        {
            target.Heal(item.healAmount);
        }
        // 未來可以在這裡擴充其他道具效果，如解除負面狀態、增加攻擊力等
    }

    private void ExecuteSkill(ActionPlan plan, BattleManager battleManager)
    {
        IBattleUnit_ReadOnly source = plan.Source;
        SkillData skill = plan.SkillUsed;

        if (source == null || source.IsDead || skill == null) return;

        BattleLog.Instance.AddLog($"{source.UnitName} 施放技能 [{skill.skillName}]！");

        // 1. 使用優化後的 GetTargetsForSkill 方法獲取所有受影響的目標
        List<IBattleUnit_ReadOnly> allTargets = GetTargetsForSkill(source, plan.Target, skill.targetType, battleManager);
        
        // 2. 消耗施法者的體力
        source.GetMonoBehaviour().ConsumeStamina(skill.staminaCost);

        // 3. 遍歷技能的所有效果並執行
        foreach(var effect in skill.effects)
        {
            if(effect != null)
            {
                effect.Execute(source, allTargets, battleManager);
            }
        }
    }

    private List<IBattleUnit_ReadOnly> GetTargetsForSkill(IBattleUnit_ReadOnly source, IBattleUnit_ReadOnly manualTarget, SkillTargetType targetType, BattleManager bm)
    {
        var targets = new List<IBattleUnit_ReadOnly>();
        
        var playerUnits = bm.PlayerUnits.Where(u => u != null && !u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
        var enemyUnits = bm.EnemyUnits.Where(u => u != null && !u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
        
        switch (targetType)
        {
            case SkillTargetType.Self:
                targets.Add(source);
                break;

            case SkillTargetType.Ally_Single:
            case SkillTargetType.Enemy_Single:
                if (manualTarget != null && !manualTarget.IsDead)
                {
                    targets.Add(manualTarget);
                }
                break;

            case SkillTargetType.Ally_All:
                targets.AddRange(source.IsPlayerTeam ? playerUnits : enemyUnits);
                break;

            case SkillTargetType.Enemy_All:
                targets.AddRange(source.IsPlayerTeam ? enemyUnits : playerUnits);
                break;

            case SkillTargetType.Enemy_Penetrate:
                var opponents = source.IsPlayerTeam ? enemyUnits : playerUnits;
                var vanguard = opponents.FirstOrDefault(u => u.Role == BattleRole.Vanguard);
                var ranged1 = opponents.FirstOrDefault(u => u.Role == BattleRole.Ranged1);
                if (vanguard != null) targets.Add(vanguard);
                if (ranged1 != null) targets.Add(ranged1);
                break;
                
            case SkillTargetType.None:
            default:
                break;
        }
        return targets;
    }
}
```

#### **TurnActionPlanner.cs**
回合行動規劃器。

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class TurnActionPlanner
{
    private const int TOTAL_PLAYER_STEPS = 8;
    
    private Dictionary<int, ActionPlan> playerPlansByStep = new Dictionary<int, ActionPlan>();
    private List<ActionPlan> enemyPlans = new List<ActionPlan>();

    public int GetPlayerPlanCount() => playerPlansByStep.Count;
    public bool IsPlanningFinished() => playerPlansByStep.Count >= TOTAL_PLAYER_STEPS;
    public bool IsStepPlanned(int stepIndex) => playerPlansByStep.ContainsKey(stepIndex);

    public int GetNextPlanningStepIndex()
    {
        for (int i = 0; i < TOTAL_PLAYER_STEPS; i++)
        {
            if (!playerPlansByStep.ContainsKey(i))
            {
                return i;
            }
        }
        return TOTAL_PLAYER_STEPS;
    }
    
    public int FindNextAvailableStep(BattleRole role, int startIndex = 0, List<int> excludeIndices = null)
    {
        bool isLookingForVanguard = (role == BattleRole.Vanguard);
        excludeIndices = excludeIndices ?? new List<int>();

        for (int i = startIndex; i < TOTAL_PLAYER_STEPS; i++)
        {
            if (playerPlansByStep.ContainsKey(i) || excludeIndices.Contains(i)) continue;

            bool isVanguardStep = (i % 2 == 0);

            if ((isLookingForVanguard && isVanguardStep) || (!isLookingForVanguard && !isVanguardStep)) return i;
        }
        return -1;
    }

    public void AddPlan(ActionPlan plan, int stepIndex)
    {
        if (plan.Type == ActionType.Skip || plan.Source == null)
        {
            if (stepIndex >= 0 && stepIndex < TOTAL_PLAYER_STEPS)
            {
                playerPlansByStep[stepIndex] = plan;
            }
            return;
        }

        if (plan.Source.IsPlayerTeam)
        {
            if (stepIndex >= 0 && stepIndex < TOTAL_PLAYER_STEPS)
            {
                playerPlansByStep[stepIndex] = plan;
            }
            else
            {
                Debug.LogError($"嘗試為玩家計畫添加無效的步驟索引: {stepIndex}");
            }
        }
        else
        {
            enemyPlans.Add(plan);
        }
    }

    public ActionPlan GetPlanAtStep(int stepIndex)
    {
        playerPlansByStep.TryGetValue(stepIndex, out ActionPlan plan);
        return plan;
    }

    public int GetStepIndexOfPlan(ActionPlan plan)
    {
        if (plan == null) return -1;
        foreach (var pair in playerPlansByStep)
        {
            if (pair.Value == plan)
            {
                return pair.Key;
            }
        }
        return -1;
    }
    
    public int GetLastPlanStepIndex()
    {
        if (playerPlansByStep.Count == 0) return -1;
        return playerPlansByStep.Keys.Max();
    }

    public void RemovePlansFromStep(int stepIndex)
    {
        if (playerPlansByStep.TryGetValue(stepIndex, out ActionPlan planToRemove))
        {
            if (planToRemove.TransactionID != Guid.Empty)
            {
                var keysToRemove = playerPlansByStep
                    .Where(pair => pair.Value.TransactionID == planToRemove.TransactionID)
                    .Select(pair => pair.Key)
                    .ToList();
                
                foreach (var key in keysToRemove)
                {
                    playerPlansByStep.Remove(key);
                }
            }
            else
            {
                playerPlansByStep.Remove(stepIndex);
            }
        }
    }
    
    public void ClearPlayerPlans()
    {
        playerPlansByStep.Clear();
    }
    
    public void PrepareForNewTurn()
    {
        var allUnitsWithDefense = new HashSet<IBattleUnit_ReadOnly>();
        foreach(var plan in playerPlansByStep.Values)
        {
            if (plan.Type == ActionType.Defend) allUnitsWithDefense.Add(plan.Source);
        }
        foreach(var plan in enemyPlans)
        {
            if (plan.Type == ActionType.Defend) allUnitsWithDefense.Add(plan.Source);
        }

        foreach(var unit in allUnitsWithDefense)
        {
            unit.GetMonoBehaviour().SetDefenseState(false);
        }
        playerPlansByStep.Clear();
        enemyPlans.Clear();
    }

    public ActionPlan GetActionForRole(int phase, bool isPlayer, BattleRole role)
    {
        if (isPlayer)
        {
            for (int i = 0; i < 8; i++)
            {
                if (playerPlansByStep.TryGetValue(i, out ActionPlan plan))
                {
                    bool isVanguardStep = (plan.PlannedForRole == BattleRole.Vanguard);
                    bool roleMatch = (role == BattleRole.Vanguard) ? isVanguardStep : !isVanguardStep;

                    if (plan.PhaseIndex == phase && roleMatch) return plan;
                }
            }
            return null;
        }
        else
        {
            return enemyPlans.FirstOrDefault(p =>
                p.PhaseIndex == phase &&
                (p.Source == null || !p.Source.IsPlayerTeam) && 
                (
                    (role == BattleRole.Vanguard && p.PlannedForRole == BattleRole.Vanguard) ||
                    (role != BattleRole.Vanguard && (p.PlannedForRole == BattleRole.Ranged1 || p.PlannedForRole == BattleRole.Ranged2))
                )
            );
        }
    }
    
    public int GetActionCountForUnit(IBattleUnit_ReadOnly unit)
    {
        return playerPlansByStep.Values.Count(p => p.Source == unit) + enemyPlans.Count(p => p.Source == unit);
    }
    
    public void RemovePlansFromDeadUnits(List<BattleUnit> allUnits)
    {
        var deadUnits = allUnits.Where(u => u.IsDead).Cast<IBattleUnit_ReadOnly>().ToList();
        if (deadUnits.Any())
        {
            var playerKeysToRemove = playerPlansByStep
                .Where(pair => deadUnits.Contains(pair.Value.Source) || (pair.Value.Target != null && deadUnits.Contains(pair.Value.Target)))
                .Select(pair => pair.Key)
                .ToList();
                
            foreach (var key in playerKeysToRemove)
            {
                playerPlansByStep.Remove(key);
            }
            
            int removedEnemyCount = enemyPlans.RemoveAll(p => deadUnits.Contains(p.Source) || (p.Target != null && deadUnits.Contains(p.Target)));

            if (playerKeysToRemove.Count > 0 || removedEnemyCount > 0)
            {
                BattleLog.Instance.AddLog($"因單位陣亡，移除了 {playerKeysToRemove.Count + removedEnemyCount} 個無效的行動計畫。");
            }
        }
    }
}
```
**注意**: `TurnActionPlanner` 不適合做成 ScriptableObject，因為它需要儲存每一場戰鬥的即時數據。這裡我已將其改為一個普通的類，您需要在 `BattleManager` 中 `new TurnActionPlanner()` 來創建實例。

#### **CharacterStateRule.cs**
管理戰鬥中角色在特定時間點的狀態變化規則。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "CharacterStateRule", menuName = "Battle System/Character State Rule")]
public class CharacterStateRule : ScriptableObject
{
    #region 背包模擬
    public class SimulatedInventory
    {
        private Dictionary<string, int> consumableCounts;

        public SimulatedInventory()
        {
            consumableCounts = new Dictionary<string, int>();
            if (InventoryManager.Instance != null && InventoryManager.Instance.playerInventoryData != null)
            {
                foreach (var slot in InventoryManager.Instance.playerInventoryData.slots)
                {
                    if (!slot.IsEmpty() && slot.item.itemType == ItemType.Consumable)
                    {
                        if (consumableCounts.ContainsKey(slot.item.uniqueItemID))
                        {
                            consumableCounts[slot.item.uniqueItemID] += slot.quantity;
                        }
                        else
                        {
                            consumableCounts[slot.item.uniqueItemID] = slot.quantity;
                        }
                    }
                }
            }
        }

        // 拷貝構造函數：從上一個模擬背包複製數據
        public SimulatedInventory(SimulatedInventory source)
        {
            this.consumableCounts = new Dictionary<string, int>(source.consumableCounts);
        }

        // 預扣道具
        public void ConsumeItem(string itemID)
        {
            if (consumableCounts.ContainsKey(itemID) && consumableCounts[itemID] > 0)
            {
                consumableCounts[itemID]--;
            }
        }

        // 檢查是否有任何消耗品
        public bool HasAnyConsumables()
        {
            return consumableCounts.Any(pair => pair.Value > 0);
        }

        // 檢查特定道具是否有庫存
        public bool HasItem(string itemID)
        {
            return consumableCounts.ContainsKey(itemID) && consumableCounts[itemID] > 0;
        }
    }

    // 新的快照容器，包含單位狀態和背包狀態
    public class BattleStateSnapshot
    {
        public List<UnitStateSnapshot> UnitSnapshots { get; }
        public SimulatedInventory InventorySnapshot { get; }

        public BattleStateSnapshot(List<UnitStateSnapshot> unitSnaps, SimulatedInventory inventorySnap)
        {
            UnitSnapshots = unitSnaps;
            InventorySnapshot = inventorySnap;
        }
    }
    #endregion

    #region 快照資料 & 運行
    public class UnitStateSnapshot
    {
        public IBattleUnit_ReadOnly Unit { get; }
        public int Stamina { get; }
        public GridPosition Position { get; }
        public BattleRole Role { get; }
        public UnitStateSnapshot(IBattleUnit_ReadOnly unit) { Unit = unit; Stamina = unit.CurrentStamina; Position = unit.CurrentPosition; Role = unit.Role; }
        public UnitStateSnapshot(UnitStateSnapshot source) { Unit = source.Unit; Stamina = source.Stamina; Position = source.Position; Role = source.Role; }
        public UnitStateSnapshot(UnitStateSnapshot source, int newStamina, GridPosition newPosition, BattleRole newRole) { Unit = source.Unit; Stamina = newStamina; Position = newPosition; Role = newRole; }
    }
    private List<BattleStateSnapshot> planningStepSnapshots = new List<BattleStateSnapshot>();

    public void InitializeSnapshots(List<BattleUnit> allUnits)
    {
        planningStepSnapshots.Clear();
        
        // 1. 創建單位初始快照
        List<UnitStateSnapshot> initialUnitSnapshot = new List<UnitStateSnapshot>();
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                initialUnitSnapshot.Add(new UnitStateSnapshot(unit));
            }
        }

        // 2. 創建背包初始快照
        SimulatedInventory initialInventory = new SimulatedInventory();

        // 3. 將兩者打包成一個 BattleStateSnapshot
        BattleStateSnapshot initialBattleState = new BattleStateSnapshot(initialUnitSnapshot, initialInventory);

        planningStepSnapshots.Add(initialBattleState);
        Debug.Assert(planningStepSnapshots.Count == 1, "初始化後，快照列表長度不為1！");
    }

    public BattleStateSnapshot GetLatestSnapshot()
    {
        if (planningStepSnapshots.Count == 0)
        {
            Debug.LogError("嚴重錯誤：快照列表為空！無法獲取最新快照。");
            return null;
        }
        return planningStepSnapshots.Last();
    }
    
    public void PruneSnapshotsToCount(int targetCount)
    {
        if (targetCount < 1) targetCount = 1;

        if (planningStepSnapshots.Count > targetCount)
        {
            int removeCount = planningStepSnapshots.Count - targetCount;
            planningStepSnapshots.RemoveRange(targetCount, removeCount);
        }
    }

    public void GenerateAndStoreNextSnapshot(ActionPlan plan, BattleActions actionCosts)
    {
        BattleStateSnapshot previousBattleState = GetLatestSnapshot();
        if (previousBattleState == null) return;

        // 1. 複製上一步的單位狀態
        List<UnitStateSnapshot> nextUnitState = previousBattleState.UnitSnapshots.Select(s => new UnitStateSnapshot(s)).ToList();
        
        // 2. 複製上一步的背包狀態
        SimulatedInventory nextInventoryState = new SimulatedInventory(previousBattleState.InventorySnapshot);

        if (plan.Type != ActionType.Skip && plan.Source != null)
        {
            var sourceSnap = nextUnitState.FirstOrDefault(s => s.Unit == plan.Source);
            if (sourceSnap != null)
            {
                int sourceIndex = nextUnitState.IndexOf(sourceSnap);
                int newStamina = sourceSnap.Stamina;
                GridPosition newSourcePos = sourceSnap.Position;
                BattleRole newSourceRole = sourceSnap.Role;

                switch (plan.Type)
                {
                    case ActionType.Attack:
                        newStamina -= actionCosts.GetAttackStaminaCost();
                        break;

                    case ActionType.Rest:
                        newStamina += actionCosts.GetRestStaminaRecovery();
                        newStamina = Mathf.Min(newStamina, plan.Source.MaxStamina);
                        break;

                    case ActionType.Item:
                        if (plan.ItemUsed != null)
                        {
                            nextInventoryState.ConsumeItem(plan.ItemUsed.uniqueItemID);
                        }
                        break;
                    
                    case ActionType.Exchange:
                        newStamina -= actionCosts.GetExchangeStaminaCost();
                        var targetSnap = nextUnitState.FirstOrDefault(s => s.Unit == plan.Target);
                        if (targetSnap != null)
                        {
                            int targetIndex = nextUnitState.IndexOf(targetSnap);
                            newSourcePos = targetSnap.Position;
                            newSourcePos = targetSnap.Position;
                            GridPosition newTargetPos = sourceSnap.Position;
                            newSourceRole = targetSnap.Role;
                            BattleRole newTargetRole = sourceSnap.Role;
                            nextUnitState[targetIndex] = new UnitStateSnapshot(targetSnap, targetSnap.Stamina, newTargetPos, newTargetRole);
                        }
                        break;
                    case ActionType.Skill:
                        if (plan.SkillUsed != null)
                        {
                            newStamina -= plan.SkillUsed.staminaCost;
                        }
                        break;
                }
                nextUnitState[sourceIndex] = new UnitStateSnapshot(sourceSnap, newStamina, newSourcePos, newSourceRole);
            }
        }
        // 3. 將新的單位狀態和背包狀態打包成下一個快照
        BattleStateSnapshot nextBattleState = new BattleStateSnapshot(nextUnitState, nextInventoryState);
        planningStepSnapshots.Add(nextBattleState);
    }
    
    public void RestoreAllUnitStamina(List<BattleUnit> allUnits)
    {
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                unit.SetStamina(unit.MaxStamina);
            }
        }
    }
    #endregion
}
```

#### **EnemyBattleAI.cs**
敵人進攻邏輯。

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "EnemyBattleAI", menuName = "Battle System/Enemy AI")]
public class EnemyBattleAI : ScriptableObject
{
    public void PlanActions(List<BattleUnit> selfUnits, List<BattleUnit> opponentUnits, TurnActionPlanner planner, BattleRules rules, int attackCost)
    {
        Dictionary<BattleUnit, int> simulatedStaminaTracker = new Dictionary<BattleUnit, int>();
        foreach(var unit in selfUnits)
        {
            simulatedStaminaTracker[unit] = unit.MaxStamina;
        }
        PlanForRole(BattleRole.Vanguard, 4, selfUnits, opponentUnits, planner, attackCost, simulatedStaminaTracker);
        PlanForRole(BattleRole.Ranged1, 2, selfUnits, opponentUnits, planner, attackCost, simulatedStaminaTracker);
        PlanForRole(BattleRole.Ranged2, 2, selfUnits, opponentUnits, planner, attackCost, simulatedStaminaTracker);
        
        BattleLog.Instance.AddLog("敵人已完成行動規劃。");
    }

    private void PlanForRole(BattleRole planningForRole, int maxActions, List<BattleUnit> self, List<BattleUnit> opponents, TurnActionPlanner planner, int attackCost, Dictionary<BattleUnit, int> staminaTracker)
    {
        BattleUnit unit = self.FirstOrDefault(u => u.Role == planningForRole && !u.IsDead);
        if (unit == null) return;

        int currentSimulatedStamina = staminaTracker[unit];

        GridPosition primaryTargetPos = GridPosition.PlayerVanguard;
        BattleUnit target = BattleManager.Instance.GetUnitAtPosition(primaryTargetPos);

        bool targetInRange = false;
        if (target != null)
        {
            int distance = Mathf.Abs((int)unit.CurrentPosition - (int)target.CurrentPosition);
            targetInRange = distance <= unit.AttackRange;
        }

        int actionsToPlan = maxActions - planner.GetActionCountForUnit(unit);
        for (int i = 0; i < actionsToPlan; i++)
        {
            int phaseIndex = (planner.GetActionCountForUnit(unit) / 2) + 1;
            if (phaseIndex > 4) break;

            ActionPlan newPlan;
            if (currentSimulatedStamina >= attackCost && targetInRange)
            {
                newPlan = ActionPlan.CreateAIAction(unit, primaryTargetPos, ActionType.Attack, phaseIndex, planningForRole);
                currentSimulatedStamina -= attackCost;
            }
            else
            {
                newPlan = ActionPlan.CreateNoTargetAction(unit, ActionType.Defend, phaseIndex, planningForRole);
            }
            planner.AddPlan(newPlan, -1);
        }
        staminaTracker[unit] = currentSimulatedStamina;
    }
    
    private GridPosition GetGridPositionForRole(BattleRole role, bool isPlayer)
    {
        if (isPlayer)
        {
            switch(role)
            {
                case BattleRole.Vanguard: return GridPosition.PlayerVanguard;
                case BattleRole.Ranged1: return GridPosition.PlayerRanged1;
                case BattleRole.Ranged2: return GridPosition.PlayerRanged2;
                case BattleRole.Support: return GridPosition.PlayerSupport;
            }
        }
        else
        {
            switch(role)
            {
                case BattleRole.Vanguard: return GridPosition.EnemyVanguard;
                case BattleRole.Ranged1: return GridPosition.EnemyRanged1;
                case BattleRole.Ranged2: return GridPosition.EnemyRanged2;
                case BattleRole.Support: return GridPosition.EnemySupport;
            }
        }
        return GridPosition.None;
    }
}
```

### **BattlefieldStateSimulator.cs**
戰場狀態模擬器。
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class BattlefieldStateSimulator : MonoBehaviour
{
    private List<BattleUnit> allUnits;
    private CharacterStateRule characterStateRule;

    public void Initialize(List<BattleUnit> units, CharacterStateRule rule)
    {
        allUnits = units;
        characterStateRule = rule;
    }

    public void ShowStateFromSnapshot(List<CharacterStateRule.UnitStateSnapshot> snapshot)
    {
        if (snapshot == null)
        {
            Debug.LogError("傳入的快照為空，無法更新視覺！");
            return;
        }

        // 步驟一：【先破】全局重置所有單位的視覺狀態
        foreach (var unit in allUnits)
        {
            if (unit != null && !unit.IsDead)
            {
                unit.ResetVisualsToCoreState();
            }
        }

        // 步驟二：【後立】根據快照數據，應用新的預演效果
        foreach (var unitSnapshot in snapshot)
        {
            BattleUnit unitToUpdate = allUnits.FirstOrDefault(u => u == unitSnapshot.Unit.GetMonoBehaviour());
            
            if (unitToUpdate != null && !unitToUpdate.IsDead)
            {
                GridPosition previewPos = unitSnapshot.Position;
                int previewStamina = unitSnapshot.Stamina;
                BattleRole previewRole = unitSnapshot.Role;

                unitToUpdate.UpdatePreviewVisuals(previewPos, previewStamina, previewRole);
            }
        }
    }

    public void ShowTemporaryStaminaPreview(IBattleUnit_ReadOnly unitToModify, int staminaCost)
    {
        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        if (latestSnapshot == null) return;

        ShowStateFromSnapshot(latestSnapshot.UnitSnapshots);

        // 1. 先獲取 BattleUnit 的 MonoBehaviour 實例
        BattleUnit unitMono = unitToModify.GetMonoBehaviour();
        if (unitMono == null) return;

        // 2. 在快照中找到對應的單位數據
        var unitSnap = latestSnapshot.UnitSnapshots.FirstOrDefault(s => s.Unit == unitToModify);

        // 3. 確保快照數據存在
        if (unitSnap != null)
        {
            int finalPreviewStamina = unitSnap.Stamina - staminaCost;
            // 4. 使用之前獲取的 unitMono 變數來調用方法
            unitMono.UpdatePreviewVisuals(unitSnap.Position, finalPreviewStamina, unitSnap.Role);
        }
    }
    
    public void ClearTemporaryPreviews()
    {
        var latestSnapshot = characterStateRule.GetLatestSnapshot();
        if (latestSnapshot != null)
        {
            ShowStateFromSnapshot(latestSnapshot.UnitSnapshots);
        }
    }
}
```