這是一個正在研發的 Unity 遊戲 Demo，幫我紀錄，方便我有問題可以修改

### **系統架構總覽**

目前的遊戲系統是一個以**數據驅動 (Data-Driven)** 為核心的架構。遊戲的內容，如物品、對話和任務，主要存放在外部檔案（ScriptableObject 和 XML）中，而 C# 腳本則作為這些數據的「執行引擎」。這種架構的優點是**高靈活性**和**易於擴展**，策劃或設計師可以透過修改數據文件來改變遊戲內容，而不需要改動程式碼。

系統可以分為以下幾個核心模組：

1.  **玩家與輸入 (Player & Input)**：負責玩家的基礎操作和與世界的互動。
2.  **物品與背包 (Item & Inventory)**：管理所有遊戲內物品的數據、拾取、儲存和使用。
3.  **對話系統 (Dialogue System)**：處理所有遊戲中的文字互動，是一個基於 XML 的強大敘事引擎。
4.  **任務系統 (Quest System)**：管理任務的生命週期，從接取到完成，並與對話系統緊密耦合。
5.  **世界互動 (World Interaction)**：定義了玩家可以互動的對象，如 NPC 和觸發器。
6.  **隊伍系統 (Party System)**：管理所有遊戲內成員的數據、資料、儲存和使用。
7.  **JSON 系統 (JSON System)**：負責將玩家的隊伍進度存到檔案裡，以及從檔案裡讀取出來。

---

### **各腳本功能簡介**

#### **一、 玩家與輸入模組 (Player & Input Module)**

*   `Player.cs`:
    *   **職責**：玩家的物理控制器與互動發起者。
    *   **功能**：處理基於 `Rigidbody2D` 的移動。偵測並記錄周圍的可拾取物品 (`GroundItem`) 和可互動物件 (`IInteractable`)。提供 `TryPickupItem()` 和 `TryInteract()` 方法供 `KeyManager` 呼叫。

*   `PlayerState.cs`:
    *   **職責**：玩家的核心數據容器。
    *   **功能**：儲存玩家的非背包數據，目前主要是金錢 (`money`)。提供了增加和花費金錢的接口，是交易系統的基礎。

*   `KeyManager.cs`:
    *   **職責**：中央輸入處理器。
    *   **功能**：監聽所有非移動的鍵盤輸入（如 `I` 開背包, `Q` 開任務, `E` 互動, `Space` 拾取, `ESC` 關閉面板），並將這些指令分派給對應的管理系統（`InventoryManager`, `QuestUI`, `Player`）。

---

#### **二、 物品與背包模組 (Item & Inventory Module)**

*   `Item.cs` (ScriptableObject):
    *   **職責**：定義單個物品的所有靜態數據。
    *   **功能**：作為物品的模板，包含名稱、描述、圖標、類型、堆疊上限、唯一ID (`uniqueItemID`) 和交易價格等。

*   `ItemDatabase.cs` (ScriptableObject):
    *   **職責**：所有物品的總資料庫。
    *   **功能**：存放遊戲中所有 `Item` ScriptableObject 的列表，並提供一個靜態方法 `GetItemByID()`，讓其他系統可以透過唯一ID快速查找物品數據。

*   `Inventory.cs` (ScriptableObject):
    *   **職責**：定義一個背包的數據結構。
    *   **功能**：包含背包的容量 (`capacity`) 和一個 `InventorySlot` 列表，用於實際儲存物品。允許多個不同背包的存在（如玩家背包、倉庫）。

*   `InventorySlot.cs`:
    *   **職責**：背包中的單個格子。
    *   **功能**：儲存一個 `Item` 的引用和其數量 (`quantity`)。封裝了添加、移除、清空和交換物品的核心邏輯。

*   `GroundItem.cs`:
    *   **職責**：代表掉落在地上的物品實體。
    *   **功能**：掛載在一個遊戲物件上，使其可被玩家拾取。包含 `Item` 數據和數量，並透過 `AttemptPickup()` 方法與 `InventoryManager` 互動。

*   `InventoryManager.cs`:
    *   **職責**：背包系統的總管（單例）。
    *   **功能**：管理玩家的 `Inventory` 數據。處理添加 (`AddItem`)、移除 (`RemoveItem`)、查詢 (`HasItem`) 物品的邏輯。與 `InventoryUI` 溝通以刷新界面，並在拋棄物品時生成 `GroundItem`。

*   `InventoryUI.cs` & `InventorySlotUI.cs`:
    *   **職責**：背包的視覺表現。
    *   **功能**：`InventoryUI` 根據 `Inventory` 數據動態生成 `InventorySlotUI` 列表。`InventorySlotUI` 負責顯示單個格子的圖標和數量。同時處理拖拽 (`ItemDragHandler`) 和點擊顯示詳情 (`ItemDetailsPanel`) 的交互。

*   `ItemDetailsPanel.cs` & `ItemDropUI.cs`:
    *   **職責**：物品的交互面板。
    *   **功能**：`ItemDetailsPanel` 顯示被點擊物品的詳細資訊，並提供使用/丟棄按鈕。`ItemDropUI` 在丟棄物品時彈出，讓玩家可以選擇丟棄的數量。

*   `ItemDragHandler.cs`:
    *   **職責**：處理背包格子內物品的拖拽邏輯。
    *   **功能**：實現 Unity 的拖拽接口 (`IBeginDragHandler` 等)，允許玩家在背包內移動或堆疊物品。

---

#### **三、 對話系統模組 (Dialogue System Module)**

*   `DialogueData.cs`:
    *   **職責**：定義對話數據的 C# 類別結構。
    *   **功能**：完美映射了 `dialogues.xml` 的結構，包括 `DialogueSegment` (對話片段), `DialogueOption` (選項), `DialogueBranch` (條件分支) 和 `DialogueAction` (動作)，是 XML 數據在內存中的體現。`DynamicOptions` (動態選項請求) 和 `DialogueOptionTemplate` (選項範本) 的結構**，使程式能理解 XML 中動態生成選項的指令。

*   `DialogueManager.cs`:
    *   **職責**：對話系統的大腦（單例），具備**動態內容生成**能力。
    *   **功能**：
        *   負責載入和快取 XML 對話檔案，並管理整個對話流程。
        *   **動態選項生成**：能夠解析 `<DynamicOptions>` 標籤，主動向 `QuestManager` 等其他系統查詢數據（如可接任務列表），並根據查詢結果和範本 (`OptionTemplate`) 即時創建對話選項。
        *   當遇到被標記為 `IsEnd` 且沒有任何可用選項的對話片段時，會**自動生成一個 `[離開]` 按鈕**，防止遊戲流程卡死。
        *   **追蹤互動對象**：能記錄當前是哪個 `NPC` 觸發了對話，以便精準地處理針對該 NPC 的動態選項請求。
        *   **對話流程控制**：根據 `DialogueTrigger` 或 `NPC` 的請求，啟動和管理整個對話流程。核心功能是解析 `DialogueBranch`，執行 `QuestManager` 的條件檢查，並根據結果觸發對應的 `DialogueAction`（如跳轉片段、結束對話、啟動新對話模組）。

*   `DialogueUI.cs`:
    *   **職責**：對話的視覺界面。
    *   **功能**：接收 `DialogueManager` 的指令，顯示說話人姓名、對話文本，並動態生成選項按鈕。能夠**完美展示由 `DialogueManager` 靜態或動態生成的任何選項列表**。

---

#### **四、 任務系統模組 (Quest System Module)**

*   `QuestData.cs`:
    *   **職責**：定義任務數據的 C# 類別結構。
    *   **功能**：映射了 `quests.xml` 的結構，包含任務ID、名稱、描述、目標 (`QuestObjective`)、獎勵 (`ItemReward`)，以及核心的**前提條件** (`Prerequisites`) 和**可重複性** (`IsRepeatable`)。

*   `QuestDatabase.cs`:
    *   **職責**：任務的靜態資料庫。
    *   **功能**：在遊戲啟動時載入 `quests.xml`，並將所有任務數據存入字典中。提供靜態方法 `GetQuest()` 供 `QuestManager` 獲取任務的原始模板。

*   `QuestManager.cs`:
    *   **職責**：所有任務狀態的管理者（單例）。
    *   **功能**：
        *   追蹤每個任務的當前狀態 (`NotStarted`, `InProgress`, `Completed`) 和進度。提供接受 (`AcceptQuest`)、完成 (`CompleteQuest`) 任務的接口。
        *   **提供任務列表查詢**：新增了 `GetAvailableQuestsForNPC()` 和 `GetInProgressOrCompletableQuestsForNPC()` 等方法。這些方法不再只返回 `true/false`，而是**直接返回一個完整的任務物件列表 (`List<Quest>`)**，供 `DialogueManager` 用來動態生成選項。
        *   最重要的是，它提供了多種查詢方法（如 `HasAvailableQuests`, `IsQuestCompletable`）供 `DialogueManager` 進行條件判斷。

*   `QuestUI.cs`:
    *   **職責**：任務日誌的視覺界面。
    *   **功能**：顯示進行中和已完成的任務列表。點擊任務項可查看詳細描述、目標進度和獎勵。透過訂閱 `QuestManager` 的事件，實現任務狀態改變時的自動刷新。

---

#### **五、 世界互動模組 (World Interaction Module)**

*   `IInteractable.cs` (Interface):
    *   **職責**：定義一個「可互動」的標準。
    *   **功能**：只包含一個 `Interact()` 方法。任何實現了此接口的類（如 `NPC`, `DialogueTrigger`）都可以被 `Player` 識別並與之互動。

*   `NPC.cs`:
    *   **職責**：非玩家角色的核心組件。
    *   **功能**：
        *   實現了 `IInteractable` 接口。包含唯一的 `npcID` 和一個可提供的**任務列表** (`availableQuestIDs`)。當玩家與其互動時，它會啟動 `DialogueManager`，觸發其指定的入口對話 (`mainDialogueID`)。
        *   **傳遞身份**：當玩家與其互動時，它在啟動 `DialogueManager` 的同時，會**將自己的 `npcID` 一併傳遞過去**。這一步對於實現精確的動態選項至關重要。

*   `DialogueTrigger.cs`:
    *   **職責**：通用的對話觸發器。
    *   **功能**：實現了 `IInteractable` 接口。可以放置在任何物件上（如一個告示牌、一本書），當玩家與其互動時，觸發一段指定的對話。是實現非 NPC 對話的便捷方式。

---

#### **六、 隊伍系統模組 (Party System Module)**

*   `MemberDataSO.cs` (ScriptableObject):
    *   **職責**：定義一個成員的「原始設計藍圖」。
    *   **功能**：
        *   包含成員的靜態資料，如 ID、名稱、圖像、基礎屬性與成長規則。
        *   由開發者在 Unity 編輯器中設定，作為遊戲的基礎設定值，一旦設定好就不會改變。

*   `PartyDatabase.cs` (ScriptableObject):
    *   **職責**：為遊戲中所有成員設計藍圖 (`MemberDataSO`) 的「中央資料庫」。
    *   **功能**：
        *   持有一個遊戲中所有 `MemberDataSO` 的列表。
        *   提供一個全域靜態方法 (`GetMemberDataByID`)，讓任何腳本都能透過 ID 快速查詢到成員的原始資料，是整個系統的資料來源。

*   `MemberInstance.cs` (Serializable Class):
    *   **職責**：代表一個玩家「實際擁有、會成長」的成員個體。
    *   **功能**：
        *   儲存動態資料，如等級、經驗值、當前血量。
        *   透過 `memberDataSO_ID` 關聯到它的設計藍圖，並以此計算出當前的最大血量、攻擊力等屬性。
        *   擁有一個獨一無二的 `instanceID`，用於在存檔中識別每一個體。
        *   這個類別的物件會被寫入 JSON 存檔中，記錄玩家進度。

*   `PartyManager.cs`:
    *   **職責**：作為隊伍系統的「中央管理器」，處理所有隊伍相關的邏輯與狀態變更。
    *   **功能**：
        *   管理玩家的兩個核心列表：`AllMembers` (所有成員倉庫) 和 `BattleParty` (戰鬥隊伍)。
        *   提供方法來執行操作，如「上陣」、「卸下」、「交換順序」。
        *   當隊伍資料發生任何變動（如成員增減、順序變更）時，會觸發一個全域事件 (`OnPartyUpdated`)，通知所有 UI 介面進行更新。
        *   作為存檔和讀檔的發起點，會呼叫 `JSONSaveManager` 來執行實際的檔案操作。

*   `MemberCardUI.cs`:
    *   **職責**：作為可重用的 UI 元件，專門用來顯示成員的「基礎資訊卡片」（如倉庫列表）。
    *   **功能**：
        *   接收一個 `MemberInstance` 資料，並在卡片上顯示其名稱和圖像。
        *   處理點擊事件，通知上層管理器（如 `PartyHolderUI`）玩家選擇了哪個成員。
        *   根據傳入的狀態（如是否被選中、是否在戰鬥隊伍中）顯示不同的視覺效果，例如發光的邊框。

*   `MemberStatCardUI.cs`:
    *   **職責**：作為可重用的 UI 元件，專門用來顯示成員的「詳細戰鬥屬性卡片」（如戰鬥隊伍欄位）。
    *   **功能**：
        *   接收一個 `MemberInstance` 資料，並顯示更詳細的資訊，如名稱、圖像、當前/最大血量、攻擊力等。

*   `PartyHolderUI.cs`:
    *   **職責**：管理「全部成員倉庫」的 UI 介面。
    *   **功能**：
        *   監聽 `PartyManager` 的 `OnPartyUpdated` 事件。
        *   事件觸發時，它會根據 `PartyManager` 的 `AllMembers` 列表，動態生成或更新所有 `MemberCardUI`。
        *   當卡片被點擊時，它會呼叫 `PartyDetailUI` 來顯示該成員的詳細資料。

*   `PartyBattleUI.cs`:
    *   **職責**：管理「當前戰鬥隊伍」的 UI 介面。
    *   **功能**：
        *   同樣監聽 `OnPartyUpdated` 事件。
        *   事件觸發時，它會根據 `PartyManager` 的 `BattleParty` 列表，更新戰鬥隊伍欄位中的 `MemberStatCardUI`。
        *   負責顯示當前出戰成員的卡片，並處理拖曳交換順序等互動。

*   `PartyDetailUI.cs`:
    *   **職責**：管理「成員詳細資料」的彈出式面板。
    *   **功能**：
        *   平時隱藏，在玩家點擊任一成員卡片時被呼叫並顯示。
        *   展示指定 `MemberInstance` 的所有詳細數據（等級、經驗、屬性等）。
        *   面板上的「上陣/卸下」按鈕會根據該成員的當前狀態動態改變其文字和功能。

---

#### **七、 JSON 系統模組 (JSON System Module)**

*   `JSONSaveManager.cs`:
    *   **職責**：專職的「存檔與讀檔工具人」，負責處理 JSON 序列化與檔案系統操作。
    *   **功能**：
        *   提供 `SavePartyData` 方法，將 `PartySaveData` 物件轉換成 JSON 格式的文字，並寫入硬碟檔案。
        *   提供 `LoadPartyData` 方法，從硬碟讀取 JSON 檔案，將其轉換回 `PartySaveData` 物件，並交還給 `PartyManager`。
        *   管理存檔路徑，並能在讀檔時進行資料驗證，確保存檔的相容性。

*   `PartySaveData.cs` (Serializable Class):
    *   **職責**：作為一個資料「包裹」或「容器」，專門用來配合 Unity 的 JSON 工具進行序列化。
    *   **功能**：
        *   它的存在是為了解決技術限制：Unity 的 `JsonUtility` 無法直接序列化一個根層級的 List。
        *   它將所有需要存檔的列表（如 `AllMembers` 和 `BattlePartyInstanceIDs`）打包成一個單一的物件，讓 `JSONSaveManager` 可以順利地處理。好的，這就為您口語化地整理一下剛剛那些腳本的功能介紹。

---

### **完整代碼**

### 第 1 部分：資料結構 (`QuestData.cs`, `DialogueData.cs`, `QuestDatabase.cs`)

#### 1.1. `QuestData.cs`

```csharp
// QuestData.cs
using System.Collections.Generic;
using System.Xml.Serialization;
using UnityEngine;

// 任務目標類型
public enum QuestObjectiveType { Collect, Kill, Talk, GoTo }

// 任務的一個具體目標
[System.Serializable]
public class QuestObjective
{
    [XmlAttribute("type")]
    public QuestObjectiveType type;

    [XmlAttribute("targetID")]
    public string targetID; // 物品ID, 敵人ID, NPC ID, 地點ID

    [XmlAttribute("amount")]
    public int requiredAmount;

    [XmlAttribute("description")]
    public string description;

    // 執行緒不安全的，僅用於 runtime
    [XmlIgnore]
    public int currentAmount = 0;
}

// 物品獎勵
[System.Serializable]
public class ItemReward
{
    [XmlAttribute("id")]
    public string itemID;

    [XmlAttribute("amount")]
    public int amount;
}

// 完整的任務定義
[System.Serializable]
public class Quest
{
    public enum QuestStatus { NotStarted, InProgress, Completed, Failed }
    
    [XmlAttribute("id")]
    public string questID;
    
    [XmlElement("Name")]
    public string questName;

    [XmlElement("Description")]
    public string description;
    
    [XmlElement("GiverNPC")]
    public string giverNPCID;

    [XmlElement("HandInNPC")]
    public string handInNPCID;
    
    // 任務前提條件
    [XmlArray("Prerequisites")]
    [XmlArrayItem("QuestID")]
    public List<string> prerequisiteQuestIDs = new List<string>();

    // 任務是否可重複
    [XmlElement("IsRepeatable")]
    public bool isRepeatable = false;
    
    [XmlArray("Objectives")]
    [XmlArrayItem("Objective")]
    public List<QuestObjective> objectives = new List<QuestObjective>();
    
    [XmlArray("Rewards")]
    [XmlArrayItem("Item")]
    public List<ItemReward> itemRewards = new List<ItemReward>();
    
    [XmlElement("Money")]
    public int moneyReward;
    
    // 檢查所有目標是否都已完成
    public bool AreAllObjectivesComplete()
    {
        foreach (var obj in objectives)
        {
            if (obj.currentAmount < obj.requiredAmount)
            {
                return false;
            }
        }
        return true;
    }
    
    // 重置任務進度
    public void ResetProgress()
    {
        foreach (var obj in objectives)
        {
            obj.currentAmount = 0;
        }
    }
}
```

#### 1.2. `DialogueData.cs`

```csharp
// DialogueData.cs
using System.Collections.Generic;
using System.Xml.Serialization;

// 對話的一個片段，包含說話者、文本和選項
[System.Serializable]
public class DialogueSegment
{
    [XmlAttribute("id")]
    public string id;

    [XmlElement("Speaker")]
    public string speakerName;

    [XmlElement("Text")]
    public string dialogueText;
    
    // 如果為 true，則此段對話結束後直接關閉對話框
    [XmlElement("IsEnd")]
    public bool isEnd = false;

    [XmlArray("Options")]
    [XmlArrayItem("Option")]
    public List<DialogueOption> options = new List<DialogueOption>();

    [XmlElement("DynamicOptions")]
    public List<DynamicOptions> dynamicOptions = new List<DynamicOptions>();
}

// 玩家可選的選項
[System.Serializable]
public class DialogueOption
{
    [XmlElement("Text")]
    public string text;

    // 舊的條件系統，仍然可以用來決定選項是否「顯示」
    [XmlElement("Condition")]
    public List<DialogueCondition> displayConditions = new List<DialogueCondition>();

    // 簡單的線性動作列表 (當沒有分支時使用)
    [XmlElement("Action")]
    public List<DialogueAction> actions = new List<DialogueAction>();
    
    // 複雜的分支邏輯
    [XmlElement("Branch")]
    public DialogueBranch branch; // 如果這個存在，將優先於上面的 actions 列表
}

// 代表動態選項的範本
[System.Serializable]
public class DialogueOptionTemplate
{
    [XmlAttribute("text")]
    public string text; // e.g., "{questName}"

    // 範本可以包含簡單動作或複雜分支
    [XmlElement("Action")]
    public List<DialogueAction> actions = new List<DialogueAction>();
    
    [XmlElement("Branch")]
    public DialogueBranch branch;
}

// 代表動態生成的請求
[System.Serializable]
public class DynamicOptions
{
    [XmlAttribute("source")]
    public string source; // "QuestManager", "ShopManager", etc.

    [XmlAttribute("type")]
    public string type; // "AvailableQuests", "SellableItems", etc.

    [XmlAttribute("npcID")]
    public string npcID; // 目標 NPC 的 ID

    [XmlElement("OptionTemplate")]
    public DialogueOptionTemplate optionTemplate;
}

// 基礎的條件/動作類，用於XML序列化
[System.Serializable]
public class BaseDialogueAction
{
    [XmlAttribute("type")]
    public string type;

    [XmlAttribute("value")]
    public string value;
}

// 繼承自基礎類，方便區分
[System.Serializable]
public class DialogueCondition : BaseDialogueAction { }

[System.Serializable]
public class DialogueAction : BaseDialogueAction { }


// 代表一個完整的對話，例如某個NPC的主線對話
[System.Serializable]
public class Dialogue
{
    [XmlAttribute("id")]
    public string dialogueID;

    [XmlElement("Segment")]
    public List<DialogueSegment> segments = new List<DialogueSegment>();
}

// 整個對話資料庫，對應 XML 根節點
[XmlRoot("DialogueDatabase")]
public class DialogueDatabase
{
    [XmlElement("Dialogue")]
    public List<Dialogue> dialogues = new List<Dialogue>();
}

// 分支邏輯的資料結構
// 代表一個條件檢查
[System.Serializable]
public class DialogueCheck
{
    [XmlAttribute("type")]
    public string type;

    [XmlAttribute("value")]
    public string value;
}

// 代表一個完整的 IF-THEN-ELSE 分支
[System.Serializable]
public class DialogueBranch
{
    [XmlElement("Check")]
    public DialogueCheck check;

    [XmlArray("OnTrue")]
    [XmlArrayItem("Action")]
    public List<DialogueAction> trueActions = new List<DialogueAction>();

    [XmlArray("OnFalse")]
    [XmlArrayItem("Action")]
    public List<DialogueAction> falseActions = new List<DialogueAction>();
}
```

#### 1.3. `QuestDatabase.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using System.Xml.Serialization;
using System.Linq;

// 這個腳本不是 MonoBehaviour，而是一個靜態存取點
public static class QuestDatabase
{
    private static Dictionary<string, Quest> quests;
    private static bool isLoaded = false;

    // 確保只載入一次
    private static void LoadDatabase()
    {
        if (isLoaded) return;

        quests = new Dictionary<string, Quest>();
        
        // 1. 從讀取單一檔案，改為讀取資料夾內所有 TextAsset
        TextAsset[] questFiles = Resources.LoadAll<TextAsset>("GameData/Quests");
        if (questFiles.Length == 0)
        {
            Debug.LogWarning("[QuestDatabase] 在 'Resources/GameData/Quests' 資料夾中找不到任何任務檔案。");
            isLoaded = true;
            return;
        }

        foreach (var questFile in questFiles)
        {
            // 2. 序列化器從 QuestDatabaseRoot 改為 Quest，因為每個檔案只有一個任務
            XmlSerializer serializer = new XmlSerializer(typeof(Quest));
            using (StringReader reader = new StringReader(questFile.text))
            {
                try
                {
                    Quest quest = (Quest)serializer.Deserialize(reader);
                    if (quest != null && !string.IsNullOrEmpty(quest.questID))
                    {
                        if (!quests.ContainsKey(quest.questID))
                        {
                            quests.Add(quest.questID, quest);
                        }
                        else
                        {
                            Debug.LogWarning($"[QuestDatabase] 發現重複的任務 ID: {quest.questID} (在檔案 {questFile.name} 中)。");
                        }
                    }
                }
                catch (System.Exception e)
                {
                     Debug.LogError($"[QuestDatabase] 解析任務檔案 '{questFile.name}' 失敗: {e.Message}");
                }
            }
        }

        Debug.Log($"[QuestDatabase] 成功載入 {quests.Count} 個獨立任務。");
        isLoaded = true;
    }

    public static Quest GetQuest(string questID)
    {
        LoadDatabase(); // 確保已載入
        if (quests.TryGetValue(questID, out Quest questTemplate))
        {
            // 返回一個深拷貝，以防止對資料庫中的原始數據進行修改
            return new Quest
            {
                questID = questTemplate.questID,
                questName = questTemplate.questName,
                description = questTemplate.description,
                giverNPCID = questTemplate.giverNPCID,
                handInNPCID = questTemplate.handInNPCID,
                prerequisiteQuestIDs = new List<string>(questTemplate.prerequisiteQuestIDs),
                isRepeatable = questTemplate.isRepeatable,
                objectives = questTemplate.objectives.Select(o => new QuestObjective {
                    type = o.type,
                    targetID = o.targetID,
                    requiredAmount = o.requiredAmount,
                    description = o.description,
                    currentAmount = 0
                }).ToList(),
                itemRewards = new List<ItemReward>(questTemplate.itemRewards),
                moneyReward = questTemplate.moneyReward
            };
        }
        Debug.LogWarning($"[QuestDatabase] 找不到 ID 為 '{questID}' 的任務。");
        return null;
    }
}

// 輔助類，用於 XML 根節點的反序列化
[XmlRoot("QuestDatabase")]
public class QuestDatabaseRoot
{
    [XmlElement("Quest")]
    public List<Quest> quests = new List<Quest>();
}
```


### 第 2 部分：UI 設計（`QuestUI.cs`, `Dialogue.cs`）

#### 2.1. `QuestUI.cs`

```csharp
// QuestUI.cs
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class QuestUI : MonoBehaviour
{
    [Header("UI 元件")]
    [SerializeField] private GameObject questPanel;
    [SerializeField] private Transform questListContainer;
    [SerializeField] private GameObject questListItemPrefab;
    
    [Header("詳情面板")]
    [SerializeField] private TextMeshProUGUI questNameText;
    [SerializeField] private TextMeshProUGUI questDescriptionText;
    [SerializeField] private TextMeshProUGUI questObjectivesText;
    [SerializeField] private TextMeshProUGUI questRewardsText;

    private List<GameObject> currentListItems = new List<GameObject>();

    void Start()
    {
        // 訂閱事件，以便在任務狀態改變時自動刷新
        QuestManager.Instance.OnQuestAccepted += (id) => RefreshUI();
        QuestManager.Instance.OnQuestCompleted += (id) => RefreshUI();
        QuestManager.Instance.OnQuestUpdated += (id) => RefreshUI();

        questPanel.SetActive(false);
    }
    
    public void TogglePanel()
    {
        bool isActive = !questPanel.activeSelf;
        questPanel.SetActive(isActive);
        if (isActive)
        {
            RefreshUI();
        }
    }

    // 刷新整個任務日誌
    public void RefreshUI()
    {
        // 如果面板是關閉的，就沒必要刷新
        if (!questPanel.activeSelf) return;

        QuestManager.Instance?.SyncCollectionQuests();
        // 清理舊的列表項
        foreach (var item in currentListItems)
        {
            Destroy(item);
        }
        currentListItems.Clear();
        
        // 獲取所有活躍任務
        List<Quest> activeQuests = QuestManager.Instance.GetActiveQuests();

        // 為每個任務創建列表項
        foreach (var quest in activeQuests)
        {
            GameObject listItem = Instantiate(questListItemPrefab, questListContainer);
            listItem.GetComponentInChildren<TextMeshProUGUI>().text = quest.questName;
            
            Button button = listItem.GetComponent<Button>();
            button.onClick.AddListener(() => {
                ShowQuestDetails(quest);
            });
            currentListItems.Add(listItem);
        }
        
        // 預設顯示第一個任務的詳情，或清空詳情
        if (activeQuests.Count > 0)
        {
            ShowQuestDetails(activeQuests[0]);
        }
        else
        {
            ClearDetails();
        }
    }

    // 顯示指定任務的詳細資訊
    private void ShowQuestDetails(Quest quest)
    {
        questNameText.text = quest.questName;
        questDescriptionText.text = quest.description;

        // 顯示目標
        string objectivesStr = "";
        foreach (var obj in quest.objectives)
        {
            objectivesStr += $"- {obj.description} ({obj.currentAmount} / {obj.requiredAmount})\n";
        }
        questObjectivesText.text = objectivesStr;

        // 1. 檢查並添加金錢獎勵
        string rewardsStr = "獎勵:\n";
        bool hasAnyReward = false;
        if (quest.moneyReward > 0)
        {
            rewardsStr += $"- 金錢: {quest.moneyReward}\n";
            hasAnyReward = true;
        }
        foreach (var reward in quest.itemRewards)
        {
            Item item = ItemDatabase.Instance.GetItemByID(reward.itemID);
            rewardsStr += $"- {item.itemName} x{reward.amount}\n";
        }
        questRewardsText.text = rewardsStr;

        // 3. 如果沒有任何獎勵，可以顯示提示文字
        if (!hasAnyReward)
        {
            rewardsStr += "- 無";
        }
    }

    // 清空詳情面板
    private void ClearDetails()
    {
        questNameText.text = "沒有進行中的任務";
        questDescriptionText.text = "";
        questObjectivesText.text = "";
        questRewardsText.text = "";
    }

    void OnDestroy()
    {
        // 移除事件訂閱，防止內存洩漏
        if (QuestManager.Instance != null)
        {
            QuestManager.Instance.OnQuestAccepted -= (id) => RefreshUI();
            QuestManager.Instance.OnQuestCompleted -= (id) => RefreshUI();
            QuestManager.Instance.OnQuestUpdated -= (id) => RefreshUI();
        }
    }
}
```
#### 2.2. `DialogueUI.cs`

```csharp
// DialogueUI.cs
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;
using System;

public class DialogueUI : MonoBehaviour
{
    [Header("UI 元件")]
    [SerializeField] private GameObject dialoguePanel;
    [SerializeField] private TextMeshProUGUI speakerNameText;
    [SerializeField] private TextMeshProUGUI dialogueText;
    [SerializeField] private Transform optionsContainer;
    [SerializeField] private GameObject optionButtonPrefab;

    private List<GameObject> currentOptionButtons = new List<GameObject>();

    void Awake()
    {
        // 初始時隱藏面板
        if (dialoguePanel != null)
        {
            dialoguePanel.SetActive(false);
        }
    }

    // 顯示對話內容
    public void ShowDialogue(string speakerName, string text)
    {
        dialoguePanel.SetActive(true);
        speakerNameText.text = speakerName;
        dialogueText.text = text;
        ClearOptions();
    }

    // 顯示選項
    public void ShowOptions(List<DialogueOption> options, Action<DialogueOption> onOptionSelectedCallback)
    {
        ClearOptions();

        foreach (var option in options)
        {
            GameObject buttonGO = Instantiate(optionButtonPrefab, optionsContainer);
            buttonGO.GetComponentInChildren<TextMeshProUGUI>().text = option.text;
            
            // 為按鈕添加點擊事件監聽器
            Button button = buttonGO.GetComponent<Button>();
            button.onClick.AddListener(() => {
                onOptionSelectedCallback?.Invoke(option);
            });
            
            currentOptionButtons.Add(buttonGO);
        }
    }
    
    // 清除舊的選項按鈕
    private void ClearOptions()
    {
        foreach (var button in currentOptionButtons)
        {
            Destroy(button);
        }
        currentOptionButtons.Clear();
    }

    // 隱藏整個對話面板
    public void HideDialogue()
    {
        dialoguePanel.SetActive(false);
        ClearOptions();
    }
}
```

### 第 3 部分：核心管理器與組件（`QuestManager.cs`, `DialogueManager.cs`, `DialogueTrigger.cs`,`NPC.cs`, `KeyManager.cs`, `IInteractable.cs`）

#### 3.1. `QuestManager.cs`
```csharp
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;

public class QuestManager : MonoBehaviour
{
    public static QuestManager Instance { get; private set; }

    // 追蹤任務狀態的字典
    private Dictionary<string, Quest.QuestStatus> questStatuses = new Dictionary<string, Quest.QuestStatus>();
    // 儲存活躍任務的進度
    private Dictionary<string, Quest> activeQuests = new Dictionary<string, Quest>();
    // 快取場景中所有的 NPC，避免重複查找
    private Dictionary<string, NPC> npcCache = new Dictionary<string, NPC>();

    // 事件
    public event Action<string> OnQuestAccepted;
    public event Action<string> OnQuestCompleted;
    public event Action<string> OnQuestUpdated;

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // 在遊戲開始時快取所有 NPC
    private void Start()
    {
        CacheAllNPCs();
    }

    private void CacheAllNPCs()
    {
        npcCache.Clear();
        NPC[] allNpcs = FindObjectsOfType<NPC>();
        foreach(var npc in allNpcs)
        {
            if (!npcCache.ContainsKey(npc.GetNpcID()))
            {
                npcCache.Add(npc.GetNpcID(), npc);
            }
        }
    }

    // 檢查前提條件是否滿足
    public bool ArePrerequisitesMet(string questID)
    {
        Quest quest = QuestDatabase.GetQuest(questID);
        if (quest == null) return false;

        foreach (var prereqID in quest.prerequisiteQuestIDs)
        {
            if (GetQuestStatus(prereqID) != Quest.QuestStatus.Completed)
            {
                return false; // 只要有一個前置任務沒完成，就不滿足
            }
        }
        return true;
    }

    // 獲取指定 NPC 的所有可接任務
    public List<Quest> GetAvailableQuestsForNPC(string npcID)
    {
        List<Quest> available = new List<Quest>();
        if (npcCache.TryGetValue(npcID, out NPC npc))
        {
            foreach (var questID in npc.GetQuestList())
            {
                if (GetQuestStatus(questID) == Quest.QuestStatus.NotStarted && ArePrerequisitesMet(questID))
                {
                    // 從資料庫獲取完整的任務數據，因為我們需要任務名稱
                    Quest q = QuestDatabase.GetQuest(questID);
                    if (q != null)
                    {
                        available.Add(q);
                    }
                }
            }
        }
        return available;
    }

    // 獲取指定 NPC 的所有進行中或可完成的任務
    public List<Quest> GetInProgressOrCompletableQuestsForNPC(string npcID)
    {
        // 直接從 activeQuests 中篩選，效率更高
        return activeQuests.Values.Where(q => q.handInNPCID == npcID).ToList();
    }

    public bool CheckCustomCondition(string condition, string npcID)
    {
        switch (condition)
        {
            case "HasProgressOrCompletableQuests":
                return activeQuests.Values.Any(q => q.handInNPCID == npcID);
            // ... 未來可擴充
        }
        return false;
    }

    // 獲取任務狀態
    public Quest.QuestStatus GetQuestStatus(string questID)
    {
        if (questStatuses.TryGetValue(questID, out Quest.QuestStatus status))
        {
            return status;
        }
        return Quest.QuestStatus.NotStarted;
    }
    
    // 接受任務
    public void AcceptQuest(string questID)
    {
        if (GetQuestStatus(questID) != Quest.QuestStatus.NotStarted || !ArePrerequisitesMet(questID))
        {
            Debug.LogWarning($"[QuestManager] 無法接受任務 {questID}，狀態不符或前置未完成。");
            return;
        }

        Quest newQuest = QuestDatabase.GetQuest(questID);
        if (newQuest != null)
        {
            questStatuses[questID] = Quest.QuestStatus.InProgress;
            activeQuests[questID] = newQuest;
            Debug.Log($"[QuestManager] 已接受任務: {newQuest.questName}");
            OnQuestAccepted?.Invoke(questID);
        }
    }
    
    // 完成任務
    public void CompleteQuest(string questID)
    {
        if (GetQuestStatus(questID) != Quest.QuestStatus.InProgress) return;
        
        if (activeQuests.TryGetValue(questID, out Quest quest))
        {
            // 雙重檢查確保目標已達成
            if (!quest.AreAllObjectivesComplete())
            {
                Debug.LogWarning($"[QuestManager] 嘗試完成任務 '{questID}' 但目標未達成。");
                return;
            }
            
            // 發放獎勵
            PlayerState playerState = FindObjectOfType<PlayerState>();
            if (playerState != null)
            {
                playerState.AddMoney(quest.moneyReward);
            }
            foreach (var reward in quest.itemRewards)
            {
                Item item = ItemDatabase.Instance.GetItemByID(reward.itemID);
                InventoryManager.Instance.AddItem(item, reward.amount);
            }

            // 處理可重複任務
            if (quest.isRepeatable)
            {
                questStatuses[questID] = Quest.QuestStatus.NotStarted; // 狀態重置為未開始
                quest.ResetProgress(); // 清空進度
            }
            else
            {
                questStatuses[questID] = Quest.QuestStatus.Completed; // 設為永久完成
            }
            
            // 更新狀態
            questStatuses[questID] = Quest.QuestStatus.Completed;
            activeQuests.Remove(questID);
            Debug.Log($"[QuestManager] 已完成任務: {quest.questName}");
            OnQuestCompleted?.Invoke(questID);
        }
    }

    public bool HasAvailableQuests(string npcID)
    {
        if (npcCache.TryGetValue(npcID, out NPC npc))
        {
            foreach (var questID in npc.GetQuestList())
            {
                if (GetQuestStatus(questID) == Quest.QuestStatus.NotStarted && ArePrerequisitesMet(questID))
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    public bool HasProgressOrCompletableQuests(string npcID)
    {
        return activeQuests.Values.Any(q => q.handInNPCID == npcID);
    }

    public bool IsQuestCompletable(string questID)
    {
        if (activeQuests.TryGetValue(questID, out Quest quest))
        {
            return quest.AreAllObjectivesComplete();
        }
        return false;
    }

    // 更新任務進度 (由外部事件呼叫，例如殺敵、撿物品)
    public void AdvanceObjective(string targetID, QuestObjectiveType type, int amount = 1)
    {
        // 遍歷所有活躍任務
        foreach (var quest in activeQuests.Values.ToList())
        {
            bool updated = false;
            foreach (var objective in quest.objectives)
            {
                if (objective.type == type && objective.targetID == targetID && objective.currentAmount < objective.requiredAmount)
                {
                    objective.currentAmount = Mathf.Min(objective.currentAmount + amount, objective.requiredAmount);
                    updated = true;
                }
            }
            if (updated)
            {
                Debug.Log($"[QuestManager] 任務 '{quest.questName}' 進度更新。");
                OnQuestUpdated?.Invoke(quest.questID);
            }
        }
    }

    // 為了讓對話系統能夠檢查物品，我們需要一個方法來同步收集類任務的進度
    public void SyncCollectionQuests()
    {
        foreach (var quest in activeQuests.Values)
        {
            bool updated = false;
            foreach (var objective in quest.objectives)
            {
                if (objective.type == QuestObjectiveType.Collect)
                {
                    Item item = ItemDatabase.Instance.GetItemByID(objective.targetID);
                    int itemCount = InventoryManager.Instance.GetItemCount(item);
                    if (objective.currentAmount != itemCount)
                    {
                        objective.currentAmount = itemCount;
                        updated = true;
                    }
                }
            }
            if (updated)
            {
                OnQuestUpdated?.Invoke(quest.questID);
            }
        }
    }

    // 給UI調用的方法
    public List<Quest> GetActiveQuests()
    {
        return activeQuests.Values.ToList();
    }
}
```
#### 3.2. `DialogueManager.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using System.Xml.Serialization;
using System.Linq;

public class DialogueManager : MonoBehaviour
{
    public static DialogueManager Instance { get; private set; }

    [Header("UI 引用")]
    [SerializeField] private DialogueUI dialogueUI;

    // 使用快取來儲存已載入的對話檔案
    // 鍵(string)是檔案的相對路徑，值(DialogueDatabase)是解析後的對話資料
    private Dictionary<string, DialogueDatabase> dialogueCache = new Dictionary<string, DialogueDatabase>();

    private Dialogue currentDialogue;
    private DialogueSegment currentSegment;
    // 追蹤當前對話是從哪個檔案載入的，方便後續查找
    private DialogueDatabase currentDialogueDB;
    private string currentNpcID; // 追蹤當前對話的 NPC

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // 動態載入並快取對話檔案
    // **[修正 1]** 參數名從 fileName 改為 relativePath，並在內部統一使用
    private DialogueDatabase LoadAndCacheDialogueFile(string relativePath)
    {
        // 如果已經快取過，直接返回快取的資料
        if (dialogueCache.ContainsKey(relativePath))
        {
            return dialogueCache[relativePath];
        }

        // 完整的 Resources 路徑
        string fullPath = $"GameData/Dialogues/{relativePath}";
        TextAsset xmlFile = Resources.Load<TextAsset>(fullPath);

        if (xmlFile == null)
        {
            // **[優化]** 錯誤訊息中也使用 fullPath
            Debug.LogError($"[DialogueManager] 找不到對話檔案於: Resources/{fullPath}.xml");
            return null;
        }

        XmlSerializer serializer = new XmlSerializer(typeof(DialogueDatabase));
        using (StringReader reader = new StringReader(xmlFile.text))
        {
            DialogueDatabase db = (DialogueDatabase)serializer.Deserialize(reader);
            // 存入快取
            // **[修正 2]** 快取的鍵應該是相對路徑
            dialogueCache[relativePath] = db; 
            // **[優化]** Log 訊息也使用相對路徑
            Debug.Log($"[DialogueManager] 成功載入並快取對話檔案: {relativePath}.xml");
            return db;
        }
    }

    // StartDialogue 方法現在需要檔案名和對話ID
    public void StartDialogue(string relativePath, string dialogueID, string npcID = null)
    {
        currentNpcID = npcID; // 保存 NPC ID
        // 載入 (或從快取讀取) 對應的對話檔案
        // **[修正 3]** 將 fileName 改為 relativePath
        currentDialogueDB = LoadAndCacheDialogueFile(relativePath);
        if (currentDialogueDB == null)
        {
            // **[優化]** 錯誤訊息也使用 relativePath
            Debug.LogError($"[DialogueManager] 無法開始對話，因為檔案 '{relativePath}.xml' 載入失敗。");
            return;
        }

        // 從載入的資料庫中尋找指定的對話ID
        currentDialogue = currentDialogueDB.dialogues.FirstOrDefault(d => d.dialogueID == dialogueID);
        if (currentDialogue != null && currentDialogue.segments.Count > 0)
        {
            // 預設從第一個 segment 開始
            ShowSegment(currentDialogue.segments[0].id);
        }
        else
        {
             Debug.LogError($"[DialogueManager] 在檔案 '{relativePath}.xml' 中找不到對話ID '{dialogueID}' 或該對話沒有任何片段。");
        }
    }

    // 顯示指定的對話片段
    private void ShowSegment(string segmentID)
    {
        currentSegment = currentDialogue.segments.FirstOrDefault(s => s.id == segmentID);
        if (currentSegment == null)
        {
            Debug.LogWarning($"[DialogueManager] 在當前對話中找不到片段ID '{segmentID}'。結束對話。");
            EndDialogue();
            return;
        }
        
        dialogueUI.ShowDialogue(currentSegment.speakerName, currentSegment.dialogueText);
        
        List<DialogueOption> availableOptions = new List<DialogueOption>();

        // 1. 處理靜態選項
        foreach (var option in currentSegment.options)
        {
            if (CheckDisplayConditions(option.displayConditions))
            {
                availableOptions.Add(option);
            }
        }

        // 2. 處理動態選項
        foreach (var dynamicRequest in currentSegment.dynamicOptions)
        {
            availableOptions.AddRange(GenerateDynamicOptions(dynamicRequest));
        }
        
        // 3. 處理 IsEnd 和沒有選項的情況
        if (currentSegment.isEnd && availableOptions.Count == 0)
        {
            // 自動生成一個離開選項
            availableOptions.Add(new DialogueOption 
            {
                text = "[離開]", 
                actions = new List<DialogueAction> { new DialogueAction { type = "EndDialogue" } } 
            });
        }

        if (availableOptions.Count > 0)
        {
            dialogueUI.ShowOptions(availableOptions, OnOptionSelected);
        }
    }

    // 動態生成選項的核心方法
    private List<DialogueOption> GenerateDynamicOptions(DynamicOptions request)
    {
        List<DialogueOption> generated = new List<DialogueOption>();
        string targetNpcID = (request.npcID == "self" && !string.IsNullOrEmpty(currentNpcID)) ? currentNpcID : request.npcID;

        if (request.source == "QuestManager")
        {
            List<Quest> quests = new List<Quest>();
            switch (request.type)
            {
                case "AvailableQuests":
                    quests = QuestManager.Instance.GetAvailableQuestsForNPC(targetNpcID);
                    break;
                case "InProgressOrCompletableQuests":
                    quests = QuestManager.Instance.GetInProgressOrCompletableQuestsForNPC(targetNpcID);
                    break;
            }

            foreach (var quest in quests)
            {
                DialogueOption newOption = new DialogueOption();
                newOption.text = request.optionTemplate.text.Replace("{questName}", quest.questName);
                
                // 處理動作
                newOption.actions = request.optionTemplate.actions.Select(a => new DialogueAction { 
                    type = a.type, 
                    value = a.value.Replace("{questID}", quest.questID) 
                }).ToList();
                
                // 處理分支
                if (request.optionTemplate.branch != null)
                {
                    newOption.branch = new DialogueBranch
                    {
                        check = new DialogueCheck
                        {
                            type = request.optionTemplate.branch.check.type,
                            value = request.optionTemplate.branch.check.value.Replace("{questID}", quest.questID)
                        },
                        trueActions = request.optionTemplate.branch.trueActions.Select(a => new DialogueAction { type = a.type, value = a.value.Replace("{questID}", quest.questID) }).ToList(),
                        falseActions = request.optionTemplate.branch.falseActions.Select(a => new DialogueAction { type = a.type, value = a.value.Replace("{questID}", quest.questID) }).ToList()
                    };
                }
                generated.Add(newOption);
            }
        }
        return generated;
    }

    // 當玩家選擇一個選項時
    private void OnOptionSelected(DialogueOption option)
    {
        if (option.branch != null && option.branch.check != null)
        {
            ProcessBranch(option.branch);
        }
        else
        {
            ProcessActions(option.actions);
        }
    }

    // 處理分支的方法
    private void ProcessBranch(DialogueBranch branch)
    {
        bool result = ExecuteCheck(branch.check);
        ProcessActions(result ? branch.trueActions : branch.falseActions);
    }

    // 執行單一條件檢查並返回布林值
    private bool ExecuteCheck(DialogueCheck check)
    {
        // "self" 關鍵字替換
        string checkValue = check.value;
        if (checkValue.Contains("self"))
        {
            checkValue = checkValue.Replace("self", currentNpcID);
        }
        
        string[] parts = checkValue.Split(',');
        string id = parts[0];
        
        switch (check.type)
        {
            case "QuestCheck":
                switch (id)
                {
                    case "HasAvailableQuests":
                        return QuestManager.Instance.HasAvailableQuests(parts[1]); // parts[1] is npcID
                    case "HasProgressOrCompletableQuests":
                        return QuestManager.Instance.HasProgressOrCompletableQuests(parts[1]); // parts[1] is npcID
                    case "IsCompletable":
                        return QuestManager.Instance.IsQuestCompletable(parts[1]); // parts[1] is questID
                }
                break;
        }
        Debug.LogWarning($"[DialogueManager] 未知的檢查類型或ID: {check.type}, {id}");
        return false;
    }

    // 檢查所有條件是否滿足
    private bool CheckDisplayConditions(List<DialogueCondition> conditions)
    {
        if (conditions == null || conditions.Count == 0) return true;

        foreach (var condition in conditions)
        {
            // (此處省略了實現，與您的原碼相同)
        }
        return true;
    }

    // 處理所有動作
    private void ProcessActions(List<DialogueAction> actions)
    {
        foreach (var action in actions)
        {
            string[] parts = new string[0];
            if (!string.IsNullOrEmpty(action.value))
            {
                parts = action.value.Split(',');
            }

            string id_or_filename = parts.Length > 0 ? parts[0].Trim() : "";
            string value_or_dialogueID = parts.Length > 1 ? parts[1].Trim() : "";

            switch (action.type)
            {
                case "GoToSegment":
                    ShowSegment(action.value);
                    return; 

                case "EndDialogue":
                    EndDialogue();
                    return;

                case "StartDialogue":
                    // **[修正 4]** 將內部宣告的 parts 變數改名為 dialogueParts，避免與外層衝突
                    string[] dialogueParts = action.value.Split(',');
                    if (dialogueParts.Length == 2)
                    {
                        string newRelativePath = dialogueParts[0].Trim();
                        string newDialogueID = dialogueParts[1].Trim();
                        StartDialogue(newRelativePath, newDialogueID, this.currentNpcID); 
                    }
                    else
                    {
                        Debug.LogError($"[DialogueManager] StartDialogue 動作的格式錯誤: '{action.value}'。應為 'filePath,dialogueID'。");
                    }
                    return;

                case "AcceptQuest":
                    QuestManager.Instance.AcceptQuest(action.value);
                    break;

                case "CompleteQuest":
                    QuestManager.Instance.CompleteQuest(action.value);
                    break;

                case "AddItem":
                    Item itemToAdd = ItemDatabase.Instance.GetItemByID(id_or_filename);
                    if (itemToAdd != null)
                    {
                        int.TryParse(value_or_dialogueID, out int amountToAdd);
                        if(amountToAdd > 0) InventoryManager.Instance.AddItem(itemToAdd, amountToAdd);
                    }
                    break;

                case "RemoveItem":
                    Item itemToRemove = ItemDatabase.Instance.GetItemByID(id_or_filename);
                    if (itemToRemove != null)
                    {
                        int.TryParse(value_or_dialogueID, out int amountToRemove);
                        if(amountToRemove > 0) InventoryManager.Instance.RemoveItem(itemToRemove, amountToRemove);
                    }
                    break;
                    
                default:
                    Debug.LogWarning($"[DialogueManager] 未知的動作類型: {action.type}");
                    break;
            }
        }
    }
    
    public void EndDialogue()
    {
        if (dialogueUI != null) dialogueUI.HideDialogue();
        currentDialogue = null;
        currentSegment = null;
        currentDialogueDB = null;
        currentNpcID = null;
    }
}
```
#### 3.3. `DialogueTrigger.cs`
```csharp
using UnityEngine;

public class DialogueTrigger : MonoBehaviour, IInteractable
{
    [Header("對話設定")]
    [Tooltip("此對話所在的 XML 檔案名稱 (不需要輸入 .xml 副檔名)")]
    [SerializeField] private string dialogueFileName;

    [Tooltip("要觸發的對話 ID (對應 XML 檔案中的 <Dialogue> 標籤的 id)")]
    [SerializeField] private string dialogueID;

    // 實現 IInteractable 接口，此方法由 Player 透過 E 鍵呼叫
    public void Interact()
    {
        if (string.IsNullOrEmpty(dialogueFileName) || string.IsNullOrEmpty(dialogueID))
        {
            Debug.LogWarning($"[DialogueTrigger] {gameObject.name} 未在 Inspector 中設定 dialogueFileName 或 dialogueID。");
            return;
        }
        
        Debug.Log($"[DialogueTrigger] 觸發對話: 檔案 '{dialogueFileName}', ID '{dialogueID}'");
        
        // 呼叫 DialogueManager，傳入檔案名和對話ID
        DialogueManager.Instance.StartDialogue(dialogueFileName, dialogueID);
    }
}
```
#### 3.4. `NPC.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;

[RequireComponent(typeof(Collider2D))]
public class NPC : MonoBehaviour, IInteractable
{
    [Header("NPC 資訊")]
    [Tooltip("唯一的 NPC ID，用於任務和對話系統的內部識別")]
    [SerializeField] private string npcID;
    
    [Header("任務設定")]
    [Tooltip("此 NPC 提供的所有任務 ID 列表")]
    [SerializeField] private List<string> availableQuestIDs = new List<string>();

    [Header("對話設定")]
    [Tooltip("此 NPC 的主要對話檔案路徑，相對於 'Resources/GameData/Dialogues/'。例如: 'NPCs/npc_mayor'")]
    [SerializeField] private string dialogueFileName;

    [Tooltip("與此 NPC 互動時的入口對話 ID")]
    [SerializeField] private string mainDialogueID;

    //[Header("功能設定")]
    //[Tooltip("此 NPC 是否為商人")]
    //[SerializeField] private bool isTrader = false;

    private void OnValidate()
    {
        // 確保此物件上的 Collider2D 是觸發器
        Collider2D col = GetComponent<Collider2D>();
        if (col != null && !col.isTrigger)
        {
            col.isTrigger = true;
        }
    }

    public string GetNpcID() => npcID;
    public List<string> GetQuestList() => availableQuestIDs;

    // 實現 IInteractable 接口，此方法由 Player 透過 E 鍵呼叫
    public void Interact()
    {
        Debug.Log($"[NPC] 與 {gameObject.name} (ID: {npcID}) 互動。");

        if (string.IsNullOrEmpty(dialogueFileName) || string.IsNullOrEmpty(mainDialogueID))
        {
            Debug.LogWarning($"[NPC] {gameObject.name} 未設定 dialogueFileName 或 mainDialogueID。");
            return;
        }

        QuestManager.Instance.SyncCollectionQuests();
        DialogueManager.Instance.StartDialogue(dialogueFileName, mainDialogueID, npcID);
    }
}
```

#### 3.5. `KeyManager.cs`

```csharp
using UnityEngine;

public class KeyManager : MonoBehaviour
{
    // 對玩家控制器的引用，用於執行拾取等動作
    private Player playerController;
    
    
    [Header("UI 面板引用 (可選)")]
    [SerializeField] private QuestUI questUI;
    [SerializeField] private PartyHolderUI partyHolderUI;
    [SerializeField] private PartyBattleUI partyBattleUI;
    // UI 面板的引用 (未來實作)
    // public GameObject mapPanel;
    // public GameObject systemMenuPanel;

    void Start()
    {
        playerController = FindObjectOfType<Player>();
        if (playerController == null)
        {
            Debug.LogError("[KeyManager] 找不到 Player 物件！");
        }
    }

    void Update()
    {
        // 持續偵測按鍵輸入

        // E鍵：對話
        if (Input.GetKeyDown(KeyCode.E))
        {
            HandleInteraction();
        }

        // I鍵：開啟/關閉背包
        if (Input.GetKeyDown(KeyCode.I))
        {
            InventoryManager.Instance.ToggleInventoryUI();
        }

        // 空白鍵：拾取物品
        if (Input.GetKeyDown(KeyCode.Space))
        {
            HandlePickup();
        }

        // Q鍵：開啟/關閉任務面板
        if (Input.GetKeyDown(KeyCode.Q))
        {
            if (questUI != null)
            {
                questUI.TogglePanel();
            }
            else
            {
                Debug.Log("[KeyManager] 按下 Q 鍵：(QuestUI 未指定)");
            }
        }

        // P鍵：開啟/關閉隊伍倉庫面板
        if (Input.GetKeyDown(KeyCode.P))
        {
            if (partyHolderUI != null)
            {
                partyHolderUI.TogglePanel();
            }
            else
            {
                Debug.LogWarning("[KeyManager] PartyHolderUI 未在 Inspector 中指定！");
            }
        }

        // B鍵：開啟/關閉戰鬥隊伍面板
        if (Input.GetKeyDown(KeyCode.B))
        {
            if (partyBattleUI != null)
            {
                partyBattleUI.TogglePanel();
            }
            else
            {
                Debug.LogWarning("[KeyManager] PartyBattleUI 未在 Inspector 中指定！");
            }
        }

        // M鍵：開啟/關閉地圖 (未來實作)
        if (Input.GetKeyDown(KeyCode.M))
        {
            Debug.Log("[KeyManager] 按下 M 鍵：(地圖功能尚未實作)");
            // if (mapPanel != null) mapPanel.SetActive(!mapPanel.activeSelf);
        }

        // ESC鍵：關閉最上層面板或開啟系統選單
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            HandleEscapeKey();
        }
    }

    private void HandleInteraction()
    {
        // 讓玩家控制器處理尋找最近的NPC
        if (playerController != null)
        {
            playerController.TryInteract();
        }
    }

    private void HandlePickup()
    {
        if (playerController != null)
        {
            playerController.TryPickupItem();
        }
    }

    private void HandleEscapeKey()
    {
        bool anyPanelWasClosed = false;

        // 優先關閉對話框 (因為它通常在最上層)
        if (DialogueManager.Instance != null && DialogueManager.Instance.isActiveAndEnabled)
        {
            // 這部分需要 DialogueManager 提供一個 IsDialogueActive 的屬性
            // 暫時先這樣處理，或者讓ESC關閉對話的功能直接寫在 DialogueManager 裡
        }
        
        // 檢查背包UI
        if (InventoryManager.Instance.playerInventoryUI != null && 
            InventoryManager.Instance.playerInventoryUI.gameObject.activeInHierarchy)
        {
            InventoryManager.Instance.CloseInventoryUI();
            anyPanelWasClosed = true;
        }
        // 檢查任務UI
        else if (questUI != null && questUI.gameObject.activeInHierarchy)
        {
            questUI.TogglePanel(); // 使用 Toggle 比較方便
            anyPanelWasClosed = true;
        }

        // 檢查隊伍倉庫UI
        else if (partyHolderUI != null && partyHolderUI.gameObject.activeInHierarchy)
        {
            partyHolderUI.TogglePanel();
            anyPanelWasClosed = true;
        }
        // 檢查戰鬥隊伍UI
        else if (partyBattleUI != null && partyBattleUI.gameObject.activeInHierarchy)
        {
            partyBattleUI.TogglePanel();
            anyPanelWasClosed = true;
        }
        
        if (!anyPanelWasClosed)
        {
            Debug.Log("[KeyManager] 按下 ESC：(開啟系統面板功能尚未實作)");
        }
    }
}
```

#### 3.6. `IInteractable.cs`
```csharp
// 讓 Player.cs 可以偵測到此物件並與之互動
public interface IInteractable
{
    void Interact();
}
```

### 第 4 部分：其他類別（`Player.cs`,`PlayerState.cs`）

#### 4.1. `Player.cs`
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// 確保 Player 物件上永遠有 Rigidbody2D 和 Collider2D 元件
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(Collider2D))]
public class Player : MonoBehaviour
{
    [Header("移動設定")]
    [SerializeField] private float moveSpeed = 5f;

    private Rigidbody2D rb;
    private Vector2 moveInput;

    // 分開管理物品和可互動物件
    private List<GroundItem> nearbyItems = new List<GroundItem>();
    private List<IInteractable> nearbyInteractables = new List<IInteractable>();

    [Header("隊伍初始設定")]
    [Tooltip("將定義玩家初始持有成員的 PartyDatabase 掛載於此。")]
    [SerializeField] private PartyDatabase initialMemberDatabase;
    private bool hasInitializedParty = false;

    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    void Start()
    {
        // 遊戲開始時，如果玩家沒有任何成員，則給予初始隊伍
        InitializeStartingParty();
    }

    void Update()
    {
        // 讀取玩家的移動輸入
        moveInput.x = Input.GetAxisRaw("Horizontal");
        moveInput.y = Input.GetAxisRaw("Vertical");

        if (moveInput.magnitude > 1)
        {
            moveInput.Normalize();
        }
    }

    void FixedUpdate()
    {
        // 在物理更新中移動角色
        rb.MovePosition(rb.position + moveInput * moveSpeed * Time.fixedDeltaTime);
    }
    
    // 這個 OnTriggerEnter2D 是關鍵。當 Player 的 Collider 進入另一個設為 "Trigger" 的 Collider 時，
    // Unity 會自動呼叫這個函式。BattleTrigger 就是利用這個機制來偵測玩家。
    // Player.cs 自身不需要寫偵測 BattleTrigger 的程式碼。
    private void OnTriggerEnter2D(Collider2D other)
    {
        // 物品偵測
        GroundItem item = other.GetComponent<GroundItem>();
        if (item != null && !nearbyItems.Contains(item))
        {
            nearbyItems.Add(item);
        }

        // 互動物件偵測
        IInteractable interactable = other.GetComponent<IInteractable>();
        if (interactable != null && !nearbyInteractables.Contains(interactable))
        {
            nearbyInteractables.Add(interactable);
            Debug.Log($"[Player] 進入可互動物件 '{other.gameObject.name}' 的範圍。");
        }
        
        // 注意：與 BattleTrigger 的互動邏輯寫在 BattleTrigger.cs 裡，而不是這裡。
        // 這樣可以保持 Player 腳本的乾淨，並且讓觸發器自己管理自己的邏輯。
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        GroundItem item = other.GetComponent<GroundItem>();
        if (item != null)
        {
            nearbyItems.Remove(item);
        }
        
        IInteractable interactable = other.GetComponent<IInteractable>();
        if (interactable != null)
        {
            nearbyInteractables.Remove(interactable);
            Debug.Log($"[Player] 離開可互動物件 '{other.gameObject.name}' 的範圍。");
        }
    }

    public void TryPickupItem()
    {
        nearbyItems.RemoveAll(item => item == null);
        if (nearbyItems.Count == 0) return;

        GroundItem closestItem = nearbyItems.OrderBy(item => 
            Vector2.Distance(transform.position, item.transform.position)
        ).FirstOrDefault();

        closestItem?.AttemptPickup();
    }
    
    public void TryInteract()
    {
        nearbyInteractables.RemoveAll(i => i == null || (i as MonoBehaviour) == null);
        
        if (nearbyInteractables.Count == 0)
        {
             Debug.Log("[Player] 附近沒有可互動的物件。");
            return;
        }

        IInteractable closestInteractable = nearbyInteractables.OrderBy(i => 
            Vector2.Distance(transform.position, (i as MonoBehaviour).transform.position)
        ).FirstOrDefault();
        
        if (closestInteractable != null)
        {
            closestInteractable.Interact();
        }
    }

    private void InitializeStartingParty()
    {
        if (hasInitializedParty || PartyManager.Instance == null) return;

        if (initialMemberDatabase == null || initialMemberDatabase.allMembers == null)
        {
            Debug.LogWarning("Player 物件上未指定初始成員資料庫，不新增任何初始成員。");
            return;
        }
        
        if (PartyManager.Instance.AllMembers.Count > 0)
        {
            Debug.Log("偵測到玩家已有成員(可能為讀檔)，跳過初始成員新增程序。");
            hasInitializedParty = true;
            return;
        }

        Debug.Log("正在根據 Player 物件上的設定初始化玩家隊伍...");
        foreach (var memberData in initialMemberDatabase.allMembers)
        {
            if (memberData != null)
            {
                PartyManager.Instance.AddMemberToHolder(memberData.memberID);
            }
        }
        
        // 假設初始隊伍的前幾位直接進入戰鬥隊伍
        var initialBattleParty = PartyManager.Instance.AllMembers.Take(4).ToList(); // 取前4位
        foreach (var member in initialBattleParty)
        {
            PartyManager.Instance.SetToBattleParty(member);
        }

        hasInitializedParty = true;
    }
}
```

#### 4.2. `PlayerState.cs`
```csharp
using UnityEngine;

public class PlayerState : MonoBehaviour
{
    [Header("玩家狀態")]
    [Tooltip("玩家目前擁有的金錢數量")]
    public int money = 0;

    // 未來可以增加更多狀態，例如：
    // public int level;
    // public float experience;

    // 這個腳本主要作為數據容器。
    // 背包數據由 InventoryManager 和 Inventory (ScriptableObject) 管理，
    // 所以這裡不需要直接引用背包。其他系統可以透過 FindObjectOfType<PlayerState>() 來存取玩家的金錢。

    public void AddMoney(int amount)
    {
        if (amount > 0)
        {
            money += amount;
            Debug.Log($"[PlayerState] 獲得金錢：{amount}。目前總額：{money}");
        }
    }

    public bool SpendMoney(int amount)
    {
        if (amount > 0 && money >= amount)
        {
            money -= amount;
            Debug.Log($"[PlayerState] 花費金錢：{amount}。目前餘額：{money}");
            return true;
        }
        else
        {
            Debug.LogWarning($"[PlayerState] 金錢不足！需要 {amount}, 但只有 {money}。");
            return false;
        }
    }
}
```

### 第 5 部分：隊伍資料結構 (`MemberDataSO.cs`, `PartyDatabase.cs`, `MemberInstance.cs`)

#### 5.1. `MemberDataSO.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewMemberData", menuName = "Party System/Member Data")]
public class MemberDataSO : ScriptableObject
{
    [Header("基礎資訊")]
    public string memberID; // 成員ID (獨一無二的編號)
    public string memberName; // 成員名稱
    public Sprite memberIcon; // 成員圖像
    public GameObject unitPrefab; // 成員單位預設Prefab

    [Header("基礎屬性")]
    public int baseHealth; // 基礎血量
    public int baseAttack; // 基礎攻擊力
    public int baseStamina; // 體力 (用於攻擊、施放技能)
    public int attackRange; // 基礎攻擊距離

    // 註解：移除行動點數，改為統一的體力值
    // public int attackActionPoints;
    // public int defenseActionPoints;

    [Header("技能槽位")]
    [Tooltip("在此輸入對應 SkillData 的技能ID")]
    public List<string> skillIDs; // 存放此成員擁有的技能ID列表

    [Header("成長規則 (暫不使用)")]
    // 根據您的要求，暫時註解掉成長相關屬性
    public int healthPerLevel; // 每級提升的血量
    public int attackPerLevel; // 每級提升的攻擊力
}
```

#### 5.2. `PartyDatabase.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

[CreateAssetMenu(fileName = "PartyDatabase", menuName = "Party System/Party Database")]
public class PartyDatabase : ScriptableObject
{
    public List<MemberDataSO> allMembers;

    // 使用字典來加速查找，避免每次都遍歷列表
    private static Dictionary<string, MemberDataSO> memberDictionary;

    // 在遊戲啟動時或編輯器中啟用時，建立字典
    private void OnEnable()
    {
        if (allMembers == null)
        {
            allMembers = new List<MemberDataSO>();
        }

        // 使用 LINQ 快速建立字典
        memberDictionary = allMembers.ToDictionary(member => member.memberID, member => member);
        Debug.Log("隊伍資料庫已載入，共 " + memberDictionary.Count + " 名成員。");
    }

    // 提供一個全局靜態方法來透過ID獲取成員模板數據
    public static MemberDataSO GetMemberDataByID(string id)
    {
        if (memberDictionary == null)
        {
            Debug.LogError("隊伍資料庫尚未初始化！請確保它被載入。");
            return null;
        }

        memberDictionary.TryGetValue(id, out MemberDataSO data);
        if (data == null)
        {
            Debug.LogWarning($"在資料庫中找不到ID為 '{id}' 的成員資料。");
        }
        return data;
    }
}
```

#### 5.3. `MemberInstance.cs`

```csharp
using System;

[System.Serializable]
public class MemberInstance
{
    public string memberDataSO_ID;  // 關聯到 MemberDataSO 的 ID
    public string instanceID;       // 每個實例獨一無二的識別碼
    public int level;
    public int experience;

    // 狀態屬性 (這些是計算屬性，不會被序列化到JSON中，以節省空間並確保數據一致性)
    // [NonSerialized] 標記確保這些欄位不會被存檔
    [NonSerialized]
    private MemberDataSO _baseData;
    public MemberDataSO BaseData
    {
        get
        {
            // 延遲載入，僅在需要時才從資料庫獲取
            if (_baseData == null)
            {
                _baseData = PartyDatabase.GetMemberDataByID(memberDataSO_ID);
            }
            return _baseData;
        }
    }

    public int MaxHP => BaseData != null ? BaseData.baseHealth + (level - 1) * BaseData.healthPerLevel : 0;
    public int CurrentAttack => BaseData != null ? BaseData.baseAttack + (level - 1) * BaseData.attackPerLevel : 0;

    // 實際存檔的欄位
    public int currentHP;

    // 構造函數，用於創建一個新的成員實例
    public MemberInstance(string so_id, int startLevel = 1)
    {
        memberDataSO_ID = so_id;
        instanceID = Guid.NewGuid().ToString(); // 產生一個唯一的ID
        level = startLevel;
        experience = 0;

        // 初始化當前HP為最大HP
        currentHP = MaxHP;
    }

    // JSON反序列化後需要一個無參數的構造函數
    public MemberInstance() { }
}
```


### 第 6 部分：隊伍系統UI (`MemberCardUI.cs`, `MemberStatCardUI.cs`, `PartyHolderUI.cs`, `PartyBattleUI.cs`, `PartyDetailUI.cs`)

#### 6.1. `MemberCardUI.cs`

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.EventSystems;

public class MemberCardUI : MonoBehaviour
{
    [SerializeField] private Image memberIconImage;
    [SerializeField] private TextMeshProUGUI memberNameText;
    [SerializeField] private Button cardButton;
    [SerializeField] private GameObject selectedBorder; // 用於顯示選中狀態的邊框
    [SerializeField] private GameObject inBattleIndicator; // 用於顯示在戰鬥隊伍中的標示

    private MemberInstance currentMember;

    // 填充卡片資料
    public void Setup(MemberInstance memberInstance, System.Action<MemberInstance> onClickCallback)
    {
        currentMember = memberInstance;

        // 從 BaseData 獲取靜態資訊
        memberNameText.text = currentMember.BaseData.memberName;
        memberIconImage.sprite = currentMember.BaseData.memberIcon;

        // 設定按鈕點擊事件
        cardButton.onClick.RemoveAllListeners();
        cardButton.onClick.AddListener(() => onClickCallback(currentMember));
    }

    // 更新卡片的視覺狀態
    public void UpdateVisualState(bool isSelected, bool isInBattleParty)
    {
        if (selectedBorder != null)
        {
            selectedBorder.SetActive(isSelected);
        }
        if (inBattleIndicator != null)
        {
            inBattleIndicator.SetActive(isInBattleParty);
        }
    }
}
```

#### 6.2. `MemberStatCardUI.cs`

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class MemberStatCardUI : MonoBehaviour
{
    [Header("基礎連結")]
    [SerializeField] private Image memberIconImage;
    [SerializeField] private TextMeshProUGUI memberNameText;
    [SerializeField] private Button cardButton;
    [SerializeField] private GameObject selectedBorder;

    [Header("屬性連結")]
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI attackText;
    [SerializeField] private TextMeshProUGUI attackAPText;
    [SerializeField] private TextMeshProUGUI defenseAPText;

    private MemberInstance currentMember;

    // 填充卡片資料，包含詳細屬性
    public void Setup(MemberInstance memberInstance, System.Action<MemberInstance> onClickCallback)
    {
        currentMember = memberInstance;
        MemberDataSO baseData = currentMember.BaseData;

        // 填充基礎資訊
        memberNameText.text = baseData.memberName;
        memberIconImage.sprite = baseData.memberIcon;

        // 填充戰鬥屬性
        hpText.text = $"HP: {currentMember.currentHP}/{currentMember.MaxHP}";
        attackText.text = $"ATK: {currentMember.CurrentAttack}";
        attackAPText.text = $"攻: {baseData.attackActionPoints} AP";
        defenseAPText.text = $"防: {baseData.defenseActionPoints} AP";

        // 設定按鈕點擊事件
        cardButton.onClick.RemoveAllListeners();
        cardButton.onClick.AddListener(() => onClickCallback(currentMember));
    }

    // 更新卡片的視覺狀態
    public void UpdateVisualState(bool isSelected)
    {
        if (selectedBorder != null)
        {
            selectedBorder.SetActive(isSelected);
        }
    }
}
```

#### 6.3. `PartyHolderUI.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

public class PartyHolderUI : MonoBehaviour
{
    [SerializeField] private GameObject holderPanel;
    [SerializeField] private Transform contentParent; // Scroll View 的 Content
    [SerializeField] private MemberCardUI cardPrefab;

    private List<MemberCardUI> spawnedCards = new List<MemberCardUI>();

    private void Awake()
    {
        if (holderPanel == null) holderPanel = this.gameObject; // 如果沒指定，就用掛載此腳本的物件
        holderPanel.SetActive(false);
    }

    private void OnEnable()
    {
        PartyManager.OnPartyUpdated += UpdateUI;
    }

    private void OnDisable()
    {
        PartyManager.OnPartyUpdated -= UpdateUI;

        if (PartyDetailUI.Instance != null)
        {
            PartyDetailUI.Instance.Hide();
        }
    }

    // 切換面板顯示/隱藏的方法
    public void TogglePanel()
    {
        bool isActive = !holderPanel.activeSelf;
        holderPanel.SetActive(isActive);

        // 只有在打開面板時才更新UI，節省效能
        if (isActive)
        {
            UpdateUI();
        }
    }

    private void UpdateUI()
    {
        // 清理舊的卡片
        foreach (var card in spawnedCards)
        {
            Destroy(card.gameObject);
        }
        spawnedCards.Clear();

        // 根據 PartyManager 的資料生成新卡片
        foreach (var member in PartyManager.Instance.AllMembers)
        {
            MemberCardUI newCard = Instantiate(cardPrefab, contentParent);
            newCard.Setup(member, OnMemberCardClicked);
            
            // 假設 PartyDetailUI 也是單例
            bool isSelected = PartyDetailUI.Instance != null && PartyDetailUI.Instance.IsShowingDetailsFor(member);
            bool isInBattle = PartyManager.Instance.BattleParty.Contains(member);
            newCard.UpdateVisualState(isSelected, isInBattle);
            
            spawnedCards.Add(newCard);
        }
    }

    private void OnMemberCardClicked(MemberInstance member)
    {
        // 通知詳細資料面板顯示
        PartyDetailUI.Instance.ShowMemberDetails(member);
        // 再次刷新UI以更新選中狀態
        UpdateUI(); 
    }
}
```

#### 6.4. `PartyBattleUI.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

public class PartyBattleUI : MonoBehaviour
{
    [SerializeField] private GameObject battlePanel;
    [SerializeField] private Transform battleSlotsParent; // 存放戰鬥隊伍卡片的容器
    
    // 將 Prefab 的類型從 MemberCardUI 改為 MemberStatCardUI
    [SerializeField] private MemberStatCardUI cardPrefab; 

    // 列表的類型也需要同步修改
    private List<MemberStatCardUI> spawnedCards = new List<MemberStatCardUI>();

    private void Awake()
    {
        if (battlePanel == null) battlePanel = this.gameObject; // 如果沒指定，就用掛載此腳本的物件
        battlePanel.SetActive(false);
    }

    private void OnEnable()
    {
        PartyManager.OnPartyUpdated += UpdateUI;
    }

    private void OnDisable()
    {
        PartyManager.OnPartyUpdated -= UpdateUI;

        if (PartyDetailUI.Instance != null)
        {
            PartyDetailUI.Instance.Hide();
        }
    }

    // 切換面板顯示/隱藏的方法
    public void TogglePanel()
    {
        bool isActive = !battlePanel.activeSelf;
        battlePanel.SetActive(isActive);

        if (isActive)
        {
            UpdateUI();
        }
    }

    private void UpdateUI()
    {
        foreach (var card in spawnedCards)
        {
            Destroy(card.gameObject);
        }
        spawnedCards.Clear();

        foreach (var member in PartyManager.Instance.BattleParty)
        {
            // 實例化新的 Prefab
            MemberStatCardUI newCard = Instantiate(cardPrefab, battleSlotsParent);
            newCard.Setup(member, OnMemberCardClicked);
            
            bool isSelected = PartyDetailUI.Instance != null && PartyDetailUI.Instance.IsShowingDetailsFor(member);
            
            // UpdateVisualState 不再需要 is_in_battle 參數
            newCard.UpdateVisualState(isSelected);
            
            spawnedCards.Add(newCard);
        }
    }

    private void OnMemberCardClicked(MemberInstance member)
    {
        // 點擊後依然是顯示最詳細的 PartyDetailUI 面板
        PartyDetailUI.Instance.ShowMemberDetails(member);
        
        // 為了更新所有卡片的選中框，手動觸發一次刷新
        UpdateUI();
    }
}
```

#### 6.5. `PartyDetailUI.cs`

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class PartyDetailUI : MonoBehaviour
{
    public static PartyDetailUI Instance { get; private set; }
    
    [Header("UI 連結")]
    [SerializeField] private GameObject detailPanel;
    [SerializeField] private Image memberIcon;
    [SerializeField] private TextMeshProUGUI memberNameText;
    // *** 移除: [SerializeField] private TextMeshProUGUI levelText; ***
    // *** 移除: [SerializeField] private TextMeshProUGUI expText; ***
    [SerializeField] private TextMeshProUGUI hpText;
    [SerializeField] private TextMeshProUGUI attackText;
    [SerializeField] private TextMeshProUGUI attackAPText;
    [SerializeField] private TextMeshProUGUI defenseAPText;

    [Header("互動元件")]
    [SerializeField] private Button actionButton;
    [SerializeField] private TextMeshProUGUI actionButtonText;
    [SerializeField] private Button closeButton;

    private MemberInstance currentMember;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        
        detailPanel.SetActive(false);
        closeButton.onClick.AddListener(Hide);
    }

    public void ShowMemberDetails(MemberInstance member)
    {
        currentMember = member;
        detailPanel.SetActive(true);
        MemberDataSO baseData = member.BaseData; // 先獲取基礎資料，方便取用

        // 填充資料
        memberIcon.sprite = baseData.memberIcon;
        memberNameText.text = baseData.memberName;
        hpText.text = $"生命值: {member.currentHP} / {member.MaxHP}";
        attackText.text = $"攻擊力: {member.CurrentAttack}";
        attackAPText.text = $"攻擊行動點: {baseData.attackActionPoints}";
        defenseAPText.text = $"防禦行動點: {baseData.defenseActionPoints}";

        // *** 移除以下兩行 ***
        // levelText.text = $"等級: {member.level}";
        // expText.text = $"經驗值: {member.experience} / 100"; 

        // 根據成員是否在戰鬥隊伍中，更新按鈕功能和文字 (此邏輯不變)
        bool isInBattleParty = PartyManager.Instance.BattleParty.Contains(member);
        if (isInBattleParty)
        {
            actionButtonText.text = "移除";
            actionButton.onClick.RemoveAllListeners();
            actionButton.onClick.AddListener(RemoveFromBattleParty);
        }
        else
        {
            actionButtonText.text = "上陣";
            actionButton.onClick.RemoveAllListeners();
            actionButton.onClick.AddListener(AddToBattleParty);
        }
    }

    public void Hide()
    {
        currentMember = null;
        detailPanel.SetActive(false);
        
        if (PartyManager.Instance != null)
        {
            PartyManager.Instance.NotifyPartyUpdated();
        }
    }
    
    public bool IsShowingDetailsFor(MemberInstance member)
    {
        return detailPanel.activeSelf && currentMember == member;
    }

    private void AddToBattleParty()
    {
        if (currentMember != null)
        {
            PartyManager.Instance.SetToBattleParty(currentMember);
            ShowMemberDetails(currentMember); // 重新調用以更新按鈕狀態
        }
    }

    private void RemoveFromBattleParty()
    {
        if (currentMember != null)
        {
            PartyManager.Instance.RemoveFromBattleParty(currentMember);
            ShowMemberDetails(currentMember); // 重新調用以更新按鈕狀態
        }
    }
}
```

### 第 7 部分：隊伍核心管理器與組件 (`PartyManager.cs`, `JSONSaveManager.cs`)

#### 7.1. `PartyManager.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class PartyManager : MonoBehaviour
{
    // 使用單例模式確保全局只有一個 PartyManager
    public static PartyManager Instance { get; private set; }

    [Header("隊伍設定")]
    [SerializeField] private int maxBattlePartySize = 4;

    [Header("玩家隊伍資料")]
    public List<MemberInstance> AllMembers; // 玩家擁有的所有成員
    public List<MemberInstance> BattleParty; // 當前出戰的成員

    // 全局事件，當隊伍資料更新時觸發
    public static event System.Action OnPartyUpdated;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject); // 確保在場景切換時管理器不被銷毀

        AllMembers = new List<MemberInstance>();
        BattleParty = new List<MemberInstance>();
    }

    // 將指定ID的成員加入到玩家的倉庫 (Holder)
    public void AddMemberToHolder(string memberID)
    {
        MemberDataSO data = PartyDatabase.GetMemberDataByID(memberID);
        if (data != null)
        {
            // 檢查是否已存在同類型的成員（可選，根據遊戲設計決定是否允許重複）
            // 為求簡單，此處允許玩家擁有多個同類型的成員
            MemberInstance newMember = new MemberInstance(memberID);
            AllMembers.Add(newMember);
            Debug.Log($"已將成員 [{data.memberName}] 加入到玩家的倉庫 (Holder)。");
            OnPartyUpdated?.Invoke(); // 觸發事件，通知UI刷新
        }
        else
        {
            Debug.LogWarning($"嘗試新增ID為 '{memberID}' 的成員失敗，在資料庫中找不到該成員。");
        }
    }

    // 將成員設置到戰鬥隊伍
    public void SetToBattleParty(MemberInstance member)
    {
        if (BattleParty.Count >= maxBattlePartySize)
        {
            Debug.LogWarning("戰鬥隊伍已滿，無法新增！");
            return;
        }
        if (!BattleParty.Contains(member) && AllMembers.Contains(member))
        {
            BattleParty.Add(member);
            OnPartyUpdated?.Invoke();
        }
    }

    // 從戰鬥隊伍中移除成員
    public void RemoveFromBattleParty(MemberInstance member)
    {
        if (BattleParty.Contains(member))
        {
            BattleParty.Remove(member);
            OnPartyUpdated?.Invoke();
        }
    }

    // 交換戰鬥成員的順序
    public void SwapBattlePartyOrder(int fromIndex, int toIndex)
    {
        if (fromIndex < 0 || fromIndex >= BattleParty.Count || toIndex < 0 || toIndex >= BattleParty.Count)
        {
            return;
        }
        MemberInstance temp = BattleParty[fromIndex];
        BattleParty[fromIndex] = BattleParty[toIndex];
        BattleParty[toIndex] = temp;
        OnPartyUpdated?.Invoke();
    }

    // 判斷是否有可戰鬥的成員
    public bool HasBattleReadyMembers()
    {
        return BattleParty.Any(member => member.currentHP > 0);
    }

    // 提供一個公開的方法讓外部系統可以請求UI刷新
    public void NotifyPartyUpdated()
    {
        Debug.Log("PartyManager 收到通知，正在觸發 OnPartyUpdated 事件。");
        OnPartyUpdated?.Invoke();
    }
    
    // 觸發存檔
    public void SaveParty()
    {
        JSONSaveManager.SavePartyData(AllMembers, BattleParty.Select(m => m.instanceID).ToList());
        Debug.Log("隊伍資料已儲存。");
    }

    // 觸發載入
    public void LoadParty()
    {
        PartySaveData saveData = JSONSaveManager.LoadPartyData();
        if (saveData != null)
        {
            AllMembers = saveData.AllMembers;
            
            // 根據存檔中的ID順序重建戰鬥隊伍
            BattleParty.Clear();
            foreach (string instanceId in saveData.BattlePartyInstanceIDs)
            {
                MemberInstance member = AllMembers.FirstOrDefault(m => m.instanceID == instanceId);
                if (member != null)
                {
                    BattleParty.Add(member);
                }
            }
            Debug.Log("隊伍資料已載入。");
            OnPartyUpdated?.Invoke();
        }
    }
}
```

#### 7.2. `JSONSaveManager.cs`

```csharp
using UnityEngine;
using System.IO;
using System.Collections.Generic;

// 一個輔助類，因為 Unity 的 JsonUtility 無法直接序列化根層級的 List
[System.Serializable]
public class PartySaveData
{
    public List<MemberInstance> AllMembers;
    public List<string> BattlePartyInstanceIDs; // 只儲存戰鬥隊伍的 instanceID 來重建
}

public static class JSONSaveManager
{
    private static readonly string fileName = "PartyData.json";

    // 獲取存檔路徑
    private static string GetSavePath()
    {
        return Path.Combine(Application.persistentDataPath, fileName);
    }

    // 儲存隊伍資料
    public static void SavePartyData(List<MemberInstance> allMembers, List<string> battlePartyInstanceIDs)
    {
        PartySaveData saveData = new PartySaveData
        {
            AllMembers = allMembers,
            BattlePartyInstanceIDs = battlePartyInstanceIDs
        };

        string json = JsonUtility.ToJson(saveData, true); // true 讓JSON格式化，方便閱讀
        File.WriteAllText(GetSavePath(), json);
    }

    // 載入隊伍資料
    public static PartySaveData LoadPartyData()
    {
        string path = GetSavePath();
        if (File.Exists(path))
        {
            string json = File.ReadAllText(path);
            PartySaveData saveData = JsonUtility.FromJson<PartySaveData>(json);

            // (可選) 資料驗證
            if (saveData != null && saveData.AllMembers != null)
            {
                // 移除在當前遊戲版本中已不存在的成員
                saveData.AllMembers.RemoveAll(instance => PartyDatabase.GetMemberDataByID(instance.memberDataSO_ID) == null);
            }

            return saveData;
        }
        else
        {
            Debug.Log("找不到存檔檔案，將創建新的隊伍資料。");
            return null;
        }
    }
}
```